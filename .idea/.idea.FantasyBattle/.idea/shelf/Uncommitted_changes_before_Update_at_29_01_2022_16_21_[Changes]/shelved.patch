Index: Source/FantasyBattle/Private/Mode/GM_FantasyBattle_Play.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Source/FantasyBattle/Private/Mode/GM_FantasyBattle_Play.cpp b/Source/FantasyBattle/Private/Mode/GM_FantasyBattle_Play.cpp
new file mode 100644
--- /dev/null	(date 1642107068000)
+++ b/Source/FantasyBattle/Private/Mode/GM_FantasyBattle_Play.cpp	(date 1642107068000)
@@ -0,0 +1,5 @@
+// Fill out your copyright notice in the Description page of Project Settings.
+
+
+#include "Mode/GM_FantasyBattle_Play.h"
+
Index: Source/FantasyBattle/Private/Mode/PC_FantasyBattle_PreGame.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Source/FantasyBattle/Private/Mode/PC_FantasyBattle_PreGame.cpp b/Source/FantasyBattle/Private/Mode/PC_FantasyBattle_PreGame.cpp
new file mode 100644
--- /dev/null	(date 1643469131170)
+++ b/Source/FantasyBattle/Private/Mode/PC_FantasyBattle_PreGame.cpp	(date 1643469131170)
@@ -0,0 +1,143 @@
+// Fill out your copyright notice in the Description page of Project Settings.
+
+#include "Mode/PC_FantasyBattle_PreGame.h"
+
+#include "FantasyBattle_GI.h"
+#include "Interfaces/OnlineIdentityInterface.h"
+#include "GameFramework/PlayerState.h"
+#include "Mode/GS_PreGame.h"
+#include "Mode/PS_PreGame.h"
+
+
+void APC_FantasyBattle_PreGame::BeginPlay()
+{
+	Super::BeginPlay();
+	
+	SetInputMode(FInputModeGameAndUI());
+	SetShowMouseCursor(true);
+	
+	UE_LOG(LogTemp, Warning, TEXT("Begin Play is running Player Controller"));
+	if (IsLocalController())
+	{
+		UFantasyBattle_GI* GI = Cast<UFantasyBattle_GI>(GetGameInstance());
+		if (GI)
+		{
+			if (!GI->IsInSession())
+			{
+				GI->ShowMainMenu();
+			}
+			AvailableArmies = GI->GetSaveGameList();
+		}	
+	}
+}
+
+void APC_FantasyBattle_PreGame::C_GameStarting_Implementation()
+{
+}
+
+void APC_FantasyBattle_PreGame::SetIsReady(bool newValue)
+{
+	APS_PreGame* PS = Cast<APS_PreGame>(PlayerState);
+	if (PS)
+	{
+		PS->SetIsReady(newValue);
+	}
+}
+
+void APC_FantasyBattle_PreGame::SetArmy(int32 ArrayIndex)
+{
+	SelectedArmy = AvailableArmies[ArrayIndex];
+}
+
+void APC_FantasyBattle_PreGame::UpdateCountDownTimer(int32 TimeLeft)
+{
+	if (!LobbyMenuPtr || TimeLeft == 0) return;
+
+	LobbyMenuPtr->UpdateCountDownTimer(TimeLeft);
+}
+
+void APC_FantasyBattle_PreGame::NewPlayerJoined_Implementation(const FUniqueNetIdRepl& PlayerID)
+{
+	UnfoundPlayers.Add(PlayerID);
+	if (!GetWorldTimerManager().IsTimerActive(LookingForPlayerTimer))
+	{
+		GetWorldTimerManager().SetTimer(LookingForPlayerTimer, this, &APC_FantasyBattle_PreGame::LookingForPlayer, 0.5f, true);
+	}
+}
+
+void APC_FantasyBattle_PreGame::WaitingForPS()
+{
+	if (IsValid(PlayerState) && IsValid(LobbyMenuPtr))
+	{
+		UE_LOG(LogTemp, Warning, TEXT("Found PlayerState and lobby in Waiting for PS"));
+		LobbyMenuPtr->SetupMenu(PlayerState->GetPlayerId(), PlayerState->GetPlayerName());
+		GetWorldTimerManager().ClearTimer(WaitingForPlayerStateTimer);
+		AGS_PreGame* GS = GetWorld()->GetGameState<AGS_PreGame>();
+		if (GS)
+		{
+			LobbyMenuPtr->SetupArmyInfo(GS->GetMaxArmySize(), AvailableArmies);
+			bInitializedLobbyGameInfo = true;
+			
+			for (APlayerState* PS : GS->PlayerArray)
+			{
+				if (PS->GetPlayerId() != PlayerState->GetPlayerId())
+				{
+					LobbyMenuPtr->CreatePlayerWidget(PS->GetPlayerName(), PS->GetPlayerId());
+				}
+			}
+		}
+	}
+}
+
+void APC_FantasyBattle_PreGame::LookingForPlayer()
+{
+	AGameStateBase* GS = GetWorld()->GetGameState();
+	if (GS)
+	{
+		for (APlayerState* PS : GS->PlayerArray)
+		{
+			if (UnfoundPlayers.Contains(PS->GetUniqueId()))
+			{
+				UnfoundPlayers.Remove(PS->GetUniqueId().GetUniqueNetId());
+				LobbyMenuPtr->CreatePlayerWidget(PS->GetPlayerName(), PS->GetPlayerId());
+			}
+		}
+	}
+	if (UnfoundPlayers.Num() == 0)
+	{
+		GetWorldTimerManager().ClearTimer(LookingForPlayerTimer);
+	}
+}
+
+
+void APC_FantasyBattle_PreGame::C_InitPC_Implementation()
+{
+	if (IsLocalController())
+	{
+		UFantasyBattle_GI* GI = Cast<UFantasyBattle_GI>(GetGameInstance());
+		if (GI)
+		{
+			if (GI->IsInSession())
+			{
+				LobbyMenuPtr = GI->ShowLobbyMenu();
+				LobbyMenuPtr->SetLobbyInterface(this);
+				bInitializedLobbyGameInfo = false;
+				AGS_PreGame* GS = Cast<AGS_PreGame>(GetWorld()->GetGameState());
+				if (GS)
+				{
+					LobbyMenuPtr->SetupArmyInfo(GS->GetMaxArmySize(), AvailableArmies);
+					bInitializedLobbyGameInfo = true;
+					
+				}
+				UE_LOG(LogTemp, Warning, TEXT("PlayerState Cast: %d, LobbyMenu Variabel: %d"), IsValid(PlayerState), IsValid(LobbyMenuPtr));
+				if (IsValid(PlayerState) && IsValid(LobbyMenuPtr))
+				{
+					LobbyMenuPtr->SetupMenu(PlayerState->GetPlayerId(), PlayerState->GetPlayerName());
+				}
+				else
+					GetWorldTimerManager().SetTimer(WaitingForPlayerStateTimer, this, &APC_FantasyBattle_PreGame::WaitingForPS, 0.5f, true);
+			}	
+		}
+	}
+}
+
Index: Source/FantasyBattle/Private/Mode/GS_FantasyBattle_Play.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Source/FantasyBattle/Private/Mode/GS_FantasyBattle_Play.cpp b/Source/FantasyBattle/Private/Mode/GS_FantasyBattle_Play.cpp
new file mode 100644
--- /dev/null	(date 1642107272000)
+++ b/Source/FantasyBattle/Private/Mode/GS_FantasyBattle_Play.cpp	(date 1642107272000)
@@ -0,0 +1,5 @@
+// Fill out your copyright notice in the Description page of Project Settings.
+
+
+#include "Mode/GS_FantasyBattle_Play.h"
+
Index: Source/FantasyBattle/Private/Mode/GS_PreGame.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Source/FantasyBattle/Private/Mode/GS_PreGame.cpp b/Source/FantasyBattle/Private/Mode/GS_PreGame.cpp
new file mode 100644
--- /dev/null	(date 1643456735053)
+++ b/Source/FantasyBattle/Private/Mode/GS_PreGame.cpp	(date 1643456735053)
@@ -0,0 +1,96 @@
+// Fill out your copyright notice in the Description page of Project Settings.
+
+
+#include "Mode/GS_PreGame.h"
+
+#include "Mode/GM_PreGame.h"
+#include "Mode/PC_FantasyBattle_PreGame.h"
+#include "Mode/PS_PreGame.h"
+#include "Net/UnrealNetwork.h"
+
+void AGS_PreGame::RunReadyCheck()
+{
+	if (IsEveryoneReady())
+	{
+		GameStarting();
+		GetWorldTimerManager().SetTimer(GameStartDelay, this, &AGS_PreGame::CountDown, 1.0f, true);
+		UE_LOG(LogTemp, Warning, TEXT("Every1 is Ready"));
+	}
+}
+
+void AGS_PreGame::GameStarting()
+{
+}
+
+bool AGS_PreGame::IsEveryoneReady()
+{
+	if (PlayerArray.Num() < 2) return false;
+
+	for (APlayerState* PS : PlayerArray)
+	{
+		APS_PreGame* LobbyPS = Cast<APS_PreGame>(PS);
+		if (LobbyPS)
+		{
+			if (!LobbyPS->GetIsReady())
+				return false;
+		}
+	}
+	return true;
+}
+
+void AGS_PreGame::CountDown()
+{
+	TimeToGameStart--;
+	if (!IsRunningDedicatedServer())
+	{
+		OnRep_TimeToGameStartChanged();
+	}
+	if (TimeToGameStart == 0)
+	{
+		GetWorldTimerManager().ClearTimer(GameStartDelay);
+		for (APlayerState* PS : PlayerArray)
+		{
+			APC_FantasyBattle_PreGame* LobbyPC = Cast<APC_FantasyBattle_PreGame>(PS->GetOwner());
+			if (LobbyPC)
+			{
+				LobbyPC->C_GameStarting();
+			}
+		}
+		AGM_PreGame* GM = Cast<AGM_PreGame>(GetWorld()->GetAuthGameMode());
+		if (GM)
+		{
+			GM->StartGame();
+		}
+	}
+}
+
+void AGS_PreGame::OnRep_TimeToGameStartChanged()
+{
+	APC_FantasyBattle_PreGame* PC = Cast<APC_FantasyBattle_PreGame>(GetWorld()->GetFirstPlayerController());
+	if (PC)
+	{
+		 PC->UpdateCountDownTimer(TimeToGameStart);
+	}
+}
+
+void AGS_PreGame::OnRep_MaxArmySizeChanged()
+{
+}
+
+void AGS_PreGame::SetMaxArmySize_Implementation(int32 NewMax)
+{
+	MaxArmySize = NewMax;
+}
+
+bool AGS_PreGame::SetMaxArmySize_Validate(int32 NewMax)
+{
+	return true;
+}
+
+void AGS_PreGame::GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const
+{
+	Super::GetLifetimeReplicatedProps(OutLifetimeProps);
+
+	DOREPLIFETIME(AGS_PreGame, TimeToGameStart);
+	DOREPLIFETIME(AGS_PreGame, MaxArmySize);
+}
\ No newline at end of file
Index: Source/FantasyBattle/Private/UI/Lobbby/UI_LobbyMenu.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Source/FantasyBattle/Private/UI/Lobbby/UI_LobbyMenu.cpp b/Source/FantasyBattle/Private/UI/Lobbby/UI_LobbyMenu.cpp
new file mode 100644
--- /dev/null	(date 1643469341995)
+++ b/Source/FantasyBattle/Private/UI/Lobbby/UI_LobbyMenu.cpp	(date 1643469341995)
@@ -0,0 +1,82 @@
+// Fill out your copyright notice in the Description page of Project Settings.
+
+
+#include "UI/Lobbby/UI_LobbyMenu.h"
+
+#include "Components/BackgroundBlur.h"
+#include "Components/Button.h"
+#include "Components/ComboBoxString.h"
+#include "Components/TextBlock.h"
+
+bool UUI_LobbyMenu::Initialize()
+{
+	bool Success = Super::Initialize();
+	if (!Success) return false;
+
+	bIsReady = false;
+	
+	if (Ready_Btn)
+		Ready_Btn->OnClicked.AddDynamic(this, &UUI_LobbyMenu::ReadyClick);
+
+	if (Armies_Combo)
+		Armies_Combo->OnSelectionChanged.AddDynamic(this, &UUI_LobbyMenu::ArmySelectionChanged);
+	
+	return true;
+}
+
+void UUI_LobbyMenu::SetupMenu(int32 OwnerID, FString PlayerName)
+{
+	ParentID = OwnerID;
+	CreatePlayerWidget(PlayerName, OwnerID);
+}
+
+void UUI_LobbyMenu::SetupArmyInfo(int32 MaxSize, TArray<FArmyStat> Armies)
+{
+	ArmySize_Text->SetText(FText::FromString(FString::FromInt(MaxSize) + " pts."));
+	for (FArmyStat Army : Armies)
+	{
+		Armies_Combo->AddOption(Army.ArmyName);
+	}
+	Armies_Combo->SetSelectedIndex(0);
+}
+
+void UUI_LobbyMenu::SetLobbyInterface(ILobbyInterface* Interface)
+{
+	LobbyInterface = Interface;
+}
+
+void UUI_LobbyMenu::UpdateCountDownTimer(int32 TimeLeft)
+{
+	
+}
+
+void UUI_LobbyMenu::UpdateReadyBtnText()
+{
+	if (bIsReady)
+	{
+		ReadyBtn_Text->SetText(FText::FromString("Not Ready"));
+		BG_Blur->SetVisibility(ESlateVisibility::SelfHitTestInvisible);
+	}
+	else
+	{
+		ReadyBtn_Text->SetText(FText::FromString("Ready"));
+		BG_Blur->SetVisibility(ESlateVisibility::Collapsed);
+	}
+}
+
+void UUI_LobbyMenu::ReadyClick()
+{
+	bIsReady = !bIsReady;
+	UpdateReadyState(bIsReady, ParentID);
+	UpdateReadyBtnText();
+	
+	if (LobbyInterface)
+		LobbyInterface->SetIsReady(bIsReady);
+}
+
+void UUI_LobbyMenu::ArmySelectionChanged(FString SelectedItem, ESelectInfo::Type SelectionType)
+{
+	if (LobbyInterface)
+		LobbyInterface->SetArmy(Armies_Combo->FindOptionIndex(SelectedItem));
+}
+
Index: Source/FantasyBattle/Private/UI/PreGame/UI_MainMenu.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Source/FantasyBattle/Private/UI/PreGame/UI_MainMenu.cpp b/Source/FantasyBattle/Private/UI/PreGame/UI_MainMenu.cpp
new file mode 100644
--- /dev/null	(date 1642626590000)
+++ b/Source/FantasyBattle/Private/UI/PreGame/UI_MainMenu.cpp	(date 1642626590000)
@@ -0,0 +1,5 @@
+// Fill out your copyright notice in the Description page of Project Settings.
+
+
+#include "UI/PreGame/UI_MainMenu.h"
+
Index: Source/FantasyBattle/Private/UI/PreGame/UI_GS_PreGame.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Source/FantasyBattle/Private/UI/PreGame/UI_GS_PreGame.cpp b/Source/FantasyBattle/Private/UI/PreGame/UI_GS_PreGame.cpp
new file mode 100644
--- /dev/null	(date 1642713076000)
+++ b/Source/FantasyBattle/Private/UI/PreGame/UI_GS_PreGame.cpp	(date 1642713076000)
@@ -0,0 +1,6 @@
+// Fill out your copyright notice in the Description page of Project Settings.
+
+
+#include "UI/PreGame/UI_GS_PreGame.h"
+
+
Index: Source/FantasyBattle/Private/Mode/PS_PreGame.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Source/FantasyBattle/Private/Mode/PS_PreGame.cpp b/Source/FantasyBattle/Private/Mode/PS_PreGame.cpp
new file mode 100644
--- /dev/null	(date 1642712270000)
+++ b/Source/FantasyBattle/Private/Mode/PS_PreGame.cpp	(date 1642712270000)
@@ -0,0 +1,23 @@
+// Fill out your copyright notice in the Description page of Project Settings.
+
+
+#include "Mode/PS_PreGame.h"
+#include "Net/UnrealNetwork.h"
+
+void APS_PreGame::SetIsReady(bool NewValue)
+{
+	bIsReady = NewValue;
+}
+
+void APS_PreGame::SetArmy(FArmyStat NewArmy)
+{
+	SelectedArmy = NewArmy;
+}
+
+void APS_PreGame::GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const
+{
+	Super::GetLifetimeReplicatedProps(OutLifetimeProps);
+	
+	DOREPLIFETIME(APS_PreGame, bIsReady);
+	DOREPLIFETIME(APS_PreGame, SelectedArmy);
+}
Index: Source/FantasyBattle/Private/Mode/GM_PreGame.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Source/FantasyBattle/Private/Mode/GM_PreGame.cpp b/Source/FantasyBattle/Private/Mode/GM_PreGame.cpp
new file mode 100644
--- /dev/null	(date 1643450512605)
+++ b/Source/FantasyBattle/Private/Mode/GM_PreGame.cpp	(date 1643450512605)
@@ -0,0 +1,172 @@
+// Fill out your copyright notice in the Description page of Project Settings.
+
+
+#include "Mode/GM_PreGame.h"
+#include "FantasyBattle_GI.h"
+#include "OnlineSubsystem.h"
+#include "Interfaces/OnlineIdentityInterface.h"
+#include "Mode/GameSession_FantasyBattle.h"
+#include "Mode/GS_PreGame.h"
+#include "Mode/PC_FantasyBattle_PreGame.h"
+#include "Mode/PS_PreGame.h"
+
+AGM_PreGame::AGM_PreGame()
+{
+	bAllExistingPlayersRegistered = false;
+}
+
+void AGM_PreGame::InitGame(const FString& MapName, const FString& Options, FString& ErrorMessage)
+{
+	Super::InitGame(MapName, Options, ErrorMessage);
+
+	OnlineSubsystem = IOnlineSubsystem::Get();
+
+	UFantasyBattle_GI* GI = Cast<UFantasyBattle_GI>(GetGameInstance());
+	if(GI)
+	{
+		UE_LOG(LogTemp, Warning, TEXT("We found the GI and its valid Casted"));
+		GI->OnSessionCreated.BindDynamic(this, &AGM_PreGame::SessionCreated);
+	}
+	if (IsRunningDedicatedServer())
+	{
+		UE_LOG(LogTemp, Warning, TEXT("So we got a dedicated Server running"));
+		GI->CreateSession_Server();
+		
+	}
+}
+
+void AGM_PreGame::PostLogin(APlayerController* NewPlayer)
+{
+	if (!this->bAllExistingPlayersRegistered)
+	{
+		// RegisterExistingPlayers has not run yet. When it does, it will register this incoming player
+		// controller.
+		Super::PostLogin(NewPlayer);
+		return;
+	}
+	UE_LOG(LogTemp, Warning, TEXT("Post Login Recieved by Server Session"));
+	check(IsValid(NewPlayer));
+
+	// This code handles logins for both the local player (listen server) and remote players (net connection).
+	FUniqueNetIdRepl UniqueNetIdRepl;
+	if (NewPlayer->IsLocalPlayerController())
+	{
+		ULocalPlayer *LocalPlayer = NewPlayer->GetLocalPlayer();
+		if (IsValid(LocalPlayer))
+		{
+			UniqueNetIdRepl = LocalPlayer->GetPreferredUniqueNetId();
+		}
+		else
+		{
+			UNetConnection *RemoteNetConnection = Cast<UNetConnection>(NewPlayer->Player);
+			check(IsValid(RemoteNetConnection));
+			UniqueNetIdRepl = RemoteNetConnection->PlayerId;
+		}
+	}
+	else
+	{
+		UNetConnection *RemoteNetConnection = Cast<UNetConnection>(NewPlayer->Player);
+		check(IsValid(RemoteNetConnection));
+		UniqueNetIdRepl = RemoteNetConnection->PlayerId;
+	}
+	
+	// Get the unique player ID.
+	TSharedPtr<const FUniqueNetId> UniqueNetId = UniqueNetIdRepl.GetUniqueNetId();
+	check(UniqueNetId != nullptr);
+	UE_LOG(LogTemp, Warning, TEXT("Post Login Got UniqueNetID and its not NULL"));
+	// Get the online session interface.
+	IOnlineSubsystem *Subsystem = IOnlineSubsystem::Get();
+	IOnlineSessionPtr SessionPtr = Subsystem->GetSessionInterface();
+	IOnlineIdentityPtr const IdentityPtr = Subsystem->GetIdentityInterface();
+	
+	// Register the player with the "MyLocalSessionName" session; this name should match the name you provided in CreateSession.
+	if (!SessionPtr->RegisterPlayer(CurrentSessionName, *UniqueNetId, false))
+	{
+		// The player could not be registered; typically you will want to kick the player from the server in this situation.
+
+	}
+	
+	Super::PostLogin(NewPlayer);
+
+	for (APC_FantasyBattle_PreGame* Player : Players)
+	{
+		Player->NewPlayerJoined(UniqueNetId);
+	}
+	APC_FantasyBattle_PreGame* PC = Cast<APC_FantasyBattle_PreGame>(NewPlayer);
+	if (PC)
+	{
+		UE_LOG(LogTemp, Warning, TEXT("PlayerID: %d"), PC->PlayerState->GetPlayerId());
+		//FString UserName = FindUserInfo(UniqueNetId.ToSharedRef());
+		//NewPlayer->PlayerState->SetPlayerName(UserName);
+		PC->C_InitPC();
+		Players.Add(PC);
+	}
+}
+
+void AGM_PreGame::SessionCreated(FName SessionName, bool bWasSuccessful)
+{
+	CurrentSessionName = SessionName;
+	UE_LOG(LogTemp, Warning, TEXT("Session Created Called in Pre Game GM"));
+	for (auto It = this->GetWorld()->GetPlayerControllerIterator(); It; --It)
+	{
+		APlayerController* PlayerController = It->Get();
+		
+		FUniqueNetIdRepl UniqueNetIdRepl;
+		if (PlayerController->IsLocalPlayerController())
+		{
+			ULocalPlayer *LocalPlayer = PlayerController->GetLocalPlayer();
+			if (IsValid(LocalPlayer))
+			{
+				UniqueNetIdRepl = LocalPlayer->GetPreferredUniqueNetId();
+			}
+			else
+			{
+				UNetConnection *RemoteNetConnection = Cast<UNetConnection>(PlayerController->Player);
+				check(IsValid(RemoteNetConnection));
+				UniqueNetIdRepl = RemoteNetConnection->PlayerId;
+			}
+		}
+		else
+		{
+			UNetConnection *RemoteNetConnection = Cast<UNetConnection>(PlayerController->Player);
+			check(IsValid(RemoteNetConnection));
+			UniqueNetIdRepl = RemoteNetConnection->PlayerId;
+		}
+
+		// Get the unique player ID.
+		TSharedPtr<const FUniqueNetId> UniqueNetId = UniqueNetIdRepl.GetUniqueNetId();
+		check(UniqueNetId != nullptr);
+
+		// Get the online session interface.
+		IOnlineSubsystem const *Subsystem = IOnlineSubsystem::Get();
+		IOnlineSessionPtr const SessionPtr = Subsystem->GetSessionInterface();
+		// Register the player with the "MyLocalSessionName" session; this name should match the name you provided in CreateSession.
+		if (!SessionPtr->RegisterPlayer(CurrentSessionName, *UniqueNetId, false))
+		{
+			// The player could not be registered; typically you will want to kick the player from the server in this situation.
+		}
+	
+		/*UFantasyBattle_GI* GI = Cast<UFantasyBattle_GI>(GetGameInstance());
+		if (GI)
+		{
+			UE_LOG(LogTemp, Warning, TEXT("So we Set the unique Net ID from session to hosting player: %s"), *UniqueNetId->ToString());
+			FString UserName = GI->FindUserInfo(UniqueNetId.ToSharedRef());
+			UE_LOG(LogTemp, Warning, TEXT("Did we find a username? %s"), *UserName);
+			PlayerController->PlayerState->SetUniqueId(UniqueNetId);
+			PlayerController->PlayerState->SetPlayerName(UserName);
+		}*/
+		APC_FantasyBattle_PreGame* PC = Cast<APC_FantasyBattle_PreGame>(PlayerController);
+		if (PC)
+		{
+			PC->C_InitPC();
+			Players.Add(PC);
+		}
+	}
+	this->bAllExistingPlayersRegistered = true;
+}
+
+void AGM_PreGame::StartGame()
+{
+}
+
+
Index: Source/FantasyBattle/Private/Mode/GameSession_FantasyBattle.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Source/FantasyBattle/Private/Mode/GameSession_FantasyBattle.cpp b/Source/FantasyBattle/Private/Mode/GameSession_FantasyBattle.cpp
new file mode 100644
--- /dev/null	(date 1642373450000)
+++ b/Source/FantasyBattle/Private/Mode/GameSession_FantasyBattle.cpp	(date 1642373450000)
@@ -0,0 +1,5 @@
+// Fill out your copyright notice in the Description page of Project Settings.
+
+
+#include "Mode/GameSession_FantasyBattle.h"
+
Index: Plugins/OnlineSubsystemEOS/ReadMe.txt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Plugins/OnlineSubsystemEOS/ReadMe.txt b/Plugins/OnlineSubsystemEOS/ReadMe.txt
new file mode 100644
--- /dev/null	(date 1641575208000)
+++ b/Plugins/OnlineSubsystemEOS/ReadMe.txt	(date 1641575208000)
@@ -0,0 +1,25 @@
+This plugin is experimental and meant to be something to jump start your development. This plugin has been tested using ShooterGame on Windows
+
+It does not meet the Epic Games Store requirement for cross store support as is. You will need to add support to ship on EGS.
+
+This plugin depends on the Engine/Source/ThirdParty/EOSSDK module which houses the SDK. Please refer to that module for information on installing / upgrading the SDK
+
+This plugin supports:
+	- EAS/EGS Auth
+	- EAS Presence
+	- EAS Friends
+	- EGS/EAS Ecom
+	- EOS Sessions
+	- EOS Stats
+	- EOS Achievements
+	- EOS Leaderboards
+	- EOS p2p Sockets
+	- EOS Metrics (session based analytics)
+	- EOS Voice
+
+To configure your settings:
+	1. Go to Project Settings
+	2. Scroll down to Plugins
+	3. Select Epic Online Services
+	4. Add a entry in the list for each artifact on EGS or use the default name for non-EGS
+		- Each deployment id/artifact can have separate settings
Index: Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/OnlineSubsystemEOS.Build.cs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/OnlineSubsystemEOS.Build.cs b/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/OnlineSubsystemEOS.Build.cs
new file mode 100644
--- /dev/null	(date 1641576012000)
+++ b/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/OnlineSubsystemEOS.Build.cs	(date 1641576012000)
@@ -0,0 +1,41 @@
+// Copyright Epic Games, Inc. All Rights Reserved.
+
+using UnrealBuildTool;
+using System.IO;
+
+public class OnlineSubsystemEOS : ModuleRules
+{
+	public OnlineSubsystemEOS(ReadOnlyTargetRules Target) : base(Target)
+	{
+		PrivateDefinitions.Add("ONLINESUBSYSTEMEOS_PACKAGE=1");
+
+		PublicDependencyModuleNames.AddRange(
+			new string[] {
+				"OnlineSubsystemUtils"
+			}
+		);
+
+		PrivateDependencyModuleNames.AddRange(
+			new string[] {
+				"Core",
+				"CoreOnline",
+				"CoreUObject",
+				"Engine",
+				"EOSSDK",
+				"EOSShared",
+				"EOSVoiceChat",
+				"Json",
+				"OnlineSubsystem",
+				"Sockets",
+				"VoiceChat",
+				"NetCore"
+			}
+		);
+
+		PrivateDefinitions.Add("USE_XBL_XSTS_TOKEN=" + (bUseXblXstsToken ? "1" : "0"));
+		PrivateDefinitions.Add("USE_PSN_ID_TOKEN=" + (bUsePsnIdToken ? "1" : "0"));
+	}
+
+	protected virtual bool bUseXblXstsToken { get { return false; } }
+	protected virtual bool bUsePsnIdToken { get { return false; } }
+}
Index: Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Public/OnlineSubsystemEOSPackage.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Public/OnlineSubsystemEOSPackage.h b/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Public/OnlineSubsystemEOSPackage.h
new file mode 100644
--- /dev/null	(date 1641575208000)
+++ b/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Public/OnlineSubsystemEOSPackage.h	(date 1641575208000)
@@ -0,0 +1,15 @@
+// Copyright Epic Games, Inc. All Rights Reserved.
+
+// Can't be #pragma once because other modules may define PACKAGE_SCOPE
+
+// Intended to be the last include in an exported class definition
+// Properly defines some members as "public to the module" vs "private to the consumer/user"
+
+// [[ IncludeTool: Inline ]] // Markup to tell IncludeTool that this file is state changing and cannot be optimized out.
+
+#undef PACKAGE_SCOPE
+#if ONLINESUBSYSTEMEOS_PACKAGE
+#define PACKAGE_SCOPE public
+#else
+#define PACKAGE_SCOPE protected
+#endif
Index: Plugins/OnlineSubsystemEOS/OnlineSubsystemEOS.uplugin
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Plugins/OnlineSubsystemEOS/OnlineSubsystemEOS.uplugin b/Plugins/OnlineSubsystemEOS/OnlineSubsystemEOS.uplugin
new file mode 100644
--- /dev/null	(date 1641576012000)
+++ b/Plugins/OnlineSubsystemEOS/OnlineSubsystemEOS.uplugin	(date 1641576012000)
@@ -0,0 +1,54 @@
+{
+	"FileVersion": 3,
+
+	"FriendlyName": "Online Subsystem EOS",
+	"Version": 1,
+	"VersionName": "1.0",
+	"Description": "Online Subsystem for Epic Online Services",
+	"Category": "Online Platform",
+	"CreatedBy": "Epic Games, Inc.",
+	"CreatedByURL": "http://dev.epicgames.com/services",
+	"EnabledByDefault": false,
+	"IsBetaVersion" : true,
+
+	"Modules": [
+		{
+			"Name": "OnlineSubsystemEOS",
+			"Type": "Runtime",
+			"LoadingPhase": "Default",
+			"PlatformAllowList": [
+				"Win64",
+				"Mac",
+				"Android"
+			]
+		},
+		{
+			"Name": "OnlineSubsystemEOSPlus",
+			"Type": "Runtime",
+			"LoadingPhase": "Default",
+			"PlatformAllowList": [
+				"Win64",
+				"Mac",
+				"Android"
+			]
+		}
+	],
+	"Plugins": [
+		{
+			"Name": "OnlineSubsystem",
+			"Enabled": true
+		},
+		{
+			"Name": "OnlineSubsystemUtils",
+			"Enabled": true
+		},
+		{
+			"Name": "EOSShared",
+			"Enabled": true
+		},
+		{
+			"Name": "EOSVoiceChat",
+			"Enabled": true
+		}
+	]
+}
Index: Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Private/NetConnectionEOS.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Private/NetConnectionEOS.cpp b/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Private/NetConnectionEOS.cpp
new file mode 100644
--- /dev/null	(date 1641575208000)
+++ b/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Private/NetConnectionEOS.cpp	(date 1641575208000)
@@ -0,0 +1,76 @@
+// Copyright Epic Games, Inc. All Rights Reserved.
+
+#include "NetConnectionEOS.h"
+#include "NetDriverEOS.h"
+#include "InternetAddrEOS.h"
+#include "SocketEOS.h"
+
+UNetConnectionEOS::UNetConnectionEOS(const FObjectInitializer& ObjectInitializer)
+	: Super(ObjectInitializer)
+	, bIsPassthrough(false)
+	, bHasP2PSession(false)
+{
+}
+
+void UNetConnectionEOS::InitLocalConnection(UNetDriver* InDriver, FSocket* InSocket, const FURL& InURL, EConnectionState InState, int32 InMaxPacket, int32 InPacketOverhead)
+{
+	bIsPassthrough = !static_cast<UNetDriverEOS*>(InDriver)->bIsUsingP2PSockets || !InURL.Host.StartsWith(EOS_CONNECTION_URL_PREFIX, ESearchCase::IgnoreCase);
+	bHasP2PSession = !bIsPassthrough;
+	  
+	if (bHasP2PSession)
+	{
+		DisableAddressResolution();
+	}
+
+	Super::InitLocalConnection(InDriver, InSocket, InURL, InState, InMaxPacket, InPacketOverhead);
+
+	// We re-set the original port, as if might have been overwritten by Super::InitLocalConnection
+	if (bHasP2PSession)
+	{
+		RemoteAddr->SetPort(InSocket->GetPortNo());
+	}
+}
+
+void UNetConnectionEOS::InitRemoteConnection(UNetDriver* InDriver, FSocket* InSocket, const FURL& InURL, const FInternetAddr& InRemoteAddr, EConnectionState InState, int32 InMaxPacket, int32 InPacketOverhead)
+{
+	bIsPassthrough = static_cast<UNetDriverEOS*>(InDriver)->bIsPassthrough;
+	bHasP2PSession = !bIsPassthrough;
+
+	if (bHasP2PSession)
+	{
+		DisableAddressResolution();
+	}
+
+	Super::InitRemoteConnection(InDriver, InSocket, InURL, InRemoteAddr, InState, InMaxPacket, InPacketOverhead);
+}
+
+void UNetConnectionEOS::CleanUp()
+{
+	Super::CleanUp();
+
+	if (bHasP2PSession)
+	{
+		DestroyEOSConnection();
+	}
+}
+
+void UNetConnectionEOS::DestroyEOSConnection()
+{
+	if (!Socket)
+	{
+		return;
+	}
+
+	if (!bHasP2PSession)
+	{
+		return;
+	}
+
+	bHasP2PSession = false;
+
+	TSharedPtr<FInternetAddrEOS> RemoteAddrEOS = StaticCastSharedPtr<FInternetAddrEOS>(RemoteAddr);
+	if (RemoteAddrEOS.IsValid())
+	{
+		static_cast<FSocketEOS*>(Socket)->Close(*RemoteAddrEOS);
+	}
+}
Index: Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Private/OnlineSubsystemEOSTypes.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Private/OnlineSubsystemEOSTypes.h b/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Private/OnlineSubsystemEOSTypes.h
new file mode 100644
--- /dev/null	(date 1641576012000)
+++ b/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Private/OnlineSubsystemEOSTypes.h	(date 1641576012000)
@@ -0,0 +1,820 @@
+// Copyright Epic Games, Inc. All Rights Reserved.
+
+#pragma once
+
+#include "OnlineSubsystemTypes.h"
+
+#include "Interfaces/OnlineIdentityInterface.h"
+#include "Interfaces/OnlineFriendsInterface.h"
+#include "Interfaces/OnlinePresenceInterface.h"
+#include "Interfaces/OnlineUserInterface.h"
+#include "EOSShared.h"
+#include "IPAddress.h"
+
+#include "OnlineSubsystemEOSPackage.h"
+
+#if WITH_EOS_SDK
+	#if defined(EOS_PLATFORM_BASE_FILE_NAME)
+	#include EOS_PLATFORM_BASE_FILE_NAME
+	#endif
+
+	#include "eos_common.h"
+#endif
+
+// Expect URLs to look like "EOS:PUID:SocketName:Channel"
+#define EOS_CONNECTION_URL_PREFIX TEXT("EOS")
+#define EOS_URL_SEPARATOR TEXT(":")
+
+#define EOS_OSS_STRING_BUFFER_LENGTH 256 + 1 // 256 plus null terminator
+
+class FOnlineSubsystemEOS;
+
+#define EOS_ID_SEPARATOR TEXT("|")
+#define EMPTY_EASID TEXT("00000000000000000000000000000000")
+#define EMPTY_PUID TEXT("00000000000000000000000000000000")
+#define ID_HALF_BYTE_SIZE 16
+#define EOS_ID_BYTE_SIZE (ID_HALF_BYTE_SIZE * 2)
+
+typedef TSharedPtr<const class FUniqueNetIdEOS> FUniqueNetIdEOSPtr;
+typedef TSharedRef<const class FUniqueNetIdEOS> FUniqueNetIdEOSRef;
+
+/**
+ * Unique net id wrapper for a EOS account ids. The underlying string is a combination
+ * of both account ids concatenated. "<EOS_EpicAccountId>|<EOS_ProductAccountId>"
+ */
+class FUniqueNetIdEOS :
+	public FUniqueNetIdString
+{
+public:
+	template<typename... TArgs>
+	static FUniqueNetIdEOSRef Create(TArgs&&... Args)
+	{
+		return MakeShareable(new FUniqueNetIdEOS(Forward<TArgs>(Args)...));
+	}
+
+	static const FUniqueNetIdEOS& Cast(const FUniqueNetId& NetId)
+	{
+		check(GetTypeStatic() == NetId.GetType());
+		return *static_cast<const FUniqueNetIdEOS*>(&NetId);
+	}
+
+	friend uint32 GetTypeHash(const FUniqueNetIdEOS& A)
+	{
+		return ::GetTypeHash(A.UniqueNetIdStr);
+	}
+
+	/** global static instance of invalid (zero) id */
+	static const FUniqueNetIdEOSRef& EmptyId()
+	{
+		static const FUniqueNetIdEOSRef EmptyId(Create());
+		return EmptyId;
+	}
+
+	static FName GetTypeStatic()
+	{
+		static FName NAME_Eos(TEXT("EOS"));
+		return NAME_Eos;
+	}
+
+	virtual FName GetType() const override
+	{
+		return GetTypeStatic();
+	}
+
+	virtual const uint8* GetBytes() const override
+	{
+		return RawBytes;
+	}
+
+	virtual int32 GetSize() const override
+	{
+		return EOS_ID_BYTE_SIZE;
+	}
+
+PACKAGE_SCOPE:
+	void UpdateNetIdStr(const FString& InNetIdStr)
+	{
+		UniqueNetIdStr = InNetIdStr;
+		ParseAccountIds();
+	}
+
+	void ParseAccountIds()
+	{
+		TArray<FString> AccountIds;
+		UniqueNetIdStr.ParseIntoArray(AccountIds, EOS_ID_SEPARATOR, false);
+		if (AccountIds.Num() > 0 && AccountIds[0].Len() > 0)
+		{
+			EpicAccountIdStr = AccountIds[0];
+		}
+		else
+		{
+			EpicAccountIdStr = EMPTY_EASID;
+		}
+		AddToBuffer(RawBytes, EpicAccountIdStr);
+		if (AccountIds.Num() > 1 && AccountIds[1].Len() > 0)
+		{
+			ProductUserIdStr = AccountIds[1];
+		}
+		else
+		{
+			ProductUserIdStr = EMPTY_PUID;
+		}
+		AddToBuffer(RawBytes + ID_HALF_BYTE_SIZE, ProductUserIdStr);
+	}
+
+	void AddToBuffer(uint8* Buffer, const FString& Source)
+	{
+		check(Source.Len() == 32);
+		for (int32 ReadOffset = 0, WriteOffset = 0; ReadOffset < 32; ReadOffset += 2, WriteOffset++)
+		{
+			FString HexStr = Source.Mid(ReadOffset, 2);
+			// String is in HEX so use the version that takes a base
+			uint8 ToByte = (uint8)FCString::Strtoi(*HexStr, nullptr, 16);
+			Buffer[WriteOffset] = ToByte;
+		}
+	}
+
+	FString EpicAccountIdStr;
+	FString ProductUserIdStr;
+	uint8 RawBytes[EOS_ID_BYTE_SIZE] = { 0 };
+private:
+	FUniqueNetIdEOS()
+		PRAGMA_DISABLE_DEPRECATION_WARNINGS
+		: FUniqueNetIdString(EMPTY_EASID EOS_ID_SEPARATOR EMPTY_PUID)
+		PRAGMA_ENABLE_DEPRECATION_WARNINGS
+	{
+		Type = FName("EOS");
+	}
+	
+	explicit FUniqueNetIdEOS(uint8* Bytes, int32 Size)
+		PRAGMA_DISABLE_DEPRECATION_WARNINGS
+		: FUniqueNetIdString()
+		PRAGMA_ENABLE_DEPRECATION_WARNINGS
+	{
+		check(Size == EOS_ID_BYTE_SIZE);
+		EpicAccountIdStr = BytesToHex(Bytes, ID_HALF_BYTE_SIZE);
+		ProductUserIdStr = BytesToHex(Bytes + ID_HALF_BYTE_SIZE, ID_HALF_BYTE_SIZE);
+		UniqueNetIdStr = EpicAccountIdStr + EOS_ID_SEPARATOR + ProductUserIdStr;
+		Type = FName("EOS");
+	}
+
+	explicit FUniqueNetIdEOS(const FString& InUniqueNetId)
+		PRAGMA_DISABLE_DEPRECATION_WARNINGS
+		: FUniqueNetIdString(InUniqueNetId, FName("EOS"))
+		PRAGMA_ENABLE_DEPRECATION_WARNINGS
+	{
+		ParseAccountIds();
+	}
+
+	explicit FUniqueNetIdEOS(FString&& InUniqueNetId)
+		PRAGMA_DISABLE_DEPRECATION_WARNINGS
+		: FUniqueNetIdString(MoveTemp(InUniqueNetId))
+		PRAGMA_ENABLE_DEPRECATION_WARNINGS
+	{
+		ParseAccountIds();
+		Type = FName("EOS");
+	}
+
+	explicit FUniqueNetIdEOS(const FUniqueNetId& Src)
+		PRAGMA_DISABLE_DEPRECATION_WARNINGS
+		: FUniqueNetIdString(Src)
+		PRAGMA_ENABLE_DEPRECATION_WARNINGS
+	{
+		ParseAccountIds();
+		Type = FName("EOS");
+	}
+};
+
+#ifndef AUTH_ATTR_REFRESH_TOKEN
+	#define AUTH_ATTR_REFRESH_TOKEN TEXT("refresh_token")
+#endif
+#ifndef AUTH_ATTR_ID_TOKEN
+	#define AUTH_ATTR_ID_TOKEN TEXT("id_token")
+#endif
+#ifndef AUTH_ATTR_AUTHORIZATION_CODE
+	#define AUTH_ATTR_AUTHORIZATION_CODE TEXT("authorization_code")
+#endif
+
+#define USER_ATTR_DISPLAY_NAME TEXT("display_name")
+#define USER_ATTR_COUNTRY TEXT("country")
+#define USER_ATTR_LANG TEXT("language")
+
+#if WITH_EOS_SDK
+
+/** Used to update all types of FOnlineUser classes, irrespective of leaf most class type */
+class IAttributeAccessInterface
+{
+public:
+	virtual void SetInternalAttribute(const FString& AttrName, const FString& AttrValue)
+	{
+	}
+
+	virtual FUniqueNetIdEOSPtr GetUniqueNetIdEOS() const
+	{
+		return FUniqueNetIdEOSPtr();
+	}
+};
+
+typedef TSharedPtr<IAttributeAccessInterface> IAttributeAccessInterfacePtr;
+typedef TSharedRef<IAttributeAccessInterface> IAttributeAccessInterfaceRef;
+
+/**
+ * Implementation of FOnlineUser that can be shared across multiple class hiearchies
+ */
+template<class BaseClass, class AttributeAccessClass>
+class TOnlineUserEOS
+	: public BaseClass
+	, public AttributeAccessClass
+{
+public:
+	TOnlineUserEOS(const FUniqueNetIdEOSRef& InNetIdRef)
+		: UserIdRef(InNetIdRef)
+	{
+	}
+
+	virtual ~TOnlineUserEOS()
+	{
+	}
+
+// FOnlineUser
+	virtual FUniqueNetIdRef GetUserId() const override
+	{
+		return UserIdRef;
+	}
+
+	virtual FString GetRealName() const override
+	{
+		return FString();
+	}
+
+	virtual FString GetDisplayName(const FString& Platform = FString()) const override
+	{
+		FString ReturnValue;
+		GetUserAttribute(USER_ATTR_DISPLAY_NAME, ReturnValue);
+		return ReturnValue;
+	}
+
+	virtual bool GetUserAttribute(const FString& AttrName, FString& OutAttrValue) const override
+	{
+		const FString* FoundAttr = UserAttributes.Find(AttrName);
+		if (FoundAttr != nullptr)
+		{
+			OutAttrValue = *FoundAttr;
+			return true;
+		}
+		return false;
+	}
+//~FOnlineUser
+
+	virtual void SetInternalAttribute(const FString& AttrName, const FString& AttrValue)
+	{
+		UserAttributes.Add(AttrName, AttrValue);
+	}
+
+	virtual FUniqueNetIdEOSPtr GetUniqueNetIdEOS() const
+	{
+		return UserIdRef;
+	}
+
+protected:
+	/** User Id represented as a FUniqueNetId */
+	FUniqueNetIdEOSRef UserIdRef;
+	/** Additional key/value pair data related to user attribution */
+	TMap<FString, FString> UserAttributes;
+};
+
+/**
+ * Implementation of FUserOnlineAccount methods that adds in the online user template to complete the interface
+ */
+template<class BaseClass>
+class TUserOnlineAccountEOS :
+	public TOnlineUserEOS<BaseClass, IAttributeAccessInterface>
+{
+public:
+	TUserOnlineAccountEOS(const FUniqueNetIdEOSRef& InNetIdRef)
+		: TOnlineUserEOS<BaseClass, IAttributeAccessInterface>(InNetIdRef)
+	{
+	}
+
+// FUserOnlineAccount
+	virtual FString GetAccessToken() const override
+	{
+		FString Token;
+		GetAuthAttribute(AUTH_ATTR_ID_TOKEN, Token);
+		return Token;
+	}
+
+	virtual bool GetAuthAttribute(const FString& AttrName, FString& OutAttrValue) const override
+	{
+		const FString* FoundAttr = AdditionalAuthData.Find(AttrName);
+		if (FoundAttr != nullptr)
+		{
+			OutAttrValue = *FoundAttr;
+			return true;
+		}
+		return false;
+	}
+
+	virtual bool SetUserAttribute(const FString& AttrName, const FString& AttrValue) override
+	{
+		const FString* FoundAttr = this->UserAttributes.Find(AttrName);
+		if (FoundAttr == nullptr || *FoundAttr != AttrValue)
+		{
+			this->UserAttributes.Add(AttrName, AttrValue);
+			return true;
+		}
+		return false;
+	}
+//~FUserOnlineAccount
+
+	void SetAuthAttribute(const FString& AttrName, const FString& AttrValue)
+	{
+		AdditionalAuthData.Add(AttrName, AttrValue);
+	}
+
+protected:
+	/** Additional key/value pair data related to auth */
+	TMap<FString, FString> AdditionalAuthData;
+};
+
+typedef TSharedRef<FOnlineUserPresence> FOnlineUserPresenceRef;
+
+/**
+ * Implementation of FOnlineFriend methods that adds in the online user template to complete the interface
+ */
+template<class BaseClass>
+class TOnlineFriendEOS :
+	public TOnlineUserEOS<BaseClass, IAttributeAccessInterface>
+{
+public:
+	TOnlineFriendEOS(const FUniqueNetIdEOSRef& InNetIdRef)
+		: TOnlineUserEOS<BaseClass, IAttributeAccessInterface>(InNetIdRef)
+	{
+	}
+
+// FOnlineFriend
+	/**
+	 * @return the current invite status of a friend wrt to user that queried
+	 */
+	virtual EInviteStatus::Type GetInviteStatus() const override
+	{
+		return InviteStatus;
+	}
+
+	/**
+	 * @return presence info for an online friend
+	 */
+	virtual const FOnlineUserPresence& GetPresence() const override
+	{
+		return Presence;
+	}
+//~FOnlineFriend
+
+	void SetInviteStatus(EInviteStatus::Type InStatus)
+	{
+		InviteStatus = InStatus;
+	}
+
+	void SetPresence(FOnlineUserPresenceRef InPresence)
+	{
+		// Copy the data over since the friend shares it as a const&
+		Presence = *InPresence;
+	}
+
+protected:
+	FOnlineUserPresence Presence;
+	EInviteStatus::Type InviteStatus;
+};
+
+/**
+ * Implementation of FOnlineBlockedPlayer methods that adds in the online user template to complete the interface
+ */
+template<class BaseClass>
+class TOnlineBlockedPlayerEOS :
+	public TOnlineUserEOS<BaseClass, IAttributeAccessInterface>
+{
+public:
+	TOnlineBlockedPlayerEOS(const FUniqueNetIdEOSRef& InNetIdRef)
+		: TOnlineUserEOS<BaseClass, IAttributeAccessInterface>(InNetIdRef)
+	{
+	}
+};
+
+/**
+ * Implementation of FOnlineRecentPlayer methods that adds in the online user template to complete the interface
+ */
+template<class BaseClass>
+class TOnlineRecentPlayerEOS :
+	public TOnlineUserEOS<BaseClass, IAttributeAccessInterface>
+{
+public:
+	TOnlineRecentPlayerEOS(const FUniqueNetIdEOSRef& InNetIdRef)
+		: TOnlineUserEOS<BaseClass, IAttributeAccessInterface>(InNetIdRef)
+	{
+	}
+
+// FOnlineRecentPlayer
+	/**
+	 * @return last time the player was seen by the current user
+	 */
+	virtual FDateTime GetLastSeen() const override
+	{
+		return LastSeenTime;
+	}
+//~FOnlineRecentPlayer
+
+	void SetLastSeen(const FDateTime& InLastSeenTime)
+	{
+		LastSeenTime = InLastSeenTime;
+	}
+
+protected:
+	FDateTime LastSeenTime;
+};
+
+static inline FString MakeNetIdStringFromIds(EOS_EpicAccountId AccountId, EOS_ProductUserId UserId)
+{
+	FString NetId = LexToString(AccountId);
+
+	// Only add this when the product user id is valid for more consistent net id string generation
+	// across different code paths
+	const FString ProductIdStr = LexToString(UserId);
+	if (!ProductIdStr.IsEmpty())
+	{
+		NetId += EOS_ID_SEPARATOR;
+		NetId += ProductIdStr;
+	}
+
+	return NetId;
+}
+
+/** Used to store a pointer to the EOS callback object without knowing type */
+class FCallbackBase
+{
+	static bool bShouldCancelAllCallbacks;
+
+public:
+	virtual ~FCallbackBase() {}
+	static bool ShouldCancelAllCallbacks() { return FCallbackBase::bShouldCancelAllCallbacks; }
+	static void CancelAllCallbacks() { FCallbackBase::bShouldCancelAllCallbacks = true; }
+};
+
+/** Class to handle all callbacks generically using a lambda to process callback results */
+template<typename CallbackFuncType, typename CallbackType>
+class TEOSCallback :
+	public FCallbackBase
+{
+public:
+	TFunction<void(const CallbackType*)> CallbackLambda;
+
+	TEOSCallback()
+	{
+
+	}
+	virtual ~TEOSCallback() = default;
+
+
+	CallbackFuncType GetCallbackPtr()
+	{
+		return &CallbackImpl;
+	}
+
+private:
+	static void EOS_CALL CallbackImpl(const CallbackType* Data)
+	{
+		if (EOS_EResult_IsOperationComplete(Data->ResultCode) == EOS_FALSE)
+		{
+			// Ignore
+			return;
+		}
+		check(IsInGameThread());
+
+		TEOSCallback* CallbackThis = (TEOSCallback*)Data->ClientData;
+		check(CallbackThis);
+
+		if (FCallbackBase::ShouldCancelAllCallbacks())
+		{
+			delete CallbackThis;
+			return;
+		}
+
+		check(CallbackThis->CallbackLambda);
+		CallbackThis->CallbackLambda(Data);
+
+		delete CallbackThis;
+	}
+};
+
+namespace OSSInternalCallback
+{
+	/** Create a callback for a non-SDK function that is tied to the lifetime of an arbitrary shared pointer. */
+	template <typename DelegateType, typename OwnerType, typename... CallbackArgs>
+	UE_NODISCARD DelegateType Create(const TSharedPtr<OwnerType, ESPMode::ThreadSafe>& InOwner,
+		const TFunction<void(CallbackArgs...)>& InUserCallback)
+	{
+		const DelegateType& CheckOwnerThenExecute = DelegateType::CreateLambda(
+			[WeakOwner = TWeakPtr<OwnerType, ESPMode::ThreadSafe>(InOwner), InUserCallback](CallbackArgs... Payload) {
+				check(IsInGameThread());
+				TSharedPtr<OwnerType, ESPMode::ThreadSafe> Owner = WeakOwner.Pin();
+				if (Owner.IsValid())
+				{
+					InUserCallback(Payload...);
+				}
+		});
+
+		return CheckOwnerThenExecute;
+	}
+}
+
+/**
+ * Class to handle nested callbacks (callbacks that are tied to an external callback's lifetime,
+ * e.g. file chunkers) generically using a lambda to process callback results
+ */
+template<typename CallbackFuncType, typename CallbackType,
+	typename Nested1CallbackFuncType, typename Nested1CallbackType, typename Nested1ReturnType>
+class TEOSCallbackWithNested1 :
+	public TEOSCallback<CallbackFuncType, CallbackType>
+{
+public:
+	TEOSCallbackWithNested1() = default;
+	virtual ~TEOSCallbackWithNested1() = default;
+
+
+	Nested1CallbackFuncType GetNested1CallbackPtr()
+	{
+		return &Nested1CallbackImpl;
+	}
+
+	void SetNested1CallbackLambda(TFunction<Nested1ReturnType(const Nested1CallbackType*)> InLambda)
+	{
+		Nested1CallbackLambda = InLambda;
+	}
+
+private:
+	TFunction<Nested1ReturnType(const Nested1CallbackType*)> Nested1CallbackLambda;
+
+	static Nested1ReturnType EOS_CALL Nested1CallbackImpl(const Nested1CallbackType* Data)
+	{
+		check(IsInGameThread());
+		if (FCallbackBase::ShouldCancelAllCallbacks())
+		{
+			return Nested1ReturnType();
+		}
+
+		TEOSCallbackWithNested1* CallbackThis = (TEOSCallbackWithNested1*)Data->ClientData;
+		check(CallbackThis);
+
+		check(CallbackThis->CallbackLambda);
+		return CallbackThis->Nested1CallbackLambda(Data);
+	}
+};
+
+/**
+ * Class to handle 2 nested callbacks (callbacks that are tied to an external callback's lifetime,
+ * e.g. file chunkers) generically using a lambda to process callback results
+ */
+template<typename CallbackFuncType, typename CallbackType,
+	typename Nested1CallbackFuncType, typename Nested1CallbackType, typename Nested1ReturnType,
+	typename Nested2CallbackFuncType, typename Nested2CallbackType>
+class TEOSCallbackWithNested2 :
+	public TEOSCallbackWithNested1<CallbackFuncType, CallbackType, Nested1CallbackFuncType, Nested1CallbackType, Nested1ReturnType>
+{
+public:
+	TEOSCallbackWithNested2() = default;
+	virtual ~TEOSCallbackWithNested2() = default;
+
+
+	Nested2CallbackFuncType GetNested2CallbackPtr()
+	{
+		return &Nested2CallbackImpl;
+	}
+
+	void SetNested2CallbackLambda(TFunction<void(const Nested2CallbackType*)> InLambda)
+	{
+		Nested2CallbackLambda = InLambda;
+	}
+
+private:
+	TFunction<void(const Nested2CallbackType*)> Nested2CallbackLambda;
+
+	static void EOS_CALL Nested2CallbackImpl(const Nested2CallbackType* Data)
+	{
+		check(IsInGameThread());
+		if (FCallbackBase::ShouldCancelAllCallbacks())
+		{
+			return;
+		}
+
+		TEOSCallbackWithNested2* CallbackThis = (TEOSCallbackWithNested2*)Data->ClientData;
+		check(CallbackThis);
+
+		check(CallbackThis->CallbackLambda);
+		CallbackThis->Nested2CallbackLambda(Data);
+	}
+};
+
+/**
+ * Class to handle nested callbacks (callbacks that are tied to an external callback's lifetime,
+ * e.g. file chunkers) generically using a lambda to process callback results
+ */
+template<typename CallbackFuncType, typename CallbackType,
+	typename Nested1CallbackFuncType, typename Nested1CallbackType, typename Nested1ReturnType>
+	class TEOSCallbackWithNested1Param3 :
+	public TEOSCallback<CallbackFuncType, CallbackType>
+{
+public:
+	TEOSCallbackWithNested1Param3() = default;
+	virtual ~TEOSCallbackWithNested1Param3() = default;
+
+
+	Nested1CallbackFuncType GetNested1CallbackPtr()
+	{
+		return (Nested1CallbackFuncType)&Nested1CallbackImpl;
+	}
+
+	void SetNested1CallbackLambda(TFunction<Nested1ReturnType(const Nested1CallbackType*, void*, uint32_t*)> InLambda)
+	{
+		Nested1CallbackLambda = InLambda;
+	}
+
+private:
+	TFunction<Nested1ReturnType(const Nested1CallbackType*, void*, uint32_t*)> Nested1CallbackLambda;
+
+	static Nested1ReturnType EOS_CALL Nested1CallbackImpl(const Nested1CallbackType* Data, void* OutDataBuffer, uint32_t* OutDataWritten)
+	{
+		check(IsInGameThread());
+		if (FCallbackBase::ShouldCancelAllCallbacks())
+		{
+			return Nested1ReturnType();
+		}
+
+		TEOSCallbackWithNested1Param3* CallbackThis = (TEOSCallbackWithNested1Param3*)Data->ClientData;
+		check(CallbackThis);
+
+		check(CallbackThis->CallbackLambda);
+		return CallbackThis->Nested1CallbackLambda(Data, OutDataBuffer, OutDataWritten);
+	}
+};
+
+/**
+ * Class to handle 2 nested callbacks (callbacks that are tied to an external callback's lifetime,
+ * e.g. file chunkers) generically using a lambda to process callback results
+ */
+template<typename CallbackFuncType, typename CallbackType,
+	typename Nested1CallbackFuncType, typename Nested1CallbackType, typename Nested1ReturnType,
+	typename Nested2CallbackFuncType, typename Nested2CallbackType>
+	class TEOSCallbackWithNested2ForNested1Param3 :
+	public TEOSCallbackWithNested1Param3<CallbackFuncType, CallbackType, Nested1CallbackFuncType, Nested1CallbackType, Nested1ReturnType>
+{
+public:
+	TEOSCallbackWithNested2ForNested1Param3() = default;
+	virtual ~TEOSCallbackWithNested2ForNested1Param3() = default;
+
+
+	Nested2CallbackFuncType GetNested2CallbackPtr()
+	{
+		return &Nested2CallbackImpl;
+	}
+
+	void SetNested2CallbackLambda(TFunction<void(const Nested2CallbackType*)> InLambda)
+	{
+		Nested2CallbackLambda = InLambda;
+	}
+
+private:
+	TFunction<void(const Nested2CallbackType*)> Nested2CallbackLambda;
+
+	static void EOS_CALL Nested2CallbackImpl(const Nested2CallbackType* Data)
+	{
+		check(IsInGameThread());
+		if (FCallbackBase::ShouldCancelAllCallbacks())
+		{
+			return;
+		}
+
+		TEOSCallbackWithNested2ForNested1Param3* CallbackThis = (TEOSCallbackWithNested2ForNested1Param3*)Data->ClientData;
+		check(CallbackThis);
+
+		check(CallbackThis->CallbackLambda);
+		CallbackThis->Nested2CallbackLambda(Data);
+	}
+};
+
+/** Class to handle all callbacks generically using a lambda to process callback results */
+template<typename CallbackFuncType, typename CallbackType>
+class TEOSGlobalCallback :
+	public FCallbackBase
+{
+public:
+	TFunction<void(const CallbackType*)> CallbackLambda;
+
+	TEOSGlobalCallback() = default;
+	virtual ~TEOSGlobalCallback() = default;
+
+
+	CallbackFuncType GetCallbackPtr()
+	{
+		return &CallbackImpl;
+	}
+
+private:
+	static void EOS_CALL CallbackImpl(const CallbackType* Data)
+	{
+		check(IsInGameThread());
+
+		TEOSGlobalCallback* CallbackThis = (TEOSGlobalCallback*)Data->ClientData;
+		check(CallbackThis);
+
+		if (FCallbackBase::ShouldCancelAllCallbacks())
+		{
+			return;
+		}
+
+		check(CallbackThis->CallbackLambda);
+		CallbackThis->CallbackLambda(Data);
+	}
+};
+
+#include "eos_sessions_types.h"
+
+/**
+ * Implementation of session information
+ */
+class FOnlineSessionInfoEOS :
+	public FOnlineSessionInfo
+{
+protected:
+	/** Hidden on purpose */
+	FOnlineSessionInfoEOS& operator=(const FOnlineSessionInfoEOS& Src)
+	{
+		return *this;
+	}
+
+PACKAGE_SCOPE:
+	/** Constructor */
+	FOnlineSessionInfoEOS();
+
+	FOnlineSessionInfoEOS(const FOnlineSessionInfoEOS& Src)
+		: FOnlineSessionInfo(Src)
+		, HostAddr(Src.HostAddr)
+		, SessionId(Src.SessionId)
+		, SessionHandle(Src.SessionHandle)
+		, bIsFromClone(true)
+	{
+	}
+
+	FOnlineSessionInfoEOS(const FString& InHostIp, const FString& InSessionId, EOS_HSessionDetails InSessionHandle);
+
+	FOnlineSessionInfoEOS(const FString& InHostIp, FUniqueNetIdEOSRef UniqueNetId, EOS_HSessionDetails InSessionHandle);
+
+	/**
+	 * Initialize LAN session
+	 */
+	void InitLAN(FOnlineSubsystemEOS* Subsystem);
+
+	FString EOSAddress;
+	/** The ip & port that the host is listening on (valid for LAN/GameServer) */
+	TSharedPtr<class FInternetAddr> HostAddr;
+	/** Unique Id for this session */
+	FUniqueNetIdStringRef SessionId;
+	/** EOS session handle. Note: this needs to be released by the SDK */
+	EOS_HSessionDetails SessionHandle;
+	/** Whether we should delete this handle or not */
+	bool bIsFromClone;
+
+public:
+	virtual ~FOnlineSessionInfoEOS();
+	bool operator==(const FOnlineSessionInfoEOS& Other) const
+	{
+		return false;
+	}
+	virtual const uint8* GetBytes() const override
+	{
+		return nullptr;
+	}
+	virtual int32 GetSize() const override
+	{
+		return sizeof(uint64) + sizeof(TSharedPtr<class FInternetAddr>);
+	}
+	virtual bool IsValid() const override
+	{
+		// LAN case
+		return HostAddr.IsValid() && HostAddr->IsValid();
+	}
+	virtual FString ToString() const override
+	{
+		return SessionId->ToString();
+	}
+	virtual FString ToDebugString() const override
+	{
+		return FString::Printf(TEXT("HostIP: %s SessionId: %s"),
+			HostAddr.IsValid() ? *HostAddr->ToString(true) : TEXT("INVALID"),
+			*SessionId->ToDebugString());
+	}
+	virtual const FUniqueNetId& GetSessionId() const override
+	{
+		return *SessionId;
+	}
+};
+
+#endif
Index: Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Private/SocketEOS.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Private/SocketEOS.cpp b/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Private/SocketEOS.cpp
new file mode 100644
--- /dev/null	(date 1641575208000)
+++ b/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Private/SocketEOS.cpp	(date 1641575208000)
@@ -0,0 +1,676 @@
+// Copyright Epic Games, Inc. All Rights Reserved.
+
+#include "SocketEOS.h"
+#include "SocketTypes.h"
+#include "SocketSubsystemEOS.h"
+
+#if WITH_EOS_SDK
+	#include "eos_p2p.h"
+#endif
+
+#if WANTS_NP_LOGGING
+
+#include "Windows/AllowWindowsPlatformTypes.h"
+THIRD_PARTY_INCLUDES_START
+#include <Windows.h>
+THIRD_PARTY_INCLUDES_END
+
+const TCHAR* GetLogPrefix()
+{
+	static FString Prefix;
+	if (Prefix.Len() == 0)
+	{
+		FParse::Value(FCommandLine::Get(), TEXT("LogPrefix="), Prefix);
+		if (Prefix.Len() == 0)
+		{
+			Prefix = TEXT("Unknown");
+		}
+	}
+	return *Prefix;
+}
+
+void NpLog(const TCHAR* Msg)
+{
+	static HWND EditWindow = NULL;
+	// Get the edit window so we can send messages to it
+	if (EditWindow == NULL)
+	{
+		HWND MainWindow = FindWindowW(NULL, L"Untitled - Notepad");
+		if (MainWindow == NULL)
+		{
+			MainWindow = FindWindowW(NULL, L"*Untitled - Notepad");
+		}
+		if (MainWindow != NULL)
+		{
+			EditWindow = FindWindowExW(MainWindow, NULL, L"Edit", NULL);
+		}
+	}
+	if (EditWindow != NULL)
+	{
+		SendMessageW(EditWindow, EM_REPLACESEL, TRUE, (LPARAM)Msg);
+	}
+}
+
+#include "Windows/HideWindowsPlatformTypes.h"
+#endif
+
+FSocketEOS::FSocketEOS(FSocketSubsystemEOS& InSocketSubsystem, const FString& InSocketDescription)
+	: FSocket(ESocketType::SOCKTYPE_Datagram, InSocketDescription, NAME_None)
+	, SocketSubsystem(InSocketSubsystem)
+	, bIsListening(false)
+#if WITH_EOS_SDK
+	, ConnectNotifyCallback(nullptr)
+	, ConnectNotifyId(EOS_INVALID_NOTIFICATIONID)
+	, ClosedNotifyCallback(nullptr)
+	, ClosedNotifyId(EOS_INVALID_NOTIFICATIONID)
+#endif
+{
+}
+
+FSocketEOS::~FSocketEOS()
+{
+	Close();
+
+	if (LocalAddress.IsValid())
+	{
+		SocketSubsystem.UnbindChannel(LocalAddress);
+		LocalAddress = FInternetAddrEOS();
+	}
+}
+
+bool FSocketEOS::Shutdown(ESocketShutdownMode Mode)
+{
+	SocketSubsystem.SetLastSocketError(ESocketErrors::SE_EOPNOTSUPP);
+	return false;
+}
+
+bool FSocketEOS::Close()
+{
+	check(IsInGameThread() && "p2p does not support multithreading");
+
+#if WITH_EOS_SDK
+	if (ConnectNotifyId != EOS_INVALID_NOTIFICATIONID)
+	{
+		EOS_P2P_RemoveNotifyPeerConnectionRequest(SocketSubsystem.GetP2PHandle(), ConnectNotifyId);
+	}
+	delete ConnectNotifyCallback;
+	ConnectNotifyCallback = nullptr;
+	if (ClosedNotifyId != EOS_INVALID_NOTIFICATIONID)
+	{
+		EOS_P2P_RemoveNotifyPeerConnectionClosed(SocketSubsystem.GetP2PHandle(), ClosedNotifyId);
+	}
+	delete ClosedNotifyCallback;
+	ClosedNotifyCallback = nullptr;
+
+	if (LocalAddress.IsValid())
+	{
+		EOS_P2P_SocketId SocketId = { };
+		SocketId.ApiVersion = EOS_P2P_SOCKETID_API_LATEST;
+		FCStringAnsi::Strcpy(SocketId.SocketName, LocalAddress.GetSocketName());
+
+		EOS_P2P_CloseConnectionsOptions Options = { };
+		Options.ApiVersion = EOS_P2P_CLOSECONNECTIONS_API_LATEST;
+		Options.LocalUserId = SocketSubsystem.GetLocalUserId();
+		Options.SocketId = &SocketId;
+
+		EOS_EResult Result = EOS_P2P_CloseConnections(SocketSubsystem.GetP2PHandle(), &Options);
+
+		UE_LOG(LogSocketSubsystemEOS, Log, TEXT("Closing socket (%s) with result (%s)"), *LocalAddress.ToString(true), ANSI_TO_TCHAR(EOS_EResult_ToString(Result)));
+		NP_LOG(TEXT("[%s] - Closing socket (%s) with result (%s)\r\n"), GetLogPrefix(), *LocalAddress.ToString(true), ANSI_TO_TCHAR(EOS_EResult_ToString(Result)));
+
+		ClosedRemotes.Empty();
+	}
+#endif
+	return true;
+}
+
+bool FSocketEOS::Bind(const FInternetAddr& Addr)
+{
+	check(IsInGameThread() && "p2p does not support multithreading");
+
+	if (!Addr.IsValid())
+	{
+		UE_LOG(LogSocketSubsystemEOS, Warning, TEXT("Attempted to bind to invalid address. Address = (%s)"), *Addr.ToString(true));
+		SocketSubsystem.SetLastSocketError(ESocketErrors::SE_EADDRNOTAVAIL);
+		return false;
+	}
+
+	// Ensure we called Initialize so we know who we are
+	if (LocalAddress.GetRemoteUserId() != nullptr)
+	{
+		UE_LOG(LogSocketSubsystemEOS, Warning, TEXT("Attempted to bind on a socket that was not initialized. Address = (%s)"), *Addr.ToString(true));
+		SocketSubsystem.SetLastSocketError(ESocketErrors::SE_NOTINITIALISED);
+		return false;
+	}
+
+	// If we have a remote user id, we're already bound
+	if (LocalAddress.GetRemoteUserId() != nullptr)
+	{
+		UE_LOG(LogSocketSubsystemEOS, Warning, TEXT("Attempted to bind a socket that was already bound. ExistingAddress = (%s) NewAddress = (%s)"), *LocalAddress.ToString(true), *Addr.ToString(true));
+		SocketSubsystem.SetLastSocketError(ESocketErrors::SE_EADDRINUSE);
+		return false;
+	}
+
+	const FInternetAddrEOS& EOSAddr = static_cast<const FInternetAddrEOS&>(Addr);
+	if (!SocketSubsystem.BindChannel(EOSAddr))
+	{
+		UE_LOG(LogSocketSubsystemEOS, Warning, TEXT("Attempted to bind a socket to a port in use. NewAddress = (%s)"), *Addr.ToString(true));
+		// BindPort sets our LastSocketError
+		return false;
+	}
+
+#if WITH_EOS_SDK
+	EOS_ProductUserId LocalUserId = LocalAddress.GetLocalUserId();
+#else
+	void* LocalUserId = LocalAddress.GetLocalUserId();
+#endif
+	LocalAddress = EOSAddr;
+	LocalAddress.SetLocalUserId(LocalUserId);
+
+	UE_LOG(LogSocketSubsystemEOS, Verbose, TEXT("Successfully bound socket to address (%s)"), *LocalAddress.ToString(true));
+	NP_LOG(TEXT("[%s] - Successfully bound socket to address (%s)\r\n"), GetLogPrefix(), *LocalAddress.ToString(true));
+	return true;
+}
+
+bool FSocketEOS::Connect(const FInternetAddr& Addr)
+{
+	/** Not supported - connectionless (UDP) only */
+	SocketSubsystem.SetLastSocketError(ESocketErrors::SE_EOPNOTSUPP);
+	return false;
+}
+
+bool FSocketEOS::Listen(int32)
+{
+	check(IsInGameThread() && "p2p does not support multithreading");
+
+	if (!LocalAddress.IsValid())
+	{
+		UE_LOG(LogSocketSubsystemEOS, Warning, TEXT("Attempted to listen without a bound address. Address = (%s)"), *LocalAddress.ToString(true));
+		SocketSubsystem.SetLastSocketError(ESocketErrors::SE_EADDRINUSE);
+		return false;
+	}
+
+#if WITH_EOS_SDK
+	// Add listener for inbound connections
+	EOS_P2P_SocketId SocketId = { };
+	SocketId.ApiVersion = EOS_P2P_SOCKETID_API_LATEST;
+	FCStringAnsi::Strcpy(SocketId.SocketName, LocalAddress.GetSocketName());
+
+	EOS_P2P_AddNotifyPeerConnectionRequestOptions Options = { };
+	Options.ApiVersion = EOS_P2P_ADDNOTIFYPEERCONNECTIONREQUEST_API_LATEST;
+	Options.LocalUserId = LocalAddress.GetLocalUserId();
+	Options.SocketId = &SocketId;
+
+	ConnectNotifyCallback = new FConnectNotifyCallback();
+	ConnectNotifyCallback->CallbackLambda = [this](const EOS_P2P_OnIncomingConnectionRequestInfo* Info)
+	{
+		char PuidBuffer[64];
+		int32 BufferLen = 64;
+		if (EOS_ProductUserId_ToString(Info->RemoteUserId, PuidBuffer, &BufferLen) != EOS_EResult::EOS_Success)
+		{
+			PuidBuffer[0] = '\0';
+		}
+		FString RemoteUser(PuidBuffer);
+
+		if (Info->LocalUserId == LocalAddress.GetLocalUserId() && FCStringAnsi::Stricmp(Info->SocketId->SocketName, LocalAddress.GetSocketName()) == 0)
+		{
+			// In case they disconnected and then reconnected, remove them from our closed list
+			FInternetAddrEOS RemoteAddress(Info->RemoteUserId, Info->SocketId->SocketName, LocalAddress.GetChannel());
+			RemoteAddress.SetLocalUserId(LocalAddress.GetLocalUserId());
+			ClosedRemotes.Remove(RemoteAddress);
+
+			EOS_P2P_SocketId SocketId = { };
+			SocketId.ApiVersion = EOS_P2P_SOCKETID_API_LATEST;
+			FCStringAnsi::Strcpy(SocketId.SocketName, Info->SocketId->SocketName);
+
+			EOS_P2P_AcceptConnectionOptions Options = { };
+			Options.ApiVersion = EOS_P2P_ACCEPTCONNECTION_API_LATEST;
+			Options.LocalUserId = LocalAddress.GetLocalUserId();
+			Options.RemoteUserId = Info->RemoteUserId;
+			Options.SocketId = &SocketId;
+			EOS_EResult AcceptResult = EOS_P2P_AcceptConnection(SocketSubsystem.GetP2PHandle(), &Options);
+			if (AcceptResult == EOS_EResult::EOS_Success)
+			{
+				UE_LOG(LogSocketSubsystemEOS, Verbose, TEXT("Accepting connection request from (%s) on socket (%s)"), *RemoteUser, UTF8_TO_TCHAR(Info->SocketId->SocketName));
+				NP_LOG(TEXT("[%s] - Accepting connection request from (%s) on socket (%s)\r\n"), GetLogPrefix(), *RemoteUser, UTF8_TO_TCHAR(Info->SocketId->SocketName));
+			}
+			else
+			{
+				UE_LOG(LogSocketSubsystemEOS, Error, TEXT("EOS_P2P_AcceptConnection from (%s) on socket (%s) failed with (%s)"), *RemoteUser, UTF8_TO_TCHAR(Info->SocketId->SocketName), ANSI_TO_TCHAR(EOS_EResult_ToString(AcceptResult)));
+				NP_LOG(TEXT("[%s] - EOS_P2P_AcceptConnection from (%s) on socket (%s) failed with (%s)\r\n"), GetLogPrefix(), *RemoteUser, UTF8_TO_TCHAR(Info->SocketId->SocketName), ANSI_TO_TCHAR(EOS_EResult_ToString(AcceptResult)));
+			}
+		}
+		else
+		{
+			UE_LOG(LogSocketSubsystemEOS, Warning, TEXT("Ignoring connection request from (%s) on socket (%s)"), *RemoteUser, UTF8_TO_TCHAR(Info->SocketId->SocketName));
+		}
+	};
+	ConnectNotifyId = EOS_P2P_AddNotifyPeerConnectionRequest(SocketSubsystem.GetP2PHandle(), &Options, ConnectNotifyCallback, ConnectNotifyCallback->GetCallbackPtr());
+
+	// Need to handle closures too
+	RegisterClosedNotification();
+#endif
+
+	bIsListening = true;
+
+	return true;
+}
+
+bool FSocketEOS::WaitForPendingConnection(bool& bHasPendingConnection, const FTimespan& WaitTime)
+{
+	/** Not supported - connectionless (UDP) only */
+	SocketSubsystem.SetLastSocketError(ESocketErrors::SE_EOPNOTSUPP);
+	return false;
+}
+
+bool FSocketEOS::HasPendingData(uint32& PendingDataSize)
+{
+	check(IsInGameThread() && "p2p does not support multithreading");
+
+	PendingDataSize = 0;
+
+#if WITH_EOS_SDK
+	EOS_P2P_GetNextReceivedPacketSizeOptions Options = { };
+	Options.ApiVersion = EOS_P2P_GETNEXTRECEIVEDPACKETSIZE_API_LATEST;
+	Options.LocalUserId = LocalAddress.GetLocalUserId();
+	uint8 Channel = LocalAddress.GetChannel();
+	Options.RequestedChannel = &Channel;
+
+	EOS_EResult Result = EOS_P2P_GetNextReceivedPacketSize(SocketSubsystem.GetP2PHandle(), &Options, &PendingDataSize);
+	if (Result == EOS_EResult::EOS_NotFound)
+	{
+		return false;
+	}
+	if (Result != EOS_EResult::EOS_Success)
+	{
+		UE_LOG(LogSocketSubsystemEOS, Warning, TEXT("Unable to check for data on address (%s) result code = (%s)"), *LocalAddress.ToString(true), ANSI_TO_TCHAR(EOS_EResult_ToString(Result)));
+
+		// @todo joeg - map EOS codes to UE4's
+		SocketSubsystem.SetLastSocketError(ESocketErrors::SE_EINVAL);
+		return false;
+	}
+
+	return true;
+#else
+	return false;
+#endif
+}
+
+FSocket* FSocketEOS::Accept(const FString& InSocketDescription)
+{
+	/** Not supported - connectionless (UDP) only */
+	SocketSubsystem.SetLastSocketError(ESocketErrors::SE_EOPNOTSUPP);
+	return nullptr;
+}
+
+FSocket* FSocketEOS::Accept(FInternetAddr& OutAddr, const FString& InSocketDescription)
+{
+	/** Not supported - connectionless (UDP) only */
+	SocketSubsystem.SetLastSocketError(ESocketErrors::SE_EOPNOTSUPP);
+	return nullptr;
+}
+
+bool FSocketEOS::SendTo(const uint8* Data, int32 Count, int32& OutBytesSent, const FInternetAddr& Destination)
+{
+	check(IsInGameThread() && "p2p does not support multithreading");
+
+	OutBytesSent = 0;
+
+	if (!Destination.IsValid())
+	{
+		UE_LOG(LogSocketSubsystemEOS, Warning, TEXT("Unable to send data, invalid destination address. DestinationAddress = (%s)"), *Destination.ToString(true));
+
+		SocketSubsystem.SetLastSocketError(ESocketErrors::SE_EADDRNOTAVAIL);
+		return false;
+	}
+
+#if WITH_EOS_SDK
+	if (Count > EOS_P2P_MAX_PACKET_SIZE)
+	{
+		UE_LOG(LogSocketSubsystemEOS, Warning, TEXT("Unable to send data, data over maximum size. Amount=[%d/%d] DestinationAddress = (%s)"), Count, EOS_P2P_MAX_PACKET_SIZE, *Destination.ToString(true));
+
+		SocketSubsystem.SetLastSocketError(ESocketErrors::SE_EMSGSIZE);
+		return false;
+	}
+
+	if (Count < 0)
+	{
+		UE_LOG(LogSocketSubsystemEOS, Warning, TEXT("Unable to send data, data invalid. Amount=[%d/%d] DestinationAddress = (%s)"), Count, EOS_P2P_MAX_PACKET_SIZE, *Destination.ToString(true));
+
+		SocketSubsystem.SetLastSocketError(ESocketErrors::SE_EINVAL);
+		return false;
+	}
+#endif 
+
+	if (Data == nullptr && Count != 0)
+	{
+		UE_LOG(LogSocketSubsystemEOS, Warning, TEXT("Unable to send data, data invalid. DestinationAddress = (%s)"), *Destination.ToString(true));
+
+		SocketSubsystem.SetLastSocketError(ESocketErrors::SE_EINVAL);
+		return false;
+	}
+
+	if (!LocalAddress.IsValid())
+	{
+		UE_LOG(LogSocketSubsystemEOS, Warning, TEXT("Unable to send data, socket was not initialized. DestinationAddress = (%s)"), *Destination.ToString(true));
+
+		SocketSubsystem.SetLastSocketError(ESocketErrors::SE_NOTINITIALISED);
+		return false;
+	}
+
+	const FInternetAddrEOS& DestinationAddress = static_cast<const FInternetAddrEOS&>(Destination);
+	if (LocalAddress == DestinationAddress)
+	{
+		UE_LOG(LogSocketSubsystemEOS, Warning, TEXT("Unable to send data, unable to send data to ourselves. DestinationAddress = (%s)"), *Destination.ToString(true));
+
+		SocketSubsystem.SetLastSocketError(ESocketErrors::SE_ECONNREFUSED);
+		return false;
+	}
+
+	// Check for sending to an address we explicitly closed
+	if (WasClosed(DestinationAddress))
+	{
+		UE_LOG(LogSocketSubsystemEOS, Warning, TEXT("Unable to send data to closed connection. DestinationAddress = (%s)"), *Destination.ToString(true));
+
+		SocketSubsystem.SetLastSocketError(ESocketErrors::SE_ECONNREFUSED);
+		return false;
+	}
+
+#if WITH_EOS_SDK
+	// Need to handle closures if we are a client and the server closes down on us
+	RegisterClosedNotification();
+
+	EOS_P2P_SocketId SocketId = { };
+	SocketId.ApiVersion = EOS_P2P_SOCKETID_API_LATEST;
+	FCStringAnsi::Strcpy(SocketId.SocketName, DestinationAddress.GetSocketName());
+
+	EOS_P2P_SendPacketOptions Options = { };
+	Options.ApiVersion = EOS_P2P_SENDPACKET_API_LATEST;
+	Options.LocalUserId = LocalAddress.GetLocalUserId();
+	Options.RemoteUserId = DestinationAddress.GetRemoteUserId();
+	Options.SocketId = &SocketId;
+	Options.bAllowDelayedDelivery = EOS_TRUE;
+	Options.Reliability = EOS_EPacketReliability::EOS_PR_UnreliableUnordered;
+	Options.Channel = DestinationAddress.GetChannel();
+	Options.DataLengthBytes = Count;
+	Options.Data = Data;
+	EOS_EResult Result = EOS_P2P_SendPacket(SocketSubsystem.GetP2PHandle(), &Options);
+	NP_LOG(TEXT("[%s] - EOS_P2P_SendPacket() to (%s) result code = (%s)\r\n"), GetLogPrefix(), *Destination.ToString(true), ANSI_TO_TCHAR(EOS_EResult_ToString(Result)));
+	if (Result != EOS_EResult::EOS_Success)
+	{
+		UE_LOG(LogSocketSubsystemEOS, Error, TEXT("Unable to send data to (%s) result code = (%s)"), *Destination.ToString(true), ANSI_TO_TCHAR(EOS_EResult_ToString(Result)));
+
+		// @todo joeg - map EOS codes to UE4's
+		SocketSubsystem.SetLastSocketError(ESocketErrors::SE_EINVAL);
+		return false;
+	}
+	OutBytesSent = Count;
+	return true;
+#else
+	return false;
+#endif
+}
+
+bool FSocketEOS::Send(const uint8* Data, int32 Count, int32& BytesSent)
+{
+	/** Not supported - connectionless (UDP) only */
+	SocketSubsystem.SetLastSocketError(ESocketErrors::SE_EOPNOTSUPP);
+	BytesSent = 0;
+	return false;
+}
+
+bool FSocketEOS::RecvFrom(uint8* Data, int32 BufferSize, int32& BytesRead, FInternetAddr& Source, ESocketReceiveFlags::Type Flags)
+{
+	check(IsInGameThread() && "p2p does not support multithreading");
+	BytesRead = 0;
+
+	if (BufferSize < 0)
+	{
+		UE_LOG(LogSocketSubsystemEOS, Error, TEXT("Unable to receive data, receiving buffer was invalid. BufferSize = (%d)"), BufferSize);
+
+		SocketSubsystem.SetLastSocketError(ESocketErrors::SE_EINVAL);
+		return false;
+	}
+
+	if (Flags != ESocketReceiveFlags::None)
+	{
+		// We do not support peaking / blocking until a packet comes
+		UE_LOG(LogSocketSubsystemEOS, Error, TEXT("Socket receive flags (%d) are not supported"), int32(Flags));
+
+		SocketSubsystem.SetLastSocketError(ESocketErrors::SE_EOPNOTSUPP);
+		return false;
+	}
+
+#if WITH_EOS_SDK
+	EOS_P2P_ReceivePacketOptions Options = { };
+	Options.ApiVersion = EOS_P2P_RECEIVEPACKET_API_LATEST;
+	Options.LocalUserId = LocalAddress.GetLocalUserId();
+	Options.MaxDataSizeBytes = BufferSize;
+	uint8 Channel = LocalAddress.GetChannel();
+	Options.RequestedChannel = &Channel;
+
+	EOS_ProductUserId RemoteUserId = nullptr;
+	EOS_P2P_SocketId SocketId;
+	
+	EOS_EResult Result = EOS_P2P_ReceivePacket(SocketSubsystem.GetP2PHandle(), &Options, &RemoteUserId, &SocketId, &Channel, Data, (uint32*)&BytesRead);
+	NP_LOG(TEXT("[%s] - EOS_P2P_ReceivePacket() for user (%s) and channel (%d) with result code = (%s)\r\n"), GetLogPrefix(), *MakeStringFromProductUserId(LocalAddress.GetLocalUserId()), Channel, ANSI_TO_TCHAR(EOS_EResult_ToString(Result)));
+	if (Result == EOS_EResult::EOS_NotFound)
+	{
+		// No data to read
+		SocketSubsystem.SetLastSocketError(ESocketErrors::SE_EWOULDBLOCK);
+		return false;
+	}
+	else if (Result != EOS_EResult::EOS_Success)
+	{
+		UE_LOG(LogSocketSubsystemEOS, Error, TEXT("Unable to receive data result code = (%s)"), ANSI_TO_TCHAR(EOS_EResult_ToString(Result)));
+
+		// @todo joeg - map EOS codes to UE4's
+		SocketSubsystem.SetLastSocketError(ESocketErrors::SE_EINVAL);
+		return false;
+	}
+
+	FInternetAddrEOS& SourceAddress = static_cast<FInternetAddrEOS&>(Source);
+	SourceAddress.SetLocalUserId(LocalAddress.GetLocalUserId());
+	SourceAddress.SetRemoteUserId(RemoteUserId);
+	SourceAddress.SetSocketName(SocketId.SocketName);
+	SourceAddress.SetChannel(Channel);
+
+	NP_LOG(TEXT("[%s] - EOS_P2P_ReceivePacket() of size (%d) from (%s)\r\n"), GetLogPrefix(), BytesRead, *SourceAddress.ToString(true));
+	return true;
+#else
+	return false;
+#endif
+}
+
+bool FSocketEOS::Recv(uint8* Data, int32 BufferSize, int32& BytesRead, ESocketReceiveFlags::Type Flags)
+{
+	BytesRead = 0;
+	SocketSubsystem.SetLastSocketError(ESocketErrors::SE_EOPNOTSUPP);
+	return false;
+}
+
+bool FSocketEOS::Wait(ESocketWaitConditions::Type Condition, FTimespan WaitTime)
+{
+	SocketSubsystem.SetLastSocketError(ESocketErrors::SE_EOPNOTSUPP);
+	return false;
+}
+
+ESocketConnectionState FSocketEOS::GetConnectionState()
+{
+	return ESocketConnectionState::SCS_NotConnected;
+}
+
+void FSocketEOS::GetAddress(FInternetAddr& OutAddr)
+{
+	OutAddr = LocalAddress;
+}
+
+bool FSocketEOS::GetPeerAddress(FInternetAddr& OutAddr)
+{
+	SocketSubsystem.SetLastSocketError(ESocketErrors::SE_EOPNOTSUPP);
+	return false;
+}
+
+bool FSocketEOS::SetNonBlocking(bool bIsNonBlocking)
+{
+	return true;
+}
+
+bool FSocketEOS::SetBroadcast(bool bAllowBroadcast)
+{
+	return true;
+}
+
+bool FSocketEOS::SetNoDelay(bool bIsNoDelay)
+{
+	return true;
+}
+
+bool FSocketEOS::JoinMulticastGroup(const FInternetAddr& GroupAddress)
+{
+	SocketSubsystem.SetLastSocketError(ESocketErrors::SE_EOPNOTSUPP);
+	return false;
+}
+
+bool FSocketEOS::LeaveMulticastGroup(const FInternetAddr& GroupAddress)
+{
+	SocketSubsystem.SetLastSocketError(ESocketErrors::SE_EOPNOTSUPP);
+	return false;
+}
+
+bool FSocketEOS::SetMulticastLoopback(bool bLoopback)
+{
+	SocketSubsystem.SetLastSocketError(ESocketErrors::SE_EOPNOTSUPP);
+	return false;
+}
+
+bool FSocketEOS::SetMulticastTtl(uint8 TimeToLive)
+{
+	SocketSubsystem.SetLastSocketError(ESocketErrors::SE_EOPNOTSUPP);
+	return false;
+}
+
+bool FSocketEOS::JoinMulticastGroup(const FInternetAddr& GroupAddress, const FInternetAddr& InterfaceAddress)
+{
+	SocketSubsystem.SetLastSocketError(ESocketErrors::SE_EOPNOTSUPP);
+	return false;
+}
+
+bool FSocketEOS::LeaveMulticastGroup(const FInternetAddr& GroupAddress, const FInternetAddr& InterfaceAddress)
+{
+	SocketSubsystem.SetLastSocketError(ESocketErrors::SE_EOPNOTSUPP);
+	return false;
+}
+
+bool FSocketEOS::SetMulticastInterface(const FInternetAddr& InterfaceAddress)
+{
+	SocketSubsystem.SetLastSocketError(ESocketErrors::SE_EOPNOTSUPP);
+	return false;
+}
+
+bool FSocketEOS::SetReuseAddr(bool bAllowReuse)
+{
+	return true;
+}
+
+bool FSocketEOS::SetLinger(bool bShouldLinger, int32 Timeout)
+{
+	return true;
+}
+
+bool FSocketEOS::SetRecvErr(bool bUseErrorQueue)
+{
+	return true;
+}
+
+bool FSocketEOS::SetSendBufferSize(int32 Size, int32& NewSize)
+{
+	return true;
+}
+
+bool FSocketEOS::SetReceiveBufferSize(int32 Size, int32& NewSize)
+{
+	return true;
+}
+
+int32 FSocketEOS::GetPortNo()
+{
+	return LocalAddress.GetChannel();
+}
+
+void FSocketEOS::SetLocalAddress(const FInternetAddrEOS& InLocalAddress)
+{
+	LocalAddress = InLocalAddress;
+}
+
+bool FSocketEOS::Close(const FInternetAddrEOS& RemoteAddress)
+{
+	check(IsInGameThread() && "p2p does not support multithreading");
+
+	if (!RemoteAddress.IsValid())
+	{
+		UE_LOG(LogSocketSubsystemEOS, Error, TEXT("Unable to close socket with remote address as it is invalid RemoteAddress = (%s)"), *RemoteAddress.ToString(true));
+		SocketSubsystem.SetLastSocketError(ESocketErrors::SE_EADDRNOTAVAIL);
+		return false;
+	}
+
+#if WITH_EOS_SDK
+	// So we don't reopen a connection by sending to it
+	ClosedRemotes.Add(RemoteAddress);
+
+	EOS_P2P_SocketId SocketId = { };
+	SocketId.ApiVersion = EOS_P2P_SOCKETID_API_LATEST;
+	FCStringAnsi::Strcpy(SocketId.SocketName, RemoteAddress.GetSocketName());
+
+	EOS_P2P_CloseConnectionOptions Options = { };
+	Options.ApiVersion = EOS_P2P_CLOSECONNECTION_API_LATEST;
+	Options.LocalUserId = LocalAddress.GetLocalUserId();
+	Options.RemoteUserId = RemoteAddress.GetRemoteUserId();
+	Options.SocketId = &SocketId;
+
+	EOS_EResult Result = EOS_P2P_CloseConnection(SocketSubsystem.GetP2PHandle(), &Options);
+	NP_LOG(TEXT("[%s] - EOS_P2P_CloseConnection() with remote address RemoteAddress (%s) result code (%s)\r\n"), GetLogPrefix(), *RemoteAddress.ToString(true), ANSI_TO_TCHAR(EOS_EResult_ToString(Result)));
+	if (Result != EOS_EResult::EOS_Success)
+	{
+		UE_LOG(LogSocketSubsystemEOS, Error, TEXT("Unable to close socket with remote address RemoteAddress (%s) due to error (%s)"), *RemoteAddress.ToString(true), ANSI_TO_TCHAR(EOS_EResult_ToString(Result)));
+
+		// @todo joeg - map EOS codes to UE4's
+		SocketSubsystem.SetLastSocketError(ESocketErrors::SE_EINVAL);
+		return false;
+	}
+	return true;
+#else
+	return false;
+#endif
+}
+
+void FSocketEOS::RegisterClosedNotification()
+{
+#if WITH_EOS_SDK
+	if (ClosedNotifyId != EOS_INVALID_NOTIFICATIONID)
+	{
+		// Already listening for these events so ignore
+		return;
+	}
+	
+	EOS_P2P_SocketId SocketId = { };
+	SocketId.ApiVersion = EOS_P2P_SOCKETID_API_LATEST;
+	FCStringAnsi::Strcpy(SocketId.SocketName, LocalAddress.GetSocketName());
+
+	EOS_P2P_AddNotifyPeerConnectionClosedOptions Options = { };
+	Options.ApiVersion = EOS_P2P_ADDNOTIFYPEERCONNECTIONCLOSED_API_LATEST;
+	Options.LocalUserId = LocalAddress.GetLocalUserId();
+	Options.SocketId = &SocketId;
+
+	ClosedNotifyCallback = new FClosedNotifyCallback();
+	ClosedNotifyCallback->CallbackLambda = [this](const EOS_P2P_OnRemoteConnectionClosedInfo* Info)
+	{
+		// Add this connection to the list of closed ones
+		FInternetAddrEOS RemoteAddress(Info->RemoteUserId, Info->SocketId->SocketName, LocalAddress.GetChannel());
+		RemoteAddress.SetLocalUserId(LocalAddress.GetLocalUserId());
+		ClosedRemotes.Add(RemoteAddress);
+		NP_LOG(TEXT("[%s] - Close connection received for remote address (%s)\r\n"), GetLogPrefix(), *RemoteAddress.ToString(true));
+	};
+	ClosedNotifyId = EOS_P2P_AddNotifyPeerConnectionClosed(SocketSubsystem.GetP2PHandle(), &Options, ClosedNotifyCallback, ClosedNotifyCallback->GetCallbackPtr());
+#endif
+}
Index: Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Private/UserManagerEOS.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Private/UserManagerEOS.cpp b/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Private/UserManagerEOS.cpp
new file mode 100644
--- /dev/null	(date 1641576012000)
+++ b/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Private/UserManagerEOS.cpp	(date 1641576012000)
@@ -0,0 +1,2840 @@
+// Copyright Epic Games, Inc. All Rights Reserved.
+
+#include "UserManagerEOS.h"
+#include "OnlineSubsystemEOS.h"
+#include "Misc/CommandLine.h"
+#include "Misc/Guid.h"
+#include "Misc/OutputDeviceRedirector.h"
+#include "IPAddress.h"
+#include "SocketSubsystem.h"
+#include "OnlineError.h"
+#include "EOSSettings.h"
+#include "CoreMinimal.h"
+#include "IEOSSDKManager.h"
+
+#include COMPILED_PLATFORM_HEADER(EOSHelpers.h)
+
+#if WITH_EOS_SDK
+
+#include "eos_auth.h"
+#include "eos_userinfo.h"
+#include "eos_friends.h"
+#include "eos_presence.h"
+#include "eos_ui.h"
+
+static inline EInviteStatus::Type ToEInviteStatus(EOS_EFriendsStatus InStatus)
+{
+	switch (InStatus)
+	{
+		case EOS_EFriendsStatus::EOS_FS_InviteSent:
+		{
+			return EInviteStatus::PendingOutbound;
+		}
+		case EOS_EFriendsStatus::EOS_FS_InviteReceived:
+		{
+			return EInviteStatus::PendingInbound;
+		}
+		case EOS_EFriendsStatus::EOS_FS_Friends:
+		{
+			return EInviteStatus::Accepted;
+		}
+	}
+	return EInviteStatus::Unknown;
+}
+
+static inline EOnlinePresenceState::Type ToEOnlinePresenceState(EOS_Presence_EStatus InStatus)
+{
+	switch (InStatus)
+	{
+		case EOS_Presence_EStatus::EOS_PS_Online:
+		{
+			return EOnlinePresenceState::Online;
+		}
+		case EOS_Presence_EStatus::EOS_PS_Away:
+		{
+			return EOnlinePresenceState::Away;
+		}
+		case EOS_Presence_EStatus::EOS_PS_ExtendedAway:
+		{
+			return EOnlinePresenceState::ExtendedAway;
+		}
+		case EOS_Presence_EStatus::EOS_PS_DoNotDisturb:
+		{
+			return EOnlinePresenceState::DoNotDisturb;
+		}
+	}
+	return EOnlinePresenceState::Offline;
+}
+
+static inline EOS_Presence_EStatus ToEOS_Presence_EStatus(EOnlinePresenceState::Type InStatus)
+{
+	switch (InStatus)
+	{
+		case EOnlinePresenceState::Online:
+		{
+			return EOS_Presence_EStatus::EOS_PS_Online;
+		}
+		case EOnlinePresenceState::Away:
+		{
+			return EOS_Presence_EStatus::EOS_PS_Away;
+		}
+		case EOnlinePresenceState::ExtendedAway:
+		{
+			return EOS_Presence_EStatus::EOS_PS_ExtendedAway;
+		}
+		case EOnlinePresenceState::DoNotDisturb:
+		{
+			return EOS_Presence_EStatus::EOS_PS_DoNotDisturb;
+		}
+	}
+	return EOS_Presence_EStatus::EOS_PS_Offline;
+}
+
+static inline EOS_EExternalCredentialType ToEOS_EExternalCredentialType(FName OSSName, const FOnlineAccountCredentials& AccountCredentials)
+{
+	if (OSSName == STEAM_SUBSYSTEM)
+	{
+		return EOS_EExternalCredentialType::EOS_ECT_STEAM_APP_TICKET;
+	}
+	else if (OSSName == PS4_SUBSYSTEM || USE_PSN_ID_TOKEN)
+	{
+		return EOS_EExternalCredentialType::EOS_ECT_PSN_ID_TOKEN;
+	}
+PRAGMA_DISABLE_DEPRECATION_WARNINGS
+	else if (OSSName == LIVE_SUBSYSTEM || USE_XBL_XSTS_TOKEN)
+	{
+		return EOS_EExternalCredentialType::EOS_ECT_XBL_XSTS_TOKEN;
+	}
+PRAGMA_ENABLE_DEPRECATION_WARNINGS
+	else if (OSSName == SWITCH_SUBSYSTEM)
+	{
+		if (AccountCredentials.Type == TEXT("NintendoAccount"))
+		{
+			return EOS_EExternalCredentialType::EOS_ECT_NINTENDO_ID_TOKEN;
+		}
+		else
+		{
+			return EOS_EExternalCredentialType::EOS_ECT_NINTENDO_NSA_ID_TOKEN;
+		}
+	}
+	else if (OSSName == APPLE_SUBSYSTEM)
+	{
+		return EOS_EExternalCredentialType::EOS_ECT_APPLE_ID_TOKEN;
+	}
+	// Unknown means OpenID
+	return EOS_EExternalCredentialType::EOS_ECT_OPENID_ACCESS_TOKEN;
+}
+
+/** Delegates that are used for internal calls and are meant to be ignored */
+IOnlinePresence::FOnPresenceTaskCompleteDelegate IgnoredPresenceDelegate;
+IOnlineUser::FOnQueryExternalIdMappingsComplete IgnoredMappingDelegate;
+
+typedef TEOSGlobalCallback<EOS_UI_OnDisplaySettingsUpdatedCallback, EOS_UI_OnDisplaySettingsUpdatedCallbackInfo> FOnDisplaySettingsUpdatedCallback;
+
+FUserManagerEOS::FUserManagerEOS(FOnlineSubsystemEOS* InSubsystem)
+	: EOSSubsystem(InSubsystem)
+	, DefaultLocalUser(-1)
+	, LoginNotificationId(0)
+	, LoginNotificationCallback(nullptr)
+	, FriendsNotificationId(0)
+	, FriendsNotificationCallback(nullptr)
+	, PresenceNotificationId(0)
+	, PresenceNotificationCallback(nullptr)
+{
+	// This delegate would cause a crash when running a dedicated server
+	if (!IsRunningDedicatedServer())
+	{
+	// Adding subscription to external ui display change event
+	EOS_UI_AddNotifyDisplaySettingsUpdatedOptions Options = {};
+	Options.ApiVersion = EOS_UI_ADDNOTIFYDISPLAYSETTINGSUPDATED_API_LATEST;
+
+	FOnDisplaySettingsUpdatedCallback* CallbackObj = new FOnDisplaySettingsUpdatedCallback();
+	DisplaySettingsUpdatedCallback = CallbackObj;
+	CallbackObj->CallbackLambda = [this](const EOS_UI_OnDisplaySettingsUpdatedCallbackInfo* Data)
+	{
+		TriggerOnExternalUIChangeDelegates((bool)Data->bIsVisible);
+	};
+
+	DisplaySettingsUpdatedId = EOS_UI_AddNotifyDisplaySettingsUpdated(EOSSubsystem->UIHandle, &Options, CallbackObj, CallbackObj->GetCallbackPtr());
+}
+}
+
+FUserManagerEOS::~FUserManagerEOS()
+{
+	// Removing subscription to external ui display change event
+	EOS_UI_RemoveNotifyDisplaySettingsUpdated(EOSSubsystem->UIHandle, DisplaySettingsUpdatedId);
+
+	delete DisplaySettingsUpdatedCallback;
+}
+
+void FUserManagerEOS::LoginStatusChanged(const EOS_Auth_LoginStatusChangedCallbackInfo* Data)
+{
+	if (Data->CurrentStatus == EOS_ELoginStatus::EOS_LS_NotLoggedIn)
+	{
+		if (AccountIdToUserNumMap.Contains(Data->LocalUserId))
+		{
+			int32 LocalUserNum = AccountIdToUserNumMap[Data->LocalUserId];
+			FUniqueNetIdEOSPtr UserNetId = UserNumToNetIdMap[LocalUserNum];
+			TriggerOnLoginStatusChangedDelegates(LocalUserNum, ELoginStatus::LoggedIn, ELoginStatus::NotLoggedIn, *UserNetId);
+			// Need to remove the local user
+			RemoveLocalUser(LocalUserNum);
+
+			// Clean up user based notifies if we have no logged in users
+			if (UserNumToNetIdMap.Num() == 0)
+			{
+				if (LoginNotificationId > 0)
+				{
+					// Remove the callback
+					EOS_Auth_RemoveNotifyLoginStatusChanged(EOSSubsystem->AuthHandle, LoginNotificationId);
+					delete LoginNotificationCallback;
+					LoginNotificationCallback = nullptr;
+					LoginNotificationId = 0;
+				}
+				if (FriendsNotificationId > 0)
+				{
+					EOS_Friends_RemoveNotifyFriendsUpdate(EOSSubsystem->FriendsHandle, FriendsNotificationId);
+					delete FriendsNotificationCallback;
+					FriendsNotificationCallback = nullptr;
+					FriendsNotificationId = 0;
+				}
+				if (PresenceNotificationId > 0)
+				{
+					EOS_Presence_RemoveNotifyOnPresenceChanged(EOSSubsystem->PresenceHandle, PresenceNotificationId);
+					delete PresenceNotificationCallback;
+					PresenceNotificationCallback = nullptr;
+					PresenceNotificationId = 0;
+				}
+				// Remove the per user connect login notification
+				if (LocalUserNumToConnectLoginNotifcationMap.Contains(LocalUserNum))
+				{
+					FNotificationIdCallbackPair* NotificationPair = LocalUserNumToConnectLoginNotifcationMap[LocalUserNum];
+					LocalUserNumToConnectLoginNotifcationMap.Remove(LocalUserNum);
+
+					EOS_Connect_RemoveNotifyAuthExpiration(EOSSubsystem->ConnectHandle, NotificationPair->NotificationId);
+
+					delete NotificationPair;
+				}
+			}
+		}
+	}
+}
+
+IOnlineSubsystem* FUserManagerEOS::GetPlatformOSS()
+{
+	IOnlineSubsystem* PlatformOSS = IOnlineSubsystem::GetByPlatform();
+	if (PlatformOSS == nullptr)
+#if !PLATFORM_DESKTOP
+	{
+		UE_LOG_ONLINE(Error, TEXT("GetPlatformOSS() failed due to no platform OSS being configured"));
+	}
+#else
+	{
+		// Attempt to load Steam before treating it as an error
+		PlatformOSS = IOnlineSubsystem::Get(STEAM_SUBSYSTEM);
+	}
+#endif
+	return PlatformOSS;
+}
+
+void FUserManagerEOS::GetPlatformAuthToken(int32 LocalUserNum, const FOnGetLinkedAccountAuthTokenCompleteDelegate& Delegate)
+{
+	IOnlineSubsystem* PlatformOSS = GetPlatformOSS();
+	if (PlatformOSS == nullptr)
+	{
+		UE_LOG_ONLINE(Error, TEXT("ConnectLoginNoEAS(%d) failed due to no platform OSS"), LocalUserNum);
+		Delegate.ExecuteIfBound(LocalUserNum, false, FExternalAuthToken());
+		return;
+	}
+	IOnlineIdentityPtr PlatformIdentity = PlatformOSS->GetIdentityInterface();
+	if (!PlatformIdentity.IsValid())
+	{
+		UE_LOG_ONLINE(Error, TEXT("ConnectLoginNoEAS(%d) failed due to no platform OSS identity interface"), LocalUserNum);
+		Delegate.ExecuteIfBound(LocalUserNum, false, FExternalAuthToken());
+		return;
+	}
+	// Request the auth token from the platform
+	PlatformIdentity->GetLinkedAccountAuthToken(LocalUserNum, Delegate);
+}
+
+typedef TEOSCallback<EOS_Auth_OnLoginCallback, EOS_Auth_LoginCallbackInfo> FLoginCallback;
+typedef TEOSCallback<EOS_Connect_OnLoginCallback, EOS_Connect_LoginCallbackInfo> FConnectLoginCallback;
+typedef TEOSCallback<EOS_Auth_OnDeletePersistentAuthCallback, EOS_Auth_DeletePersistentAuthCallbackInfo> FDeletePersistentAuthCallback;
+
+// Chose arbitrarily since the SDK doesn't define it
+#define EOS_MAX_TOKEN_SIZE 4096
+
+struct FAuthCredentials :
+	public EOS_Auth_Credentials
+{
+	FAuthCredentials() :
+		EOS_Auth_Credentials()
+	{
+		ApiVersion = EOS_AUTH_CREDENTIALS_API_LATEST;
+		Id = IdAnsi;
+		Token = TokenAnsi;
+
+		FMemory::Memset(IdAnsi, 0, sizeof(IdAnsi));
+		FMemory::Memset(TokenAnsi, 0, sizeof(TokenAnsi));
+	}
+
+	FAuthCredentials(const FAuthCredentials& Other)
+	{
+		ApiVersion = Other.ApiVersion;
+		Id = IdAnsi;
+		Token = TokenAnsi;
+		Type = Other.Type;
+		SystemAuthCredentialsOptions = Other.SystemAuthCredentialsOptions;
+		ExternalType = Other.ExternalType;
+
+		FCStringAnsi::Strncpy(IdAnsi, Other.IdAnsi, EOS_OSS_STRING_BUFFER_LENGTH);
+		FCStringAnsi::Strncpy(TokenAnsi, Other.TokenAnsi, EOS_MAX_TOKEN_SIZE);
+	}
+
+	FAuthCredentials& operator=(FAuthCredentials& Other)
+	{
+		ApiVersion = Other.ApiVersion;
+		Type = Other.Type;
+		SystemAuthCredentialsOptions = Other.SystemAuthCredentialsOptions;
+		ExternalType = Other.ExternalType;
+
+		FCStringAnsi::Strncpy(IdAnsi, Other.IdAnsi, EOS_OSS_STRING_BUFFER_LENGTH);
+		FCStringAnsi::Strncpy(TokenAnsi, Other.TokenAnsi, EOS_MAX_TOKEN_SIZE);
+
+		return *this;
+	}
+
+	FAuthCredentials(EOS_EExternalCredentialType InExternalType, const FExternalAuthToken& AuthToken) :
+		EOS_Auth_Credentials()
+	{
+		if (AuthToken.HasTokenData())
+		{
+			Init(InExternalType, AuthToken.TokenData);
+		}
+		else if (AuthToken.HasTokenString())
+		{
+			Init(InExternalType, AuthToken.TokenString);
+		}
+		else
+		{
+			UE_LOG_ONLINE(Error, TEXT("FAuthCredentials object cannot be constructed with invalid FExternalAuthToken parameter"));
+		}
+	}
+
+	void Init(EOS_EExternalCredentialType InExternalType, const FString& InTokenString)
+	{
+		ApiVersion = EOS_AUTH_CREDENTIALS_API_LATEST;
+		Type = EOS_ELoginCredentialType::EOS_LCT_ExternalAuth;
+		ExternalType = InExternalType;
+		Id = IdAnsi;
+		Token = TokenAnsi;
+
+		FCStringAnsi::Strncpy(TokenAnsi, TCHAR_TO_UTF8(*InTokenString), InTokenString.Len()+1);
+	}
+
+	void Init(EOS_EExternalCredentialType InExternalType, const TArray<uint8>& InToken)
+	{
+		ApiVersion = EOS_AUTH_CREDENTIALS_API_LATEST;
+		Type = EOS_ELoginCredentialType::EOS_LCT_ExternalAuth;
+		ExternalType = InExternalType;
+		Id = IdAnsi;
+		Token = TokenAnsi;
+
+		uint32_t InOutBufferLength = EOS_OSS_STRING_BUFFER_LENGTH;
+		EOS_ByteArray_ToString(InToken.GetData(), InToken.Num(), TokenAnsi, &InOutBufferLength);
+	}
+
+	char IdAnsi[EOS_OSS_STRING_BUFFER_LENGTH];
+	char TokenAnsi[EOS_MAX_TOKEN_SIZE];
+};
+
+bool FUserManagerEOS::Login(int32 LocalUserNum, const FOnlineAccountCredentials& AccountCredentials)
+{
+	LocalUserNumToLastLoginCredentials.Emplace(LocalUserNum, MakeShared<FOnlineAccountCredentials>(AccountCredentials));
+
+	FEOSSettings Settings = UEOSSettings::GetSettings();
+
+	// Are we configured to run at all?
+	if (!EOSSubsystem->bIsDefaultOSS && !EOSSubsystem->bIsPlatformOSS && !Settings.bUseEAS && !Settings.bUseEOSConnect)
+	{
+		UE_LOG_ONLINE(Warning, TEXT("Neither EAS nor EOS are configured to be used. Failed to login in user (%d)"), LocalUserNum);
+		TriggerOnLoginCompleteDelegates(LocalUserNum, false, *FUniqueNetIdEOS::EmptyId(), FString(TEXT("Not configured")));
+		return true;
+	}
+
+	// See if we are configured to just use EOS and not EAS
+	if (!EOSSubsystem->bIsDefaultOSS && !EOSSubsystem->bIsPlatformOSS && !Settings.bUseEAS && Settings.bUseEOSConnect)
+	{
+		// Call the EOS + Platform login path
+		return ConnectLoginNoEAS(LocalUserNum);
+	}
+
+	// We don't support offline logged in, so they are either logged in or not
+	if (GetLoginStatus(LocalUserNum) == ELoginStatus::LoggedIn)
+	{
+		UE_LOG_ONLINE(Warning, TEXT("User (%d) already logged in."), LocalUserNum);
+		TriggerOnLoginCompleteDelegates(LocalUserNum, false, *FUniqueNetIdEOS::EmptyId(), FString(TEXT("Already logged in")));
+		return true;
+	}
+
+	// See if we are logging in using platform credentials to link to EAS
+	if (!EOSSubsystem->bIsDefaultOSS && !EOSSubsystem->bIsPlatformOSS && Settings.bUseEAS)
+	{
+		LoginViaExternalAuth(LocalUserNum);
+		return true;
+	}
+
+	EOS_Auth_LoginOptions LoginOptions = { };
+	LoginOptions.ApiVersion = EOS_AUTH_LOGIN_API_LATEST;
+	LoginOptions.ScopeFlags = EOS_EAuthScopeFlags::EOS_AS_BasicProfile | EOS_EAuthScopeFlags::EOS_AS_FriendsList | EOS_EAuthScopeFlags::EOS_AS_Presence;
+
+	FPlatformEOSHelpersPtr EOSHelpers = EOSSubsystem->GetEOSHelpers();
+
+	FAuthCredentials Credentials;
+	LoginOptions.Credentials = &Credentials;
+	EOSHelpers->PlatformAuthCredentials(Credentials);
+
+	bool bIsPersistentLogin = false;
+
+	if (AccountCredentials.Type == TEXT("exchangecode"))
+	{
+		// This is how the Epic launcher will pass credentials to you
+		FCStringAnsi::Strncpy(Credentials.TokenAnsi, TCHAR_TO_UTF8(*AccountCredentials.Token), EOS_MAX_TOKEN_SIZE);
+		Credentials.Type = EOS_ELoginCredentialType::EOS_LCT_ExchangeCode;
+	}
+	else if (AccountCredentials.Type == TEXT("developer"))
+	{
+		// This is auth via the EOS auth tool
+		Credentials.Type = EOS_ELoginCredentialType::EOS_LCT_Developer;
+		FCStringAnsi::Strncpy(Credentials.IdAnsi, TCHAR_TO_UTF8(*AccountCredentials.Id), EOS_OSS_STRING_BUFFER_LENGTH);
+		FCStringAnsi::Strncpy(Credentials.TokenAnsi, TCHAR_TO_UTF8(*AccountCredentials.Token), EOS_MAX_TOKEN_SIZE);
+	}
+	else if (AccountCredentials.Type == TEXT("accountportal"))
+	{
+		// This is auth via the EOS Account Portal
+		Credentials.Type = EOS_ELoginCredentialType::EOS_LCT_AccountPortal;
+	}
+	else if (AccountCredentials.Type == TEXT("persistentauth"))
+	{
+		// Use locally stored token managed by EOSSDK keyring to attempt login.
+		Credentials.Type = EOS_ELoginCredentialType::EOS_LCT_PersistentAuth;
+
+		// Id and Token must be null when using EOS_ELoginCredentialType::EOS_LCT_PersistentAuth
+		Credentials.Id = nullptr;
+		Credentials.Token = nullptr;
+
+		// Store selection of persistent auth.
+		// The persistent auth token is handled by the EOSSDK. On a login failure the persistent token may need to be deleted if it is invalid.
+		bIsPersistentLogin = true;
+	}
+	else
+	{
+		UE_LOG_ONLINE(Warning, TEXT("Unable to Login() user (%d) due to missing auth parameters"), LocalUserNum);
+		TriggerOnLoginCompleteDelegates(LocalUserNum, false, *FUniqueNetIdEOS::EmptyId(), FString(TEXT("Missing auth parameters")));
+		return false;
+	}
+
+	FLoginCallback* CallbackObj = new FLoginCallback();
+	CallbackObj->CallbackLambda = [this, LocalUserNum, bIsPersistentLogin](const EOS_Auth_LoginCallbackInfo* Data)
+	{
+		if (Data->ResultCode == EOS_EResult::EOS_Success)
+		{
+			// Continue the login process by getting the product user id for EAS only
+			ConnectLoginEAS(LocalUserNum, Data->LocalUserId);
+		}
+		else
+		{
+			auto TriggerLoginFailure = [this, LocalUserNum, LoginResultCode = Data->ResultCode]()
+			{
+				FString ErrorString = FString::Printf(TEXT("Login(%d) failed with EOS result code (%s)"), LocalUserNum, ANSI_TO_TCHAR(EOS_EResult_ToString(LoginResultCode)));
+				UE_LOG_ONLINE(Warning, TEXT("%s"), *ErrorString);
+				TriggerOnLoginCompleteDelegates(LocalUserNum, false, *FUniqueNetIdEOS::EmptyId(), ErrorString);
+			};
+
+			const bool bShouldRemoveCachedToken =
+				Data->ResultCode == EOS_EResult::EOS_InvalidAuth ||
+				Data->ResultCode == EOS_EResult::EOS_AccessDenied ||
+				Data->ResultCode == EOS_EResult::EOS_Auth_InvalidToken;
+
+			// Check for invalid persistent login credentials.
+			if (bIsPersistentLogin && bShouldRemoveCachedToken)
+			{
+				FDeletePersistentAuthCallback* DeleteAuthCallbackObj = new FDeletePersistentAuthCallback();
+				DeleteAuthCallbackObj->CallbackLambda = [this, LocalUserNum, TriggerLoginFailure](const EOS_Auth_DeletePersistentAuthCallbackInfo* Data)
+				{
+					// Deleting the auth token is best effort.
+					TriggerLoginFailure();
+				};
+
+				EOS_Auth_DeletePersistentAuthOptions DeletePersistentAuthOptions;
+				DeletePersistentAuthOptions.ApiVersion = EOS_AUTH_DELETEPERSISTENTAUTH_API_LATEST;
+				DeletePersistentAuthOptions.RefreshToken = nullptr;
+				EOS_Auth_DeletePersistentAuth(EOSSubsystem->AuthHandle, &DeletePersistentAuthOptions, (void*)DeleteAuthCallbackObj, DeleteAuthCallbackObj->GetCallbackPtr());
+			}
+			else
+			{
+				TriggerLoginFailure();
+			}
+		}
+	};
+	// Perform the auth call
+	EOS_Auth_Login(EOSSubsystem->AuthHandle, &LoginOptions, (void*)CallbackObj, CallbackObj->GetCallbackPtr());
+	return true;
+}
+
+void FUserManagerEOS::LoginViaExternalAuth(int32 LocalUserNum)
+{
+	GetPlatformAuthToken(LocalUserNum,
+		FOnGetLinkedAccountAuthTokenCompleteDelegate::CreateLambda([this](int32 LocalUserNum, bool bWasSuccessful, const FExternalAuthToken& AuthToken)
+		{
+			if (!bWasSuccessful || !AuthToken.IsValid())
+			{
+				UE_LOG_ONLINE(Warning, TEXT("Unable to Login() user (%d) due to an empty platform auth token"), LocalUserNum);
+				TriggerOnLoginCompleteDelegates(LocalUserNum, false, *FUniqueNetIdEOS::EmptyId(), FString(TEXT("Missing platform auth token")));
+				return;
+			}
+
+			EOS_Auth_LoginOptions LoginOptions = { };
+			LoginOptions.ApiVersion = EOS_AUTH_LOGIN_API_LATEST;
+			LoginOptions.ScopeFlags = EOS_EAuthScopeFlags::EOS_AS_BasicProfile | EOS_EAuthScopeFlags::EOS_AS_FriendsList | EOS_EAuthScopeFlags::EOS_AS_Presence;
+
+			check(LocalUserNumToLastLoginCredentials.Contains(LocalUserNum));
+			FAuthCredentials Credentials(ToEOS_EExternalCredentialType(GetPlatformOSS()->GetSubsystemName(), *LocalUserNumToLastLoginCredentials[LocalUserNum]), AuthToken);
+			LoginOptions.Credentials = &Credentials;
+
+			FLoginCallback* CallbackObj = new FLoginCallback();
+			CallbackObj->CallbackLambda = [this, LocalUserNum](const EOS_Auth_LoginCallbackInfo* Data)
+			{
+				if (Data->ResultCode == EOS_EResult::EOS_Success)
+				{
+					ConnectLoginEAS(LocalUserNum, Data->LocalUserId);
+				}
+				else if (Data->ResultCode == EOS_EResult::EOS_InvalidUser)
+				{
+					// Link the account
+					LinkEAS(LocalUserNum, Data->ContinuanceToken);
+				}
+				else
+				{
+					FString ErrorString = FString::Printf(TEXT("Login(%d) failed with EOS result code (%s)"), LocalUserNum, ANSI_TO_TCHAR(EOS_EResult_ToString(Data->ResultCode)));
+					UE_LOG_ONLINE(Warning, TEXT("%s"), *ErrorString);
+					TriggerOnLoginCompleteDelegates(LocalUserNum, false, *FUniqueNetIdEOS::EmptyId(), ErrorString);
+				}
+			};
+			// Perform the auth call
+			EOS_Auth_Login(EOSSubsystem->AuthHandle, &LoginOptions, (void*)CallbackObj, CallbackObj->GetCallbackPtr());
+		}));
+}
+
+struct FLinkAccountOptions :
+	public EOS_Auth_LinkAccountOptions
+{
+	FLinkAccountOptions(EOS_ContinuanceToken Token)
+		: EOS_Auth_LinkAccountOptions()
+	{
+		ApiVersion = EOS_AUTH_LINKACCOUNT_API_LATEST;
+		ContinuanceToken = Token;
+	}
+};
+
+typedef TEOSCallback<EOS_Auth_OnLinkAccountCallback, EOS_Auth_LinkAccountCallbackInfo> FLinkAccountCallback;
+
+void FUserManagerEOS::LinkEAS(int32 LocalUserNum, EOS_ContinuanceToken Token)
+{
+	FLinkAccountOptions Options(Token);
+	FLinkAccountCallback* CallbackObj = new FLinkAccountCallback();
+	CallbackObj->CallbackLambda = [this, LocalUserNum](const EOS_Auth_LinkAccountCallbackInfo* Data)
+	{
+		if (Data->ResultCode == EOS_EResult::EOS_Success)
+		{
+			// Continue the login process by getting the product user id
+			ConnectLoginEAS(LocalUserNum, Data->LocalUserId);
+		}
+		else
+		{
+			FString ErrorString = FString::Printf(TEXT("Login(%d) failed with EOS result code (%s)"), LocalUserNum, ANSI_TO_TCHAR(EOS_EResult_ToString(Data->ResultCode)));
+			UE_LOG_ONLINE(Warning, TEXT("%s"), *ErrorString);
+			TriggerOnLoginCompleteDelegates(LocalUserNum, false, *FUniqueNetIdEOS::EmptyId(), ErrorString);
+		}
+	};
+	EOS_Auth_LinkAccount(EOSSubsystem->AuthHandle, &Options, CallbackObj, CallbackObj->GetCallbackPtr());
+}
+
+struct FConnectCredentials :
+	public EOS_Connect_Credentials
+{
+	FConnectCredentials(EOS_EExternalCredentialType InType, const FExternalAuthToken& AuthToken) :
+		EOS_Connect_Credentials()
+	{
+		if (AuthToken.HasTokenData())
+		{
+			Init(InType, AuthToken.TokenData);
+		}
+		else if (AuthToken.HasTokenString())
+		{
+			Init(InType, AuthToken.TokenString);
+		}
+		else
+		{
+			UE_LOG_ONLINE(Error, TEXT("FConnectCredentials object cannot be constructed with invalid FExternalAuthToken parameter"));
+		}
+	}
+
+	void Init(EOS_EExternalCredentialType InType, const FString& InTokenString)
+	{
+		ApiVersion = EOS_CONNECT_CREDENTIALS_API_LATEST;
+		Token = TokenAnsi;
+		Type = InType;
+
+		FCStringAnsi::Strncpy(TokenAnsi, TCHAR_TO_UTF8(*InTokenString), InTokenString.Len() + 1);
+	}
+
+	void Init(EOS_EExternalCredentialType InType, const TArray<uint8>& InToken)
+	{
+		ApiVersion = EOS_CONNECT_CREDENTIALS_API_LATEST;
+		Token = TokenAnsi;
+		Type = InType;
+
+		uint32_t InOutBufferLength = EOS_MAX_TOKEN_SIZE;
+		EOS_ByteArray_ToString(InToken.GetData(), InToken.Num(), TokenAnsi, &InOutBufferLength);
+	}
+
+	char TokenAnsi[EOS_MAX_TOKEN_SIZE];
+};
+
+bool FUserManagerEOS::ConnectLoginNoEAS(int32 LocalUserNum)
+{
+	GetPlatformAuthToken(LocalUserNum,
+		FOnGetLinkedAccountAuthTokenCompleteDelegate::CreateLambda([this](int32 LocalUserNum, bool bWasSuccessful, const FExternalAuthToken& AuthToken)
+		{
+			if (!bWasSuccessful || !AuthToken.IsValid())
+			{
+				UE_LOG_ONLINE(Error, TEXT("ConnectLoginNoEAS(%d) failed due to the platform OSS giving an empty auth token"), LocalUserNum);
+				return;
+			}
+
+			// Now login into our EOS account
+
+			check(LocalUserNumToLastLoginCredentials.Contains(LocalUserNum));
+			FConnectCredentials Credentials(ToEOS_EExternalCredentialType(GetPlatformOSS()->GetSubsystemName(), *LocalUserNumToLastLoginCredentials[LocalUserNum]), AuthToken);
+			EOS_Connect_LoginOptions Options = { };
+			Options.ApiVersion = EOS_CONNECT_LOGIN_API_LATEST;
+			Options.Credentials = &Credentials;
+
+			FConnectLoginCallback* CallbackObj = new FConnectLoginCallback();
+			CallbackObj->CallbackLambda = [this, LocalUserNum](const EOS_Connect_LoginCallbackInfo* Data)
+			{
+				if (Data->ResultCode == EOS_EResult::EOS_Success)
+				{
+					// We have an account mapping to the platform account, skip to final login
+					FullLoginCallback(LocalUserNum, nullptr, Data->LocalUserId);
+				}
+				else if (Data->ResultCode == EOS_EResult::EOS_InvalidUser)
+				{
+					// We need to create the platform account mapping for this user using the continuation token
+					CreateConnectedLogin(LocalUserNum, nullptr, Data->ContinuanceToken);
+				}
+				else
+				{
+					UE_LOG_ONLINE(Error, TEXT("ConnectLoginNoEAS(%d) failed with EOS result code (%s)"), LocalUserNum, ANSI_TO_TCHAR(EOS_EResult_ToString(Data->ResultCode)));
+				}
+			};
+			EOS_Connect_Login(EOSSubsystem->ConnectHandle, &Options, CallbackObj, CallbackObj->GetCallbackPtr());
+		}));
+
+	return true;
+}
+
+bool FUserManagerEOS::ConnectLoginEAS(int32 LocalUserNum, EOS_EpicAccountId AccountId)
+{
+	EOS_Auth_Token* AuthToken = nullptr;
+	EOS_Auth_CopyUserAuthTokenOptions CopyOptions = { };
+	CopyOptions.ApiVersion = EOS_AUTH_COPYUSERAUTHTOKEN_API_LATEST;
+
+	EOS_EResult CopyResult = EOS_Auth_CopyUserAuthToken(EOSSubsystem->AuthHandle, &CopyOptions, AccountId, &AuthToken);
+	if (CopyResult == EOS_EResult::EOS_Success)
+	{
+		EOS_Connect_Credentials Credentials = { };
+		Credentials.ApiVersion = EOS_CONNECT_CREDENTIALS_API_LATEST;
+		Credentials.Type = EOS_EExternalCredentialType::EOS_ECT_EPIC;
+		Credentials.Token = AuthToken->AccessToken;
+
+		EOS_Connect_LoginOptions Options = { };
+		Options.ApiVersion = EOS_CONNECT_LOGIN_API_LATEST;
+		Options.Credentials = &Credentials;
+
+		FConnectLoginCallback* CallbackObj = new FConnectLoginCallback();
+		CallbackObj->CallbackLambda = [LocalUserNum, AccountId, this](const EOS_Connect_LoginCallbackInfo* Data)
+		{
+			if (Data->ResultCode == EOS_EResult::EOS_Success)
+			{
+				// We have an account mapping, skip to final login
+				FullLoginCallback(LocalUserNum, AccountId, Data->LocalUserId);
+			}
+			else if (Data->ResultCode == EOS_EResult::EOS_InvalidUser)
+			{
+				// We need to create the mapping for this user using the continuation token
+				CreateConnectedLogin(LocalUserNum, AccountId, Data->ContinuanceToken);
+			}
+			else
+			{
+				UE_LOG_ONLINE(Error, TEXT("ConnectLogin(%d) failed with EOS result code (%s)"), LocalUserNum, ANSI_TO_TCHAR(EOS_EResult_ToString(Data->ResultCode)));
+				Logout(LocalUserNum);
+			}
+		};
+		EOS_Connect_Login(EOSSubsystem->ConnectHandle, &Options, CallbackObj, CallbackObj->GetCallbackPtr());
+
+		EOS_Auth_Token_Release(AuthToken);
+	}
+	else
+	{
+		UE_LOG_ONLINE(Error, TEXT("ConnectLogin(%d) failed with EOS result code (%s)"), LocalUserNum, ANSI_TO_TCHAR(EOS_EResult_ToString(CopyResult)));
+		Logout(LocalUserNum);
+	}
+	return true;
+}
+
+void FUserManagerEOS::RefreshConnectLogin(int32 LocalUserNum)
+{
+	if (!UserNumToAccountIdMap.Contains(LocalUserNum))
+	{
+		UE_LOG_ONLINE(Error, TEXT("Can't refresh ConnectLogin(%d) since (%d) is not logged in"), LocalUserNum, LocalUserNum);
+		return;
+	}
+
+	const FEOSSettings Settings = UEOSSettings::GetSettings();
+	if (Settings.bUseEAS)
+	{
+		EOS_EpicAccountId AccountId = UserNumToAccountIdMap[LocalUserNum];
+		EOS_Auth_Token* AuthToken = nullptr;
+		EOS_Auth_CopyUserAuthTokenOptions CopyOptions = { };
+		CopyOptions.ApiVersion = EOS_AUTH_COPYUSERAUTHTOKEN_API_LATEST;
+
+		EOS_EResult CopyResult = EOS_Auth_CopyUserAuthToken(EOSSubsystem->AuthHandle, &CopyOptions, AccountId, &AuthToken);
+		if (CopyResult == EOS_EResult::EOS_Success)
+		{
+			EOS_Connect_Credentials Credentials = { };
+			Credentials.ApiVersion = EOS_CONNECT_CREDENTIALS_API_LATEST;
+			Credentials.Type = EOS_EExternalCredentialType::EOS_ECT_EPIC;
+			Credentials.Token = AuthToken->AccessToken;
+
+			EOS_Connect_LoginOptions Options = { };
+			Options.ApiVersion = EOS_CONNECT_LOGIN_API_LATEST;
+			Options.Credentials = &Credentials;
+
+			FConnectLoginCallback* CallbackObj = new FConnectLoginCallback();
+			CallbackObj->CallbackLambda = [LocalUserNum, AccountId, this](const EOS_Connect_LoginCallbackInfo* Data)
+			{
+				if (Data->ResultCode != EOS_EResult::EOS_Success)
+				{
+					UE_LOG_ONLINE(Error, TEXT("Failed to refresh ConnectLogin(%d) failed with EOS result code (%s)"), LocalUserNum, ANSI_TO_TCHAR(EOS_EResult_ToString(Data->ResultCode)));
+					Logout(LocalUserNum);
+				}
+			};
+			EOS_Connect_Login(EOSSubsystem->ConnectHandle, &Options, CallbackObj, CallbackObj->GetCallbackPtr());
+
+			EOS_Auth_Token_Release(AuthToken);
+		}
+		else
+		{
+			UE_LOG_ONLINE(Error, TEXT("Failed to refresh ConnectLogin(%d) failed with EOS result code (%s)"), LocalUserNum, ANSI_TO_TCHAR(EOS_EResult_ToString(CopyResult)));
+			Logout(LocalUserNum);
+		}
+	}
+	else
+	{
+		// Not using EAS so grab the platform auth token
+		GetPlatformAuthToken(LocalUserNum,
+			FOnGetLinkedAccountAuthTokenCompleteDelegate::CreateLambda([this](int32 LocalUserNum, bool bWasSuccessful, const FExternalAuthToken& AuthToken)
+			{
+				if (!bWasSuccessful || !AuthToken.HasTokenData())
+				{
+					UE_LOG_ONLINE(Error, TEXT("ConnectLoginNoEAS(%d) failed due to the platform OSS giving an empty auth token"), LocalUserNum);
+					Logout(LocalUserNum);
+					return;
+				}
+
+				// Now login into our EOS account
+				check(LocalUserNumToLastLoginCredentials.Contains(LocalUserNum));
+				const FOnlineAccountCredentials& Creds = *LocalUserNumToLastLoginCredentials[LocalUserNum];
+				EOS_EExternalCredentialType CredType = ToEOS_EExternalCredentialType(GetPlatformOSS()->GetSubsystemName(), Creds);
+				FConnectCredentials Credentials(CredType, AuthToken);
+				EOS_Connect_LoginOptions Options = { };
+				Options.ApiVersion = EOS_CONNECT_LOGIN_API_LATEST;
+				Options.Credentials = &Credentials;
+
+				FConnectLoginCallback* CallbackObj = new FConnectLoginCallback();
+				CallbackObj->CallbackLambda = [this, LocalUserNum](const EOS_Connect_LoginCallbackInfo* Data)
+				{
+					if (Data->ResultCode != EOS_EResult::EOS_Success)
+					{
+						UE_LOG_ONLINE(Error, TEXT("Failed to refresh ConnectLogin(%d) failed with EOS result code (%s)"), LocalUserNum, ANSI_TO_TCHAR(EOS_EResult_ToString(Data->ResultCode)));
+						Logout(LocalUserNum);
+					}
+				};
+				EOS_Connect_Login(EOSSubsystem->ConnectHandle, &Options, CallbackObj, CallbackObj->GetCallbackPtr());
+			}));
+	}
+}
+
+typedef TEOSCallback<EOS_Connect_OnCreateUserCallback, EOS_Connect_CreateUserCallbackInfo> FCreateUserCallback;
+
+void FUserManagerEOS::CreateConnectedLogin(int32 LocalUserNum, EOS_EpicAccountId AccountId, EOS_ContinuanceToken Token)
+{
+	EOS_Connect_CreateUserOptions Options = { };
+	Options.ApiVersion = EOS_CONNECT_CREATEUSER_API_LATEST;
+	Options.ContinuanceToken = Token;
+
+	FCreateUserCallback* CallbackObj = new FCreateUserCallback();
+	CallbackObj->CallbackLambda = [LocalUserNum, AccountId, this](const EOS_Connect_CreateUserCallbackInfo* Data)
+	{
+		if (Data->ResultCode == EOS_EResult::EOS_Success)
+		{
+			FullLoginCallback(LocalUserNum, AccountId, Data->LocalUserId);
+		}
+		else
+		{
+// @todo joeg - logout?
+			FString ErrorString = FString::Printf(TEXT("Login(%d) failed with EOS result code (%s)"), LocalUserNum, ANSI_TO_TCHAR(EOS_EResult_ToString(Data->ResultCode)));
+			TriggerOnLoginCompleteDelegates(LocalUserNum, false, *FUniqueNetIdEOS::EmptyId(), ErrorString);
+		}
+	};
+	EOS_Connect_CreateUser(EOSSubsystem->ConnectHandle, &Options, CallbackObj, CallbackObj->GetCallbackPtr());
+}
+
+typedef TEOSGlobalCallback<EOS_Connect_OnAuthExpirationCallback, EOS_Connect_AuthExpirationCallbackInfo> FRefreshAuthCallback;
+typedef TEOSGlobalCallback<EOS_Presence_OnPresenceChangedCallback, EOS_Presence_PresenceChangedCallbackInfo> FPresenceChangedCallback;
+typedef TEOSGlobalCallback<EOS_Friends_OnFriendsUpdateCallback, EOS_Friends_OnFriendsUpdateInfo> FFriendsStatusUpdateCallback;
+typedef TEOSGlobalCallback<EOS_Auth_OnLoginStatusChangedCallback, EOS_Auth_LoginStatusChangedCallbackInfo> FLoginStatusChangedCallback;
+
+void FUserManagerEOS::FullLoginCallback(int32 LocalUserNum, EOS_EpicAccountId AccountId, EOS_ProductUserId UserId)
+{
+	// Add our login status changed callback if not already set
+	if (LoginNotificationId == 0)
+	{
+		FLoginStatusChangedCallback* CallbackObj = new FLoginStatusChangedCallback();
+		LoginNotificationCallback = CallbackObj;
+		CallbackObj->CallbackLambda = [this](const EOS_Auth_LoginStatusChangedCallbackInfo* Data)
+		{
+			LoginStatusChanged(Data);
+		};
+
+		EOS_Auth_AddNotifyLoginStatusChangedOptions Options = { };
+		Options.ApiVersion = EOS_AUTH_ADDNOTIFYLOGINSTATUSCHANGED_API_LATEST;
+		LoginNotificationId = EOS_Auth_AddNotifyLoginStatusChanged(EOSSubsystem->AuthHandle, &Options, CallbackObj, CallbackObj->GetCallbackPtr());
+	}
+	// Register for friends updates if not set yet
+	if (FriendsNotificationId == 0)
+	{
+		FFriendsStatusUpdateCallback* CallbackObj = new FFriendsStatusUpdateCallback();
+		FriendsNotificationCallback = CallbackObj;
+		CallbackObj->CallbackLambda = [LocalUserNum, this](const EOS_Friends_OnFriendsUpdateInfo* Data)
+		{
+			FriendStatusChanged(Data);
+		};
+
+		EOS_Friends_AddNotifyFriendsUpdateOptions Options = { };
+		Options.ApiVersion = EOS_FRIENDS_ADDNOTIFYFRIENDSUPDATE_API_LATEST;
+		FriendsNotificationId = EOS_Friends_AddNotifyFriendsUpdate(EOSSubsystem->FriendsHandle, &Options, CallbackObj, CallbackObj->GetCallbackPtr());
+	}
+	// Register for presence updates if not set yet
+	if (PresenceNotificationId == 0)
+	{
+		FPresenceChangedCallback* CallbackObj = new FPresenceChangedCallback();
+		PresenceNotificationCallback = CallbackObj;
+		CallbackObj->CallbackLambda = [LocalUserNum, this](const EOS_Presence_PresenceChangedCallbackInfo* Data)
+		{
+			if (EpicAccountIdToOnlineUserMap.Contains(Data->PresenceUserId))
+			{
+				// Update the presence data to the most recent
+				UpdatePresence(Data->PresenceUserId);
+				return;
+			}
+		};
+
+		EOS_Presence_AddNotifyOnPresenceChangedOptions Options = { };
+		Options.ApiVersion = EOS_PRESENCE_ADDNOTIFYONPRESENCECHANGED_API_LATEST;
+		PresenceNotificationId = EOS_Presence_AddNotifyOnPresenceChanged(EOSSubsystem->PresenceHandle, &Options, CallbackObj, CallbackObj->GetCallbackPtr());
+	}
+	// Add auth refresh notification if not set for this user yet
+	if (!LocalUserNumToConnectLoginNotifcationMap.Contains(LocalUserNum))
+	{
+		FNotificationIdCallbackPair* NotificationPair = new FNotificationIdCallbackPair();
+		LocalUserNumToConnectLoginNotifcationMap.Emplace(LocalUserNum, NotificationPair);
+
+		FRefreshAuthCallback* CallbackObj = new FRefreshAuthCallback();
+		NotificationPair->Callback = CallbackObj;
+		CallbackObj->CallbackLambda = [LocalUserNum, this](const EOS_Connect_AuthExpirationCallbackInfo* Data)
+		{
+			RefreshConnectLogin(LocalUserNum);
+		};
+
+		EOS_Connect_AddNotifyAuthExpirationOptions Options = { };
+		Options.ApiVersion = EOS_CONNECT_ADDNOTIFYAUTHEXPIRATION_API_LATEST;
+		NotificationPair->NotificationId = EOS_Connect_AddNotifyAuthExpiration(EOSSubsystem->ConnectHandle, &Options, CallbackObj, CallbackObj->GetCallbackPtr());
+	}
+
+	AddLocalUser(LocalUserNum, AccountId, UserId);
+	FUniqueNetIdEOSPtr UserNetId = GetLocalUniqueNetIdEOS(LocalUserNum);
+	check(UserNetId.IsValid());
+
+	TriggerOnLoginCompleteDelegates(LocalUserNum, true, *UserNetId, FString());
+	TriggerOnLoginStatusChangedDelegates(LocalUserNum, ELoginStatus::NotLoggedIn, ELoginStatus::LoggedIn, *UserNetId);
+}
+
+typedef TEOSCallback<EOS_Auth_OnLogoutCallback, EOS_Auth_LogoutCallbackInfo> FLogoutCallback;
+
+bool FUserManagerEOS::Logout(int32 LocalUserNum)
+{
+	FUniqueNetIdEOSPtr UserId = GetLocalUniqueNetIdEOS(LocalUserNum);
+	if (!UserId.IsValid())
+	{
+		UE_LOG_ONLINE(Warning, TEXT("No logged in user found for LocalUserNum=%d."),
+			LocalUserNum);
+		TriggerOnLogoutCompleteDelegates(LocalUserNum, false);
+		return false;
+	}
+
+	FLogoutCallback* CallbackObj = new FLogoutCallback();
+	CallbackObj->CallbackLambda = [LocalUserNum, this](const EOS_Auth_LogoutCallbackInfo* Data)
+	{
+		FDeletePersistentAuthCallback* DeleteAuthCallbackObj = new FDeletePersistentAuthCallback();
+		DeleteAuthCallbackObj->CallbackLambda = [this, LocalUserNum, LogoutResultCode = Data->ResultCode](const EOS_Auth_DeletePersistentAuthCallbackInfo* Data)
+		{
+			if (LogoutResultCode == EOS_EResult::EOS_Success)
+			{
+				RemoveLocalUser(LocalUserNum);
+
+				TriggerOnLogoutCompleteDelegates(LocalUserNum, true);
+			}
+			else
+			{
+				TriggerOnLogoutCompleteDelegates(LocalUserNum, false);
+			}
+		};
+
+		EOS_Auth_DeletePersistentAuthOptions DeletePersistentAuthOptions;
+		DeletePersistentAuthOptions.ApiVersion = EOS_AUTH_DELETEPERSISTENTAUTH_API_LATEST;
+		DeletePersistentAuthOptions.RefreshToken = nullptr;
+		EOS_Auth_DeletePersistentAuth(EOSSubsystem->AuthHandle, &DeletePersistentAuthOptions, (void*)DeleteAuthCallbackObj, DeleteAuthCallbackObj->GetCallbackPtr());
+	};
+
+	EOS_Auth_LogoutOptions LogoutOptions = { };
+	LogoutOptions.ApiVersion = EOS_AUTH_LOGOUT_API_LATEST;
+	LogoutOptions.LocalUserId = StringToAccountIdMap[UserId->UniqueNetIdStr];
+
+	EOS_Auth_Logout(EOSSubsystem->AuthHandle, &LogoutOptions, CallbackObj, CallbackObj->GetCallbackPtr());
+
+	LocalUserNumToLastLoginCredentials.Remove(LocalUserNum);
+
+	return true;
+}
+
+bool FUserManagerEOS::AutoLogin(int32 LocalUserNum)
+{
+	FString LoginId;
+	FString Password;
+	FString AuthType;
+
+	FParse::Value(FCommandLine::Get(), TEXT("AUTH_LOGIN="), LoginId);
+	FParse::Value(FCommandLine::Get(), TEXT("AUTH_PASSWORD="), Password);
+	FParse::Value(FCommandLine::Get(), TEXT("AUTH_TYPE="), AuthType);
+
+	FEOSSettings Settings = UEOSSettings::GetSettings();
+
+	if (EOSSubsystem->bIsDefaultOSS && Settings.bUseEAS && (LoginId.IsEmpty() || Password.IsEmpty() || AuthType.IsEmpty()))
+	{
+		UE_LOG_ONLINE(Warning, TEXT("Unable to AutoLogin user (%d) due to missing auth command line args"), LocalUserNum);
+		return false;
+	}
+	FOnlineAccountCredentials Creds(AuthType, LoginId, Password);
+
+	LocalUserNumToLastLoginCredentials.Emplace(LocalUserNum, MakeShared<FOnlineAccountCredentials>(Creds));
+
+	return Login(LocalUserNum, Creds);
+}
+
+void FUserManagerEOS::AddLocalUser(int32 LocalUserNum, EOS_EpicAccountId EpicAccountId, EOS_ProductUserId UserId)
+{
+	// Set the default user to the first one that logs in
+	if (DefaultLocalUser == -1)
+	{
+		DefaultLocalUser = LocalUserNum;
+	}
+
+	const FString& NetId = MakeNetIdStringFromIds(EpicAccountId, UserId);
+	FUniqueNetIdEOSRef UserNetId = FUniqueNetIdEOS::Create(NetId);
+	FUserOnlineAccountEOSRef UserAccountRef(new FUserOnlineAccountEOS(UserNetId));
+
+	UserNumToNetIdMap.Emplace(LocalUserNum, UserNetId);
+	UserNumToAccountIdMap.Emplace(LocalUserNum, EpicAccountId);
+	AccountIdToUserNumMap.Emplace(EpicAccountId, LocalUserNum);
+	NetIdStringToOnlineUserMap.Emplace(*NetId, UserAccountRef);
+	StringToUserAccountMap.Emplace(NetId, UserAccountRef);
+	AccountIdToStringMap.Emplace(EpicAccountId, NetId);
+	ProductUserIdToStringMap.Emplace(UserId, *NetId);
+	StringToAccountIdMap.Emplace(NetId, EpicAccountId);
+	EpicAccountIdToAttributeAccessMap.Emplace(EpicAccountId, UserAccountRef);
+	UserNumToProductUserIdMap.Emplace(LocalUserNum, UserId);
+	ProductUserIdToUserNumMap.Emplace(UserId, LocalUserNum);
+	StringToProductUserIdMap.Emplace(NetId, UserId);
+
+	// Init player lists
+	FFriendsListEOSRef FriendsList = MakeShareable(new FFriendsListEOS(LocalUserNum, UserNetId));
+	LocalUserNumToFriendsListMap.Emplace(LocalUserNum, FriendsList);
+	NetIdStringToFriendsListMap.Emplace(NetId, FriendsList);
+	ReadFriendsList(LocalUserNum, FString());
+
+	FBlockedPlayersListEOSRef BlockedPlayersList = MakeShareable(new FBlockedPlayersListEOS(LocalUserNum, UserNetId));
+	LocalUserNumToBlockedPlayerListMap.Emplace(LocalUserNum, BlockedPlayersList);
+	NetIdStringToBlockedPlayerListMap.Emplace(NetId, BlockedPlayersList);
+	QueryBlockedPlayers(*UserNetId);
+
+	FRecentPlayersListEOSRef RecentPlayersList = MakeShareable(new FRecentPlayersListEOS(LocalUserNum, UserNetId));
+	LocalUserNumToRecentPlayerListMap.Emplace(LocalUserNum, RecentPlayersList);
+	NetIdStringToRecentPlayerListMap.Emplace(NetId, RecentPlayersList);
+
+	// Get auth token info
+	EOS_Auth_Token* AuthToken = nullptr;
+	EOS_Auth_CopyUserAuthTokenOptions Options = { };
+	Options.ApiVersion = EOS_AUTH_COPYUSERAUTHTOKEN_API_LATEST;
+
+	EOS_EResult CopyResult = EOS_Auth_CopyUserAuthToken(EOSSubsystem->AuthHandle, &Options, EpicAccountId, &AuthToken);
+	if (CopyResult == EOS_EResult::EOS_Success)
+	{
+		UserAccountRef->SetAuthAttribute(AUTH_ATTR_ID_TOKEN, AuthToken->AccessToken);
+		EOS_Auth_Token_Release(AuthToken);
+
+		UpdateUserInfo(UserAccountRef, EpicAccountId, EpicAccountId);
+	}
+}
+
+void FUserManagerEOS::UpdateUserInfo(IAttributeAccessInterfaceRef AttributeAccessRef, EOS_EpicAccountId LocalId, EOS_EpicAccountId AccountId)
+{
+	EOS_UserInfo_CopyUserInfoOptions Options = { };
+	Options.ApiVersion = EOS_USERINFO_COPYUSERINFO_API_LATEST;
+	Options.LocalUserId = LocalId;
+	Options.TargetUserId = AccountId;
+
+	EOS_UserInfo* UserInfo = nullptr;
+
+	EOS_EResult CopyResult = EOS_UserInfo_CopyUserInfo(EOSSubsystem->UserInfoHandle, &Options, &UserInfo);
+	if (CopyResult == EOS_EResult::EOS_Success)
+	{
+		AttributeAccessRef->SetInternalAttribute(USER_ATTR_DISPLAY_NAME, UTF8_TO_TCHAR(UserInfo->DisplayName));
+		AttributeAccessRef->SetInternalAttribute(USER_ATTR_COUNTRY, UTF8_TO_TCHAR(UserInfo->Country));
+		AttributeAccessRef->SetInternalAttribute(USER_ATTR_LANG, UTF8_TO_TCHAR(UserInfo->PreferredLanguage));
+		EOS_UserInfo_Release(UserInfo);
+	}
+}
+
+bool FUserManagerEOS::IsFriendQueryUserInfoOngoing(int32 LocalUserNum)
+{
+	// If we have an entry for this user and the corresponding array has any element, users are still being processed
+	if (IsFriendQueryUserInfoOngoingForLocalUserMap.Contains(LocalUserNum))
+	{
+		if(IsFriendQueryUserInfoOngoingForLocalUserMap[LocalUserNum].Num() > 0)
+		{
+			return true;
+		}
+	}
+	
+	if (IsPlayerQueryExternalMappingsOngoingForLocalUserMap.Contains(LocalUserNum))
+	{
+		if(IsPlayerQueryExternalMappingsOngoingForLocalUserMap[LocalUserNum].Num() > 0)
+		{
+			return true;
+		}
+	}
+
+	return false;
+}
+
+TSharedPtr<FUserOnlineAccount> FUserManagerEOS::GetUserAccount(const FUniqueNetId& UserId) const
+{
+	TSharedPtr<FUserOnlineAccount> Result;
+
+	const FUniqueNetIdEOS& EOSID = FUniqueNetIdEOS::Cast(UserId);
+	const FUserOnlineAccountEOSRef* FoundUserAccount = StringToUserAccountMap.Find(EOSID.UniqueNetIdStr);
+	if (FoundUserAccount != nullptr)
+	{
+		return *FoundUserAccount;
+	}
+
+	return nullptr;
+}
+
+TArray<TSharedPtr<FUserOnlineAccount>> FUserManagerEOS::GetAllUserAccounts() const
+{
+	TArray<TSharedPtr<FUserOnlineAccount>> Result;
+
+	for (TMap<FString, FUserOnlineAccountEOSRef>::TConstIterator It(StringToUserAccountMap); It; ++It)
+	{
+		Result.Add(It.Value());
+	}
+	return Result;
+}
+
+FUniqueNetIdPtr FUserManagerEOS::GetUniquePlayerId(int32 LocalUserNum) const
+{
+	return GetLocalUniqueNetIdEOS(LocalUserNum);
+}
+
+int32 FUserManagerEOS::GetLocalUserNumFromUniqueNetId(const FUniqueNetId& NetId) const
+{
+	const FUniqueNetIdEOS& EosId = FUniqueNetIdEOS::Cast(NetId);
+	if (StringToAccountIdMap.Contains(EosId.UniqueNetIdStr))
+	{
+		EOS_EpicAccountId AccountId = StringToAccountIdMap[EosId.UniqueNetIdStr];
+		if (AccountIdToUserNumMap.Contains(AccountId))
+		{
+			return AccountIdToUserNumMap[AccountId];
+		}
+	}
+	// Use the default user if we can't find the person that they want
+	return DefaultLocalUser;
+}
+
+bool FUserManagerEOS::IsLocalUser(const FUniqueNetId& NetId) const
+{
+	const FUniqueNetIdEOS& EosId = FUniqueNetIdEOS::Cast(NetId);
+	return StringToAccountIdMap.Contains(EosId.UniqueNetIdStr);
+}
+
+FUniqueNetIdEOSPtr FUserManagerEOS::GetLocalUniqueNetIdEOS(int32 LocalUserNum) const
+{
+	const FUniqueNetIdEOSPtr* FoundId = UserNumToNetIdMap.Find(LocalUserNum);
+	if (FoundId != nullptr)
+	{
+		return *FoundId;
+	}
+	return nullptr;
+}
+
+FUniqueNetIdEOSPtr FUserManagerEOS::GetLocalUniqueNetIdEOS(EOS_ProductUserId UserId) const
+{
+	if (ProductUserIdToUserNumMap.Contains(UserId))
+	{
+		return GetLocalUniqueNetIdEOS(ProductUserIdToUserNumMap[UserId]);
+	}
+	return nullptr;
+}
+
+FUniqueNetIdEOSPtr FUserManagerEOS::GetLocalUniqueNetIdEOS(EOS_EpicAccountId AccountId) const
+{
+	if (AccountIdToUserNumMap.Contains(AccountId))
+	{
+		return GetLocalUniqueNetIdEOS(AccountIdToUserNumMap[AccountId]);
+	}
+	return nullptr;
+}
+
+EOS_EpicAccountId FUserManagerEOS::GetLocalEpicAccountId(int32 LocalUserNum) const
+{
+	if (UserNumToAccountIdMap.Contains(LocalUserNum))
+	{
+		return UserNumToAccountIdMap[LocalUserNum];
+	}
+	return nullptr;
+}
+
+EOS_EpicAccountId FUserManagerEOS::GetLocalEpicAccountId() const
+{
+	return GetLocalEpicAccountId(DefaultLocalUser);
+}
+
+EOS_ProductUserId FUserManagerEOS::GetLocalProductUserId(int32 LocalUserNum) const
+{
+	if (UserNumToProductUserIdMap.Contains(LocalUserNum))
+	{
+		return UserNumToProductUserIdMap[LocalUserNum];
+	}
+	return nullptr;
+}
+
+EOS_ProductUserId FUserManagerEOS::GetLocalProductUserId() const
+{
+	return GetLocalProductUserId(DefaultLocalUser);
+}
+
+EOS_EpicAccountId FUserManagerEOS::GetLocalEpicAccountId(EOS_ProductUserId UserId) const
+{
+	if (ProductUserIdToUserNumMap.Contains(UserId))
+	{
+		return GetLocalEpicAccountId(ProductUserIdToUserNumMap[UserId]);
+	}
+	return nullptr;
+}
+
+EOS_ProductUserId FUserManagerEOS::GetLocalProductUserId(EOS_EpicAccountId AccountId) const
+{
+	if (AccountIdToUserNumMap.Contains(AccountId))
+	{
+		return GetLocalProductUserId(AccountIdToUserNumMap[AccountId]);
+	}
+	return nullptr;
+}
+
+EOS_EpicAccountId FUserManagerEOS::GetEpicAccountId(const FUniqueNetId& NetId) const
+{
+	const FUniqueNetIdEOS& EOSId = FUniqueNetIdEOS::Cast(NetId);
+
+	if (StringToAccountIdMap.Contains(EOSId.UniqueNetIdStr))
+	{
+		return StringToAccountIdMap[EOSId.UniqueNetIdStr];
+	}
+	return nullptr;
+}
+
+EOS_ProductUserId FUserManagerEOS::GetProductUserId(const FUniqueNetId& NetId) const
+{
+	const FUniqueNetIdEOS& EOSId = FUniqueNetIdEOS::Cast(NetId);
+
+	if (StringToProductUserIdMap.Contains(EOSId.UniqueNetIdStr))
+	{
+		return StringToProductUserIdMap[EOSId.UniqueNetIdStr];
+	}
+	return nullptr;
+}
+
+typedef TEOSCallback<EOS_Connect_OnQueryProductUserIdMappingsCallback, EOS_Connect_QueryProductUserIdMappingsCallbackInfo> FConnectQueryProductUserIdMappingsCallback;
+
+/**
+ * Uses the Connect API to retrieve the EOS_EpicAccountId for a given EOS_ProductUserId
+ *
+ * @param ProductUserId the product user id we want to query
+ * @Param OutEpicAccountId the epic account id we will assign if the query is successful
+ *
+ * @return true if the operation was successful, false otherwise
+ */
+bool FUserManagerEOS::GetEpicAccountIdFromProductUserId(const EOS_ProductUserId& ProductUserId, EOS_EpicAccountId& OutEpicAccountId) const
+{
+	bool bResult = false;
+
+	char EpicIdStr[EOS_CONNECT_EXTERNAL_ACCOUNT_ID_MAX_LENGTH+1];
+	int32 EpicIdStrSize = sizeof(EpicIdStr);
+
+	EOS_Connect_GetProductUserIdMappingOptions Options = { };
+	Options.ApiVersion = EOS_CONNECT_GETPRODUCTUSERIDMAPPING_API_LATEST;
+	Options.AccountIdType = EOS_EExternalAccountType::EOS_EAT_EPIC;
+	Options.LocalUserId = GetLocalProductUserId();
+	Options.TargetProductUserId = ProductUserId;
+
+	EOS_EResult Result = EOS_Connect_GetProductUserIdMapping(EOSSubsystem->ConnectHandle, &Options, EpicIdStr, &EpicIdStrSize);
+	if (Result == EOS_EResult::EOS_Success)
+	{
+		OutEpicAccountId = EOS_EpicAccountId_FromString(EpicIdStr);
+		bResult = true;
+	}
+	else
+	{
+		UE_LOG_ONLINE(Verbose, TEXT("[FUserManagerEOS::GetEpicAccountIdFromProductUserId] EOS_Connect_GetProductUserIdMapping not successful for ProductUserId (%s). Finished with EOS_EResult %s"), *LexToString(ProductUserId), ANSI_TO_TCHAR(EOS_EResult_ToString(Result)));
+	}
+
+	return bResult;
+}
+
+void FUserManagerEOS::GetEpicAccountIdAsync(const EOS_ProductUserId& ProductUserId, const GetEpicAccountIdAsyncCallback& Callback) const
+{
+	// We check first if the Product User Id has already been queried, which would allow us to retrieve its Epic Account Id directly
+	EOS_EpicAccountId AccountId;
+	if (GetEpicAccountIdFromProductUserId(ProductUserId, AccountId))
+	{
+		Callback(ProductUserId, AccountId);
+	}
+	else
+	{
+		// If it's the first time we want the Epic Account Id for this Product User Id, we have to query it first
+		TArray<EOS_ProductUserId> ProductUserIdList = { const_cast<EOS_ProductUserId>(ProductUserId) };
+
+		EOS_Connect_QueryProductUserIdMappingsOptions QueryProductUserIdMappingsOptions = {};
+		QueryProductUserIdMappingsOptions.ApiVersion = EOS_CONNECT_QUERYPRODUCTUSERIDMAPPINGS_API_LATEST;
+		QueryProductUserIdMappingsOptions.LocalUserId = EOSSubsystem->UserManager->GetLocalProductUserId(0);
+		QueryProductUserIdMappingsOptions.ProductUserIds = ProductUserIdList.GetData();
+		QueryProductUserIdMappingsOptions.ProductUserIdCount = 1;
+
+		FConnectQueryProductUserIdMappingsCallback* CallbackObj = new FConnectQueryProductUserIdMappingsCallback();
+		CallbackObj->CallbackLambda = [this, ProductUserId, Callback](const EOS_Connect_QueryProductUserIdMappingsCallbackInfo* Data)
+		{
+			EOS_EpicAccountId AccountId = nullptr;
+
+			if (Data->ResultCode == EOS_EResult::EOS_Success)
+			{
+				GetEpicAccountIdFromProductUserId(ProductUserId, AccountId);
+			}
+			else
+			{
+				UE_LOG_ONLINE(Verbose, TEXT("[FUserManagerEOS::GetEpicAccountIdAsync] EOS_Connect_QueryProductUserIdMappings not successful for ProductUserId (%s). Finished with EOS_EResult %s."), *LexToString(ProductUserId), ANSI_TO_TCHAR(EOS_EResult_ToString(Data->ResultCode)));
+			}
+
+			Callback(ProductUserId, AccountId);
+		};
+
+		EOS_Connect_QueryProductUserIdMappings(EOSSubsystem->ConnectHandle, &QueryProductUserIdMappingsOptions, CallbackObj, CallbackObj->GetCallbackPtr());
+	}
+}
+
+FOnlineUserPtr FUserManagerEOS::GetLocalOnlineUser(int32 LocalUserNum) const
+{
+	FOnlineUserPtr OnlineUser;
+	if (UserNumToNetIdMap.Contains(LocalUserNum))
+	{
+		const FUniqueNetIdEOSPtr NetId = UserNumToNetIdMap.FindRef(LocalUserNum);
+		if (NetIdStringToOnlineUserMap.Contains(*NetId->UniqueNetIdStr))
+		{
+			OnlineUser = NetIdStringToOnlineUserMap.FindRef(*NetId->UniqueNetIdStr);
+		}
+	}
+	return OnlineUser;
+}
+
+FOnlineUserPtr FUserManagerEOS::GetOnlineUser(EOS_ProductUserId UserId) const
+{
+	FOnlineUserPtr OnlineUser;
+	if (ProductUserIdToStringMap.Contains(UserId))
+	{
+		const FString& NetId = ProductUserIdToStringMap.FindRef(UserId);
+		if (NetIdStringToOnlineUserMap.Contains(*NetId))
+		{
+			OnlineUser = NetIdStringToOnlineUserMap.FindRef(*NetId);
+		}
+	}
+	return OnlineUser;
+}
+
+FOnlineUserPtr FUserManagerEOS::GetOnlineUser(EOS_EpicAccountId AccountId) const
+{
+	FOnlineUserPtr OnlineUser;
+	if (AccountIdToStringMap.Contains(AccountId))
+	{
+		const FString& NetId = AccountIdToStringMap.FindRef(AccountId);
+		if (NetIdStringToOnlineUserMap.Contains(*NetId))
+		{
+			OnlineUser = NetIdStringToOnlineUserMap.FindRef(*NetId);
+		}
+	}
+	return OnlineUser;
+}
+
+void FUserManagerEOS::RemoveLocalUser(int32 LocalUserNum)
+{
+	const FUniqueNetIdEOSPtr* FoundId = UserNumToNetIdMap.Find(LocalUserNum);
+	if (FoundId != nullptr)
+	{
+		EOSSubsystem->ReleaseVoiceChatUserInterface(**FoundId);
+		LocalUserNumToFriendsListMap.Remove(LocalUserNum);
+		const FString& NetId = (*FoundId)->UniqueNetIdStr;
+		EOS_EpicAccountId AccountId = StringToAccountIdMap[NetId];
+		AccountIdToStringMap.Remove(AccountId);
+		AccountIdToUserNumMap.Remove(AccountId);
+		NetIdStringToOnlineUserMap.Remove(NetId);
+		StringToAccountIdMap.Remove(NetId);
+		StringToUserAccountMap.Remove(NetId);
+		UserNumToNetIdMap.Remove(LocalUserNum);
+		UserNumToAccountIdMap.Remove(LocalUserNum);
+		EOS_ProductUserId UserId = UserNumToProductUserIdMap[LocalUserNum];
+		ProductUserIdToUserNumMap.Remove(UserId);
+		ProductUserIdToStringMap.Remove(UserId);
+		UserNumToProductUserIdMap.Remove(LocalUserNum);
+	}
+	// Reset this for the next user login
+	if (LocalUserNum == DefaultLocalUser)
+	{
+		DefaultLocalUser = -1;
+	}
+}
+
+FUniqueNetIdPtr FUserManagerEOS::CreateUniquePlayerId(uint8* Bytes, int32 Size)
+{
+	if (Bytes != nullptr && Size >= 32)
+	{
+		// In the case of crossplay the size might be larger, but we only know how to parse the 32
+// @todo joeg crossplay
+		return FUniqueNetIdEOS::Create(Bytes, 32);
+	}
+	return nullptr;
+}
+
+FUniqueNetIdPtr FUserManagerEOS::CreateUniquePlayerId(const FString& Str)
+{
+	return FUniqueNetIdEOS::Create(Str);
+}
+
+ELoginStatus::Type FUserManagerEOS::GetLoginStatus(int32 LocalUserNum) const
+{
+	FUniqueNetIdEOSPtr UserId = GetLocalUniqueNetIdEOS(LocalUserNum);
+	if (UserId.IsValid())
+	{
+		return GetLoginStatus(*UserId);
+	}
+	return ELoginStatus::NotLoggedIn;
+}
+
+ELoginStatus::Type FUserManagerEOS::GetLoginStatus(const FUniqueNetIdEOS& UserId) const
+{
+	if (!StringToAccountIdMap.Contains(UserId.UniqueNetIdStr))
+	{
+		return ELoginStatus::NotLoggedIn;
+	}
+
+	FEOSSettings Settings = UEOSSettings::GetSettings();
+	// If the user isn't using EAS, then only check for a product user id
+	if (!Settings.bUseEAS)
+	{
+		EOS_ProductUserId ProductUserId = StringToProductUserIdMap[UserId.UniqueNetIdStr];
+		if (ProductUserId != nullptr)
+		{
+			return ELoginStatus::LoggedIn;
+		}
+		return ELoginStatus::NotLoggedIn;
+	}
+
+	EOS_EpicAccountId AccountId = StringToAccountIdMap[UserId.UniqueNetIdStr];
+	if (AccountId == nullptr)
+	{
+		return ELoginStatus::NotLoggedIn;
+	}
+
+	EOS_ELoginStatus LoginStatus = EOS_Auth_GetLoginStatus(EOSSubsystem->AuthHandle, AccountId);
+	switch (LoginStatus)
+	{
+		case EOS_ELoginStatus::EOS_LS_LoggedIn:
+		{
+			return ELoginStatus::LoggedIn;
+		}
+		case EOS_ELoginStatus::EOS_LS_UsingLocalProfile:
+		{
+			return ELoginStatus::UsingLocalProfile;
+		}
+	}
+	return ELoginStatus::NotLoggedIn;
+}
+
+ELoginStatus::Type FUserManagerEOS::GetLoginStatus(const FUniqueNetId& UserId) const
+{
+	const FUniqueNetIdEOS& EosId = FUniqueNetIdEOS::Cast(UserId);
+	return GetLoginStatus(EosId);
+}
+
+FString FUserManagerEOS::GetPlayerNickname(int32 LocalUserNum) const
+{
+	FUniqueNetIdEOSPtr UserId = GetLocalUniqueNetIdEOS(LocalUserNum);
+	if (UserId.IsValid())
+	{
+		TSharedPtr<FUserOnlineAccount> UserAccount = GetUserAccount(*UserId);
+		if (UserAccount.IsValid())
+		{
+			return UserAccount->GetDisplayName();
+		}
+	}
+	return FString();
+}
+
+FString FUserManagerEOS::GetPlayerNickname(const FUniqueNetId& UserId) const
+{
+	TSharedPtr<FUserOnlineAccount> UserAccount = GetUserAccount(UserId);
+	if (UserAccount.IsValid())
+	{
+		return UserAccount->GetDisplayName();
+	}
+	return FString();
+}
+
+FString FUserManagerEOS::GetAuthToken(int32 LocalUserNum) const
+{
+	FUniqueNetIdPtr UserId = GetUniquePlayerId(LocalUserNum);
+	if (UserId.IsValid())
+	{
+		TSharedPtr<FUserOnlineAccount> UserAccount = GetUserAccount(*UserId);
+		if (UserAccount.IsValid())
+		{
+			return UserAccount->GetAccessToken();
+		}
+	}
+	return FString();
+}
+
+void FUserManagerEOS::RevokeAuthToken(const FUniqueNetId& LocalUserId, const FOnRevokeAuthTokenCompleteDelegate& Delegate)
+{
+	Delegate.ExecuteIfBound(LocalUserId, FOnlineError(EOnlineErrorResult::NotImplemented));
+}
+
+FPlatformUserId FUserManagerEOS::GetPlatformUserIdFromUniqueNetId(const FUniqueNetId& UniqueNetId) const
+{
+	return GetPlatformUserIdFromLocalUserNum(GetLocalUserNumFromUniqueNetId(UniqueNetId));
+}
+
+void FUserManagerEOS::GetUserPrivilege(const FUniqueNetId& UserId, EUserPrivileges::Type Privilege, const FOnGetUserPrivilegeCompleteDelegate& Delegate)
+{
+	Delegate.ExecuteIfBound(UserId, Privilege, (uint32)EPrivilegeResults::NoFailures);
+}
+
+FString FUserManagerEOS::GetAuthType() const
+{
+	return TEXT("epic");
+}
+
+// IOnlineExternalUI Interface
+
+bool FUserManagerEOS::ShowLoginUI(const int ControllerIndex, bool bShowOnlineOnly, bool bShowSkipButton, const FOnLoginUIClosedDelegate& Delegate)
+{
+	FPlatformEOSHelpersPtr EOSHelpers = EOSSubsystem->GetEOSHelpers();
+	EOSHelpers->PlatformTriggerLoginUI(EOSSubsystem, ControllerIndex, bShowOnlineOnly, bShowSkipButton, Delegate);
+
+	return true;
+}
+
+bool FUserManagerEOS::ShowAccountCreationUI(const int ControllerIndex, const FOnAccountCreationUIClosedDelegate& Delegate)
+{
+	UE_LOG_ONLINE_EXTERNALUI(Warning, TEXT("[FUserManagerEOS::ShowAccountCreationUI] This method is not implemented."));
+	
+	EOSSubsystem->ExecuteNextTick([this, ControllerIndex, Delegate]()
+		{
+			Delegate.ExecuteIfBound(ControllerIndex, FOnlineAccountCredentials(), FOnlineError(EOnlineErrorResult::NotImplemented));
+		});
+
+	return true;
+}
+
+typedef TEOSCallback<EOS_UI_OnShowFriendsCallback, EOS_UI_ShowFriendsCallbackInfo> FOnShowFriendsCallback;
+
+bool FUserManagerEOS::ShowFriendsUI(int32 LocalUserNum)
+{
+	EOS_UI_ShowFriendsOptions Options = {};
+	Options.ApiVersion = EOS_UI_SHOWFRIENDS_API_LATEST;
+	Options.LocalUserId = GetLocalEpicAccountId(LocalUserNum);
+
+	FOnShowFriendsCallback* CallbackObj = new FOnShowFriendsCallback();
+	CallbackObj->CallbackLambda = [this](const EOS_UI_ShowFriendsCallbackInfo* Data)
+	{
+		if (Data->ResultCode == EOS_EResult::EOS_Success)
+		{
+			UE_LOG_ONLINE_EXTERNALUI(VeryVerbose, TEXT("[FUserManagerEOS::ShowFriendsUI] EOS_UI_ShowFriends was successful."));
+		}
+		else
+		{
+			UE_LOG_ONLINE_EXTERNALUI(Warning, TEXT("[FUserManagerEOS::ShowFriendsUI] EOS_UI_ShowFriends was not successful. Finished with error %s"), ANSI_TO_TCHAR(EOS_EResult_ToString(Data->ResultCode)));
+		}
+	};
+
+	EOS_UI_ShowFriends(EOSSubsystem->UIHandle, &Options, CallbackObj, CallbackObj->GetCallbackPtr());
+
+	return true;
+}
+
+
+bool FUserManagerEOS::ShowInviteUI(int32 LocalUserNum, FName SessionName)
+{
+	UE_LOG_ONLINE_EXTERNALUI(Warning, TEXT("[FUserManagerEOS::ShowInviteUI] This method is not implemented."));
+
+	return false;
+}
+
+bool FUserManagerEOS::ShowAchievementsUI(int32 LocalUserNum)
+{
+	UE_LOG_ONLINE_EXTERNALUI(Warning, TEXT("[FUserManagerEOS::ShowAchievementsUI] This method is not implemented."));
+
+	return false;
+}
+
+bool FUserManagerEOS::ShowLeaderboardUI(const FString& LeaderboardName)
+{
+	UE_LOG_ONLINE_EXTERNALUI(Warning, TEXT("[FUserManagerEOS::ShowLeaderboardUI] This method is not implemented."));
+
+	return false;
+}
+
+bool FUserManagerEOS::ShowWebURL(const FString& Url, const FShowWebUrlParams& ShowParams, const FOnShowWebUrlClosedDelegate& Delegate)
+{
+	UE_LOG_ONLINE_EXTERNALUI(Warning, TEXT("[FUserManagerEOS::ShowWebURL] This method is not implemented."));
+
+	EOSSubsystem->ExecuteNextTick([this, Delegate]()
+		{
+			Delegate.ExecuteIfBound(FString());
+		});
+
+	return true;
+}
+
+bool FUserManagerEOS::CloseWebURL()
+{
+	UE_LOG_ONLINE_EXTERNALUI(Warning, TEXT("[FUserManagerEOS::CloseWebURL] This method is not implemented."));
+
+	return false;
+}
+
+bool FUserManagerEOS::ShowProfileUI(const FUniqueNetId& Requestor, const FUniqueNetId& Requestee, const FOnProfileUIClosedDelegate& Delegate)
+{
+	UE_LOG_ONLINE_EXTERNALUI(Warning, TEXT("[FUserManagerEOS::ShowProfileUI] This method is not implemented."));
+
+	EOSSubsystem->ExecuteNextTick([this, Delegate]()
+		{
+			Delegate.ExecuteIfBound();
+		});
+
+	return true;
+}
+
+bool FUserManagerEOS::ShowAccountUpgradeUI(const FUniqueNetId& UniqueId)
+{
+	UE_LOG_ONLINE_EXTERNALUI(Warning, TEXT("[FUserManagerEOS::ShowAccountUpgradeUI] This method is not implemented."));
+
+	return false;
+}
+
+bool FUserManagerEOS::ShowStoreUI(int32 LocalUserNum, const FShowStoreParams& ShowParams, const FOnShowStoreUIClosedDelegate& Delegate)
+{
+	UE_LOG_ONLINE_EXTERNALUI(Warning, TEXT("[FUserManagerEOS::ShowStoreUI] This method is not implemented."));
+
+	EOSSubsystem->ExecuteNextTick([this, Delegate]()
+		{
+			Delegate.ExecuteIfBound(false);
+		});
+
+	return true;
+}
+
+bool FUserManagerEOS::ShowSendMessageUI(int32 LocalUserNum, const FShowSendMessageParams& ShowParams, const FOnShowSendMessageUIClosedDelegate& Delegate)
+{
+	UE_LOG_ONLINE_EXTERNALUI(Warning, TEXT("[FUserManagerEOS::ShowSendMessageUI] This method is not implemented."));
+
+	EOSSubsystem->ExecuteNextTick([this, Delegate]()
+		{
+			Delegate.ExecuteIfBound(false);
+		});
+
+	return true;
+}
+
+// ~IOnlineExternalUI Interface
+
+typedef TEOSCallback<EOS_Friends_OnQueryFriendsCallback, EOS_Friends_QueryFriendsCallbackInfo> FReadFriendsCallback;
+
+void FUserManagerEOS::FriendStatusChanged(const EOS_Friends_OnFriendsUpdateInfo* Data)
+{
+	// This seems to happen due to the SDK's local cache going from empty to filled, so ignore it
+	// It's not really a valid transition since there should have been a pending invite inbetween
+	if (Data->PreviousStatus == EOS_EFriendsStatus::EOS_FS_NotFriends && Data->CurrentStatus == EOS_EFriendsStatus::EOS_FS_Friends)
+	{
+		return;
+	}
+
+	// Get the local user information
+	if (AccountIdToUserNumMap.Contains(Data->LocalUserId))
+	{
+		int32 LocalUserNum = AccountIdToUserNumMap[Data->LocalUserId];
+		FUniqueNetIdEOSPtr LocalEOSID = UserNumToNetIdMap[LocalUserNum];
+		// If we don't know them yet, then add them to kick off the reads
+		if (!AccountIdToStringMap.Contains(Data->TargetUserId))
+		{
+			AddFriend(LocalUserNum, Data->TargetUserId);
+		}
+		// They are in our list now
+		FOnlineUserPtr OnlineUser = EpicAccountIdToOnlineUserMap[Data->TargetUserId];
+		FOnlineFriendEOSPtr Friend = LocalUserNumToFriendsListMap[LocalUserNum]->GetByNetIdString(AccountIdToStringMap[Data->TargetUserId]);
+		// Figure out which notification to fire
+		if (Data->CurrentStatus == EOS_EFriendsStatus::EOS_FS_Friends)
+		{
+			Friend->SetInviteStatus(EInviteStatus::Accepted);
+			TriggerOnInviteAcceptedDelegates(*LocalEOSID, *OnlineUser->GetUserId());
+		}
+		else if (Data->PreviousStatus == EOS_EFriendsStatus::EOS_FS_Friends && Data->CurrentStatus == EOS_EFriendsStatus::EOS_FS_NotFriends)
+		{
+			LocalUserNumToFriendsListMap[LocalUserNum]->Remove(AccountIdToStringMap[Data->TargetUserId], Friend.ToSharedRef());
+			Friend->SetInviteStatus(EInviteStatus::Unknown);
+			TriggerOnFriendRemovedDelegates(*LocalEOSID, *OnlineUser->GetUserId());
+		}
+		else if (Data->PreviousStatus < EOS_EFriendsStatus::EOS_FS_Friends && Data->CurrentStatus == EOS_EFriendsStatus::EOS_FS_NotFriends)
+		{
+			LocalUserNumToFriendsListMap[LocalUserNum]->Remove(AccountIdToStringMap[Data->TargetUserId], Friend.ToSharedRef());
+			Friend->SetInviteStatus(EInviteStatus::Unknown);
+			TriggerOnInviteRejectedDelegates(*LocalEOSID, *OnlineUser->GetUserId());
+		}
+		else if (Data->CurrentStatus == EOS_EFriendsStatus::EOS_FS_InviteReceived)
+		{
+			Friend->SetInviteStatus(EInviteStatus::PendingInbound);
+			TriggerOnInviteReceivedDelegates(*LocalEOSID, *OnlineUser->GetUserId());
+		}
+		TriggerOnFriendsChangeDelegates(LocalUserNum);
+	}
+}
+
+void FUserManagerEOS::AddFriend(int32 LocalUserNum, EOS_EpicAccountId EpicAccountId)
+{
+	const FString NetId = LexToString(EpicAccountId);
+	FUniqueNetIdEOSRef FriendNetId = FUniqueNetIdEOS::Create(NetId);
+	FOnlineFriendEOSRef FriendRef = MakeShareable(new FOnlineFriendEOS(FriendNetId));
+	LocalUserNumToFriendsListMap[LocalUserNum]->Add(NetId, FriendRef);
+
+	EOS_Friends_GetStatusOptions Options = { };
+	Options.ApiVersion = EOS_FRIENDS_GETSTATUS_API_LATEST;
+	Options.LocalUserId = UserNumToAccountIdMap[LocalUserNum];
+	Options.TargetUserId = EpicAccountId;
+	EOS_EFriendsStatus Status = EOS_Friends_GetStatus(EOSSubsystem->FriendsHandle, &Options);
+	
+	FriendRef->SetInviteStatus(ToEInviteStatus(Status));
+
+	// Add this friend as a remote player (this will grab user info)
+	AddRemotePlayer(LocalUserNum, NetId, EpicAccountId, FriendNetId, FriendRef, FriendRef);
+
+	// Querying the presence of a non-friend would cause an SDK error.
+	// Players that sent/recieved a friend invitation from us still count as "friends", so check
+	// our friend relationship here.
+	if(Status == EOS_EFriendsStatus::EOS_FS_Friends)
+	{
+		QueryPresence(*FriendNetId, IgnoredPresenceDelegate);
+	}
+}
+
+void FUserManagerEOS::AddRemotePlayer(int32 LocalUserNum, const FString& NetId, EOS_EpicAccountId EpicAccountId)
+{
+	FUniqueNetIdEOSRef EOSID = FUniqueNetIdEOS::Create(NetId);
+	FOnlineUserEOSRef UserRef = MakeShareable(new FOnlineUserEOS(EOSID));
+	// Add this user as a remote (this will grab presence & user info)
+	AddRemotePlayer(LocalUserNum, NetId, EpicAccountId, EOSID, UserRef, UserRef);
+}
+
+void FUserManagerEOS::AddRemotePlayer(int32 LocalUserNum, const FString& NetId, EOS_EpicAccountId EpicAccountId, FUniqueNetIdEOSPtr UniqueNetId, FOnlineUserPtr OnlineUser, IAttributeAccessInterfaceRef AttributeRef)
+{
+	NetIdStringToOnlineUserMap.Emplace(NetId, OnlineUser);
+	EpicAccountIdToOnlineUserMap.Emplace(EpicAccountId, OnlineUser);
+	NetIdStringToAttributeAccessMap.Emplace(NetId, AttributeRef);
+	EpicAccountIdToAttributeAccessMap.Emplace(EpicAccountId, AttributeRef);
+
+	StringToAccountIdMap.Emplace(NetId, EpicAccountId);
+	AccountIdToStringMap.Emplace(EpicAccountId, NetId);
+
+	// Read the user info for this player
+	ReadUserInfo(LocalUserNum, EpicAccountId);
+}
+
+void FUserManagerEOS::UpdateRemotePlayerProductUserId(EOS_EpicAccountId AccountId, EOS_ProductUserId UserId)
+{
+	// See if the net ids have changed for this user and bail if they are the same
+	const FString NewNetIdStr = MakeNetIdStringFromIds(AccountId, UserId);
+	const FString PrevNetIdStr = AccountIdToStringMap[AccountId];
+	if (PrevNetIdStr == NewNetIdStr)
+	{
+		// No change, so skip any work
+		return;
+	}
+
+	const FString AccountIdStr = LexToString(AccountId);
+	const FString UserIdStr = LexToString(UserId);
+
+	// Get the unique net id and rebuild the string for it
+	IAttributeAccessInterfaceRef AttrAccess = NetIdStringToAttributeAccessMap[PrevNetIdStr];
+	FUniqueNetIdEOSPtr NetIdEOS = AttrAccess->GetUniqueNetIdEOS();
+	if (NetIdEOS.IsValid())
+	{
+		ConstCastSharedPtr<FUniqueNetIdEOS>(NetIdEOS)->UpdateNetIdStr(NewNetIdStr);
+	}
+	// Update any old friends entries with the new net id key
+	for (TMap<int32, FFriendsListEOSRef>::TConstIterator It(LocalUserNumToFriendsListMap); It; ++It)
+	{
+		FFriendsListEOSRef FriendsList = It.Value();
+		FOnlineFriendEOSPtr FoundFriend = FriendsList->GetByNetIdString(PrevNetIdStr);
+		if (FoundFriend.IsValid())
+		{
+			FriendsList->UpdateNetIdStr(PrevNetIdStr, NewNetIdStr);
+		}
+	}
+	// Update all of the other net id to X mappings
+	AccountIdToStringMap.Remove(AccountId);
+	AccountIdToStringMap.Emplace(AccountId, NewNetIdStr);
+	ProductUserIdToStringMap.Remove(UserId);
+	ProductUserIdToStringMap.Emplace(UserId, *NewNetIdStr);
+	StringToAccountIdMap.Remove(PrevNetIdStr);
+	StringToAccountIdMap.Emplace(NewNetIdStr, AccountId);
+	StringToProductUserIdMap.Emplace(NewNetIdStr, UserId);
+	// If it's the first time we're updating this remote player, it will be indexed by its epic account id
+	FOnlineUserPtr OnlineUser = NetIdStringToOnlineUserMap[AccountIdStr];
+	if (OnlineUser.IsValid())
+	{
+		NetIdStringToOnlineUserMap.Remove(AccountIdStr);
+	}
+	else
+	{
+		OnlineUser = NetIdStringToOnlineUserMap[PrevNetIdStr];
+		NetIdStringToOnlineUserMap.Remove(PrevNetIdStr);
+	}
+	NetIdStringToOnlineUserMap.Emplace(NewNetIdStr, OnlineUser);
+	NetIdStringToAttributeAccessMap.Remove(PrevNetIdStr);
+	NetIdStringToAttributeAccessMap.Emplace(NewNetIdStr, AttrAccess);
+	// Presence may not be available for all online users
+	if (NetIdStringToOnlineUserPresenceMap.Contains(PrevNetIdStr))
+	{
+		FOnlineUserPresenceRef UserPresence = NetIdStringToOnlineUserPresenceMap[PrevNetIdStr];
+		NetIdStringToOnlineUserPresenceMap.Remove(PrevNetIdStr);
+		NetIdStringToOnlineUserPresenceMap.Emplace(NewNetIdStr, UserPresence);
+	}
+}
+
+// IOnlineFriends Interface
+
+bool FUserManagerEOS::ReadFriendsList(int32 LocalUserNum, const FString& ListName, const FOnReadFriendsListComplete& Delegate)
+{
+	if (!UserNumToNetIdMap.Contains(LocalUserNum))
+	{
+		const FString ErrorStr = FString::Printf(TEXT("Can't ReadFriendsList() for user (%d) since they are not logged in"), LocalUserNum);
+		UE_LOG_ONLINE_FRIEND(Warning, TEXT("%s"), *ErrorStr);
+		Delegate.ExecuteIfBound(LocalUserNum, false, ListName, ErrorStr);
+		return false;
+	}
+
+	// We save the information for this call even if it won't be automatically processed
+	const bool bIsReadFriendsListOngoing = CachedReadUserListInfoForLocalUserMap.Contains(LocalUserNum);
+	if (!bIsReadFriendsListOngoing)
+	{
+		CachedReadUserListInfoForLocalUserMap.Emplace(LocalUserNum);
+	}
+	CachedReadUserListInfoForLocalUserMap[LocalUserNum].Add(ReadUserListInfo(LocalUserNum, ListName, Delegate));
+
+	if (bIsReadFriendsListOngoing)
+	{
+		UE_LOG_ONLINE_FRIEND(Verbose, TEXT("A ReadFriendsList() operation for user (%d) is already running, we'll save its information and launch it automatically later."), LocalUserNum);
+		return true;
+	}
+
+	EOS_Friends_QueryFriendsOptions Options = { };
+	Options.ApiVersion = EOS_FRIENDS_QUERYFRIENDS_API_LATEST;
+	Options.LocalUserId = UserNumToAccountIdMap[LocalUserNum];
+
+	FReadFriendsCallback* CallbackObj = new FReadFriendsCallback();
+	CallbackObj->CallbackLambda = [this, LocalUserNum, ListName, Delegate](const EOS_Friends_QueryFriendsCallbackInfo* Data)
+	{
+		EOS_EResult Result = Data->ResultCode;
+		if (GetLoginStatus(LocalUserNum) != ELoginStatus::LoggedIn)
+		{
+			// Handle the user logging out while a read is in progress
+			Result = EOS_EResult::EOS_InvalidUser;
+		}
+
+		bool bWasSuccessful = Result == EOS_EResult::EOS_Success;
+		if (bWasSuccessful)
+		{
+			EOS_Friends_GetFriendsCountOptions Options = { };
+			Options.ApiVersion = EOS_FRIENDS_GETFRIENDSCOUNT_API_LATEST;
+			Options.LocalUserId = UserNumToAccountIdMap[LocalUserNum];
+			int32 FriendCount = EOS_Friends_GetFriendsCount(EOSSubsystem->FriendsHandle, &Options);
+
+			LocalUserNumToFriendsListMap[LocalUserNum]->Empty(FriendCount);
+
+			TArray<FString> FriendEasIds;
+			FriendEasIds.Reserve(FriendCount);
+			// Process each friend returned
+			for (int32 Index = 0; Index < FriendCount; Index++)
+			{
+				EOS_Friends_GetFriendAtIndexOptions FriendIndexOptions = { };
+				FriendIndexOptions.ApiVersion = EOS_FRIENDS_GETFRIENDATINDEX_API_LATEST;
+				FriendIndexOptions.Index = Index;
+				FriendIndexOptions.LocalUserId = Options.LocalUserId;
+				EOS_EpicAccountId FriendEpicAccountId = EOS_Friends_GetFriendAtIndex(EOSSubsystem->FriendsHandle, &FriendIndexOptions);
+				if (FriendEpicAccountId != nullptr)
+				{
+					AddFriend(LocalUserNum, FriendEpicAccountId);
+					FriendEasIds.Add(LexToString(FriendEpicAccountId));
+				}
+			}
+
+			const TFunction<FOnQueryExternalIdMappingsComplete::TFuncType>& OnExternalIdMappingsQueriedLambda = 
+				[this, LocalUserNum](bool bWasSuccessful, const FUniqueNetId& UserId, const FExternalIdQueryOptions& QueryOptions,
+					const TArray<FString>& ExternalIds, const FString& Error) {
+						ProcessReadFriendsListComplete(LocalUserNum, bWasSuccessful, Error);
+				};
+
+			const auto& ExternalMappingsCallback = OSSInternalCallback::Create<FOnQueryExternalIdMappingsComplete>(EOSSubsystem->UserManager, OnExternalIdMappingsQueriedLambda);
+			
+			QueryExternalIdMappings(*GetLocalUniqueNetIdEOS(DefaultLocalUser), FExternalIdQueryOptions(), FriendEasIds, ExternalMappingsCallback);
+			
+		}
+		else
+		{
+			const FString ErrorString = FString::Printf(TEXT("ReadFriendsList(%d) failed with EOS result code (%s)"), LocalUserNum, ANSI_TO_TCHAR(EOS_EResult_ToString(Result)));
+			ProcessReadFriendsListComplete(LocalUserNum, false, ErrorString);
+		}
+	};
+	EOS_Friends_QueryFriends(EOSSubsystem->FriendsHandle, &Options, CallbackObj, CallbackObj->GetCallbackPtr());
+
+	return true;
+}
+
+void FUserManagerEOS::ProcessReadFriendsListComplete(int32 LocalUserNum, bool bWasSuccessful, const FString& ErrorStr)
+{
+	// If we started any user info queries for friends, we'll just wait until they finish
+	if (!IsFriendQueryUserInfoOngoing(LocalUserNum))
+	{
+		// If not, we'll just trigger the delegates for all cached calls
+		TArray<ReadUserListInfo> CachedInfoList;
+		if (CachedReadUserListInfoForLocalUserMap.RemoveAndCopyValue(LocalUserNum, CachedInfoList))
+		{
+			for (const ReadUserListInfo& CachedInfo : CachedInfoList)
+			{
+				CachedInfo.ExecuteDelegateIfBound(bWasSuccessful, ErrorStr);
+			}
+		}
+
+		TriggerOnFriendsChangeDelegates(LocalUserNum);
+
+		IsFriendQueryUserInfoOngoingForLocalUserMap.Remove(LocalUserNum);
+		IsPlayerQueryExternalMappingsOngoingForLocalUserMap.Remove(LocalUserNum);
+	}
+}
+
+void FUserManagerEOS::SetFriendAlias(int32 LocalUserNum, const FUniqueNetId& FriendId, const FString& ListName, const FString& Alias, const FOnSetFriendAliasComplete& Delegate)
+{
+	UE_LOG_ONLINE_FRIEND(Warning, TEXT("[FUserManagerEOS::SetFriendAlias] This method is not supported."));
+
+	EOSSubsystem->ExecuteNextTick([this, LocalUserNum, FriendId = FriendId.AsShared(), ListName, Delegate]()
+		{
+			Delegate.ExecuteIfBound(LocalUserNum, *FriendId, ListName, FOnlineError(EOnlineErrorResult::NotImplemented));
+		});
+}
+
+void FUserManagerEOS::DeleteFriendAlias(int32 LocalUserNum, const FUniqueNetId& FriendId, const FString& ListName, const FOnDeleteFriendAliasComplete& Delegate)
+{
+	UE_LOG_ONLINE_FRIEND(Warning, TEXT("[FUserManagerEOS::DeleteFriendAlias] This method is not supported."));
+
+	EOSSubsystem->ExecuteNextTick([this, LocalUserNum, FriendId = FriendId.AsShared(), ListName, Delegate]()
+		{
+			Delegate.ExecuteIfBound(LocalUserNum, *FriendId, ListName, FOnlineError(EOnlineErrorResult::NotImplemented));
+		});
+}
+
+bool FUserManagerEOS::DeleteFriendsList(int32 LocalUserNum, const FString& ListName, const FOnDeleteFriendsListComplete& Delegate)
+{
+	UE_LOG_ONLINE_FRIEND(Warning, TEXT("[FUserManagerEOS::DeleteFriendsList] This method is not supported."));
+
+	EOSSubsystem->ExecuteNextTick([this, LocalUserNum, ListName, Delegate]()
+		{
+			Delegate.ExecuteIfBound(LocalUserNum, false, ListName, TEXT("This method is not supported."));
+		});
+
+	return true;
+}
+
+typedef TEOSCallback<EOS_Friends_OnSendInviteCallback, EOS_Friends_SendInviteCallbackInfo> FSendInviteCallback;
+
+bool FUserManagerEOS::SendInvite(int32 LocalUserNum, const FUniqueNetId& FriendId, const FString& ListName, const FOnSendInviteComplete& Delegate)
+{
+	if (!UserNumToNetIdMap.Contains(LocalUserNum))
+	{
+		UE_LOG_ONLINE_FRIEND(Warning, TEXT("Can't SendInvite() for user (%d) since they are not logged in"), LocalUserNum);
+		Delegate.ExecuteIfBound(LocalUserNum, false, FriendId, ListName, FString(TEXT("Can't SendInvite() for user (%d) since they are not logged in"), LocalUserNum));
+		return false;
+	}
+
+	const FUniqueNetIdEOS& EOSID = FUniqueNetIdEOS::Cast(FriendId);
+	if (!StringToAccountIdMap.Contains(EOSID.UniqueNetIdStr))
+	{
+		UE_LOG_ONLINE_FRIEND(Warning, TEXT("Can't SendInvite() for user (%d) since the potential player id is unknown"), LocalUserNum);
+		Delegate.ExecuteIfBound(LocalUserNum, false, FriendId, ListName, FString(TEXT("Can't SendInvite() for user (%d) since the player id is unknown"), LocalUserNum));
+		return false;
+	}
+
+	FSendInviteCallback* CallbackObj = new FSendInviteCallback();
+	CallbackObj->CallbackLambda = [LocalUserNum, ListName, this, Delegate](const EOS_Friends_SendInviteCallbackInfo* Data)
+	{
+		const FString& NetId = AccountIdToStringMap[Data->TargetUserId];
+
+		FString ErrorString;
+		bool bWasSuccessful = Data->ResultCode == EOS_EResult::EOS_Success;
+		if (!bWasSuccessful)
+		{
+			ErrorString = FString::Printf(TEXT("Failed to send invite for user (%d) to player (%s) with result code (%s)"), LocalUserNum, *NetId, ANSI_TO_TCHAR(EOS_EResult_ToString(Data->ResultCode)));
+		}
+		Delegate.ExecuteIfBound(LocalUserNum, bWasSuccessful, *FUniqueNetIdEOS::Create(NetId), ListName, ErrorString);
+	};
+
+	EOS_Friends_SendInviteOptions Options = { };
+	Options.ApiVersion = EOS_FRIENDS_SENDINVITE_API_LATEST;
+	Options.LocalUserId = UserNumToAccountIdMap[LocalUserNum];
+	Options.TargetUserId = StringToAccountIdMap[EOSID.UniqueNetIdStr];
+	EOS_Friends_SendInvite(EOSSubsystem->FriendsHandle, &Options, CallbackObj, CallbackObj->GetCallbackPtr());
+
+	return true;
+}
+
+typedef TEOSCallback<EOS_Friends_OnAcceptInviteCallback, EOS_Friends_AcceptInviteCallbackInfo> FAcceptInviteCallback;
+
+bool FUserManagerEOS::AcceptInvite(int32 LocalUserNum, const FUniqueNetId& FriendId, const FString& ListName, const FOnAcceptInviteComplete& Delegate)
+{
+	if (!UserNumToNetIdMap.Contains(LocalUserNum))
+	{
+		UE_LOG_ONLINE_FRIEND(Warning, TEXT("Can't AcceptInvite() for user (%d) since they are not logged in"), LocalUserNum);
+		Delegate.ExecuteIfBound(LocalUserNum, false, FriendId, ListName, FString(TEXT("Can't AcceptInvite() for user (%d) since they are not logged in"), LocalUserNum));
+		return false;
+	}
+
+	const FUniqueNetIdEOS& EOSID = FUniqueNetIdEOS::Cast(FriendId);
+	if (!StringToAccountIdMap.Contains(EOSID.UniqueNetIdStr))
+	{
+		UE_LOG_ONLINE_FRIEND(Warning, TEXT("Can't AcceptInvite() for user (%d) since the friend is not in their list"), LocalUserNum);
+		Delegate.ExecuteIfBound(LocalUserNum, false, FriendId, ListName, FString(TEXT("Can't AcceptInvite() for user (%d) since the friend is not in their list"), LocalUserNum));
+		return false;
+	}
+
+	FAcceptInviteCallback* CallbackObj = new FAcceptInviteCallback();
+	CallbackObj->CallbackLambda = [LocalUserNum, ListName, this, Delegate](const EOS_Friends_AcceptInviteCallbackInfo* Data)
+	{
+		const FString& NetId = AccountIdToStringMap[Data->TargetUserId];
+
+		FString ErrorString;
+		bool bWasSuccessful = Data->ResultCode == EOS_EResult::EOS_Success;
+		if (!bWasSuccessful)
+		{
+			ErrorString = FString::Printf(TEXT("Failed to accept invite for user (%d) from friend (%s) with result code (%s)"), LocalUserNum, *NetId, ANSI_TO_TCHAR(EOS_EResult_ToString(Data->ResultCode)));
+		}
+		Delegate.ExecuteIfBound(LocalUserNum, bWasSuccessful, *FUniqueNetIdEOS::Create(NetId), ListName, ErrorString);
+	};
+
+	EOS_Friends_AcceptInviteOptions Options = { };
+	Options.ApiVersion = EOS_FRIENDS_ACCEPTINVITE_API_LATEST;
+	Options.LocalUserId = UserNumToAccountIdMap[LocalUserNum];
+	Options.TargetUserId = StringToAccountIdMap[EOSID.UniqueNetIdStr];
+	EOS_Friends_AcceptInvite(EOSSubsystem->FriendsHandle, &Options, CallbackObj, CallbackObj->GetCallbackPtr());
+	return true;
+}
+
+void EOS_CALL EOSRejectInviteCallback(const EOS_Friends_RejectInviteCallbackInfo* Data)
+{
+	// We don't need to notify anyone so ignore
+}
+
+bool FUserManagerEOS::RejectInvite(int32 LocalUserNum, const FUniqueNetId& FriendId, const FString& ListName)
+{
+	if (!UserNumToNetIdMap.Contains(LocalUserNum))
+	{
+		UE_LOG_ONLINE_FRIEND(Warning, TEXT("Can't RejectInvite() for user (%d) since they are not logged in"), LocalUserNum);
+		return false;
+	}
+
+	const FUniqueNetIdEOS& EOSID = FUniqueNetIdEOS::Cast(FriendId);
+	if (!StringToAccountIdMap.Contains(EOSID.UniqueNetIdStr))
+	{
+		UE_LOG_ONLINE_FRIEND(Warning, TEXT("Can't RejectInvite() for user (%d) since the friend is not in their list"), LocalUserNum);
+		return false;
+	}
+
+	EOS_Friends_RejectInviteOptions Options{ 0 };
+	Options.ApiVersion = EOS_FRIENDS_REJECTINVITE_API_LATEST;
+	Options.LocalUserId = UserNumToAccountIdMap[LocalUserNum];
+	Options.TargetUserId = StringToAccountIdMap[EOSID.UniqueNetIdStr];
+	EOS_Friends_RejectInvite(EOSSubsystem->FriendsHandle, &Options, nullptr, &EOSRejectInviteCallback);
+	return true;
+}
+
+bool FUserManagerEOS::DeleteFriend(int32 LocalUserNum, const FUniqueNetId& FriendId, const FString& ListName)
+{
+	UE_LOG_ONLINE_FRIEND(Warning, TEXT("[FUserManagerEOS::DeleteFriend] Friends may only be deleted via the Epic Games Launcher."));
+
+	EOSSubsystem->ExecuteNextTick([this, LocalUserNum, FriendId = FriendId.AsShared(), ListName]()
+		{
+			TriggerOnDeleteFriendCompleteDelegates(LocalUserNum, false, *FriendId, ListName, TEXT("[FUserManagerEOS::DeleteFriend] Friends may only be deleted via the Epic Games Launcher."));
+		});
+
+	return true;
+}
+
+bool FUserManagerEOS::GetFriendsList(int32 LocalUserNum, const FString& ListName, TArray<TSharedRef<FOnlineFriend>>& OutFriends)
+{
+	OutFriends.Reset();
+	if (LocalUserNumToFriendsListMap.Contains(LocalUserNum))
+	{
+		FFriendsListEOSRef FriendsList = LocalUserNumToFriendsListMap[LocalUserNum];
+		for (FOnlineFriendEOSRef Friend : FriendsList->GetList())
+		{
+			const FOnlineUserPresence& Presence = Friend->GetPresence();
+			// See if they only want online only
+			if (ListName == EFriendsLists::ToString(EFriendsLists::OnlinePlayers) && !Presence.bIsOnline)
+			{
+				continue;
+			}
+			// Of if they only want friends playing this game
+			else if (ListName == EFriendsLists::ToString(EFriendsLists::InGamePlayers) && !Presence.bIsPlayingThisGame)
+			{
+				continue;
+			}
+			// If the service hasn't returned the info yet, skip them
+			else if (Friend->GetDisplayName().IsEmpty())
+			{
+				continue;
+			}
+			OutFriends.Add(Friend);
+		}
+		// Sort these by those playing the game first, alphabetically, then not playing, then not online
+		OutFriends.Sort([](TSharedRef<FOnlineFriend> A, TSharedRef<FOnlineFriend> B)
+		{
+			const FOnlineUserPresence& APres = A->GetPresence();
+			const FOnlineUserPresence& BPres = B->GetPresence();
+			// If they are the same, then check playing this game
+			if (APres.bIsOnline == BPres.bIsOnline)
+			{
+				// If they are the same, then sort by name
+				if (APres.bIsPlayingThisGame == BPres.bIsPlayingThisGame)
+				{
+					const EInviteStatus::Type AFriendStatus = A->GetInviteStatus();
+					const EInviteStatus::Type BFriendStatus = B->GetInviteStatus();
+					// Sort pending friends below accepted friends
+					if (AFriendStatus == BFriendStatus && AFriendStatus == EInviteStatus::Accepted)
+					{
+						const FString& AName = A->GetDisplayName();
+						const FString& BName = B->GetDisplayName();
+						return AName < BName;
+					}
+				}
+			}
+			return false;
+		});
+		return true;
+	}
+	return false;
+}
+
+TSharedPtr<FOnlineFriend> FUserManagerEOS::GetFriend(int32 LocalUserNum, const FUniqueNetId& FriendId, const FString& ListName)
+{
+	if (LocalUserNumToFriendsListMap.Contains(LocalUserNum))
+	{
+		FFriendsListEOSRef FriendsList = LocalUserNumToFriendsListMap[LocalUserNum];
+		const FUniqueNetIdEOS& EosId = FUniqueNetIdEOS::Cast(FriendId);
+		FOnlineFriendEOSPtr FoundFriend = FriendsList->GetByNetIdString(EosId.UniqueNetIdStr);
+		if (FoundFriend.IsValid())
+		{
+			const FOnlineUserPresence& Presence = FoundFriend->GetPresence();
+			// See if they only want online only
+			if (ListName == EFriendsLists::ToString(EFriendsLists::OnlinePlayers) && !Presence.bIsOnline)
+			{
+				return TSharedPtr<FOnlineFriend>();
+			}
+			// Of if they only want friends playing this game
+			else if (ListName == EFriendsLists::ToString(EFriendsLists::InGamePlayers) && !Presence.bIsPlayingThisGame)
+			{
+				return TSharedPtr<FOnlineFriend>();
+			}
+			return FoundFriend;
+		}
+	}
+	return TSharedPtr<FOnlineFriend>();
+}
+
+bool FUserManagerEOS::IsFriend(int32 LocalUserNum, const FUniqueNetId& FriendId, const FString& ListName)
+{
+	return GetFriend(LocalUserNum, FriendId, ListName).IsValid();
+}
+
+bool FUserManagerEOS::QueryRecentPlayers(const FUniqueNetId& UserId, const FString& Namespace)
+{
+	UE_LOG_ONLINE_FRIEND(Warning, TEXT("[FUserManagerEOS::QueryRecentPlayers] This method is not supported."));
+
+	EOSSubsystem->ExecuteNextTick([this, UserId = UserId.AsShared(), Namespace]()
+		{
+			TriggerOnQueryRecentPlayersCompleteDelegates(*UserId, Namespace, false, TEXT("This method is not supported."));
+		});
+
+	return true;
+}
+
+bool FUserManagerEOS::GetRecentPlayers(const FUniqueNetId& UserId, const FString& Namespace, TArray<TSharedRef<FOnlineRecentPlayer>>& OutRecentPlayers)
+{
+	UE_LOG_ONLINE_FRIEND(Warning, TEXT("[FUserManagerEOS::GetRecentPlayers] This method is not supported."));
+
+	return false;
+}
+
+bool FUserManagerEOS::BlockPlayer(int32 LocalUserNum, const FUniqueNetId& PlayerId)
+{
+	UE_LOG_ONLINE_FRIEND(Warning, TEXT("[FUserManagerEOS::BlockPlayer] This method is not supported."));
+
+	EOSSubsystem->ExecuteNextTick([this, LocalUserNum, PlayerId = PlayerId.AsShared()]()
+		{
+			TriggerOnBlockedPlayerCompleteDelegates(LocalUserNum, false, *PlayerId, TEXT(""), TEXT("This method is not supported"));
+		});
+
+	return true;
+}
+
+bool FUserManagerEOS::UnblockPlayer(int32 LocalUserNum, const FUniqueNetId& PlayerId)
+{
+	UE_LOG_ONLINE_FRIEND(Warning, TEXT("[FUserManagerEOS::UnblockPlayer] This method is not supported."));
+
+	EOSSubsystem->ExecuteNextTick([this, LocalUserNum, PlayerId = PlayerId.AsShared()]()
+		{
+			TriggerOnUnblockedPlayerCompleteDelegates(LocalUserNum, false, *PlayerId, TEXT(""), TEXT("This method is not supported"));
+		});
+
+	return true;
+}
+
+bool FUserManagerEOS::QueryBlockedPlayers(const FUniqueNetId& UserId)
+{
+	UE_LOG_ONLINE_FRIEND(Warning, TEXT("[FUserManagerEOS::QueryBlockedPlayers] This method is not supported."));
+
+	EOSSubsystem->ExecuteNextTick([this, UserId = UserId.AsShared()]()
+		{
+			TriggerOnQueryBlockedPlayersCompleteDelegates(*UserId, false, TEXT("This method is not supported"));
+		});
+
+	return true;
+}
+
+bool FUserManagerEOS::GetBlockedPlayers(const FUniqueNetId& UserId, TArray<TSharedRef<FOnlineBlockedPlayer>>& OutBlockedPlayers)
+{
+	UE_LOG_ONLINE_FRIEND(Warning, TEXT("[FUserManagerEOS::GetBlockedPlayers] This method is not supported."));
+
+	return false;
+}
+
+void FUserManagerEOS::DumpBlockedPlayers() const
+{
+	UE_LOG_ONLINE_FRIEND(Warning, TEXT("[FUserManagerEOS::DumpBlockedPlayers] This method is not supported."));
+}
+
+void FUserManagerEOS::DumpRecentPlayers() const
+{
+	UE_LOG_ONLINE_FRIEND(Warning, TEXT("[FUserManagerEOS::DumpRecentPlayers] This method is not supported."));
+}
+
+bool FUserManagerEOS::HandleFriendsExec(UWorld* InWorld, const TCHAR* Cmd, FOutputDevice& Ar)
+{
+#if !UE_BUILD_SHIPPING
+
+	bool bWasHandled = true;
+	if (FParse::Command(&Cmd, TEXT("ReadFriendsList"))) /* ONLINE (EOS if using EOSPlus) FRIENDS ReadFriendsList 0 default/onlinePlayers/inGamePlayers/inGameAndSessionPlayers */
+	{
+		int LocalUserNum = FCString::Atoi(*FParse::Token(Cmd, false));
+
+		FString FriendsList = FParse::Token(Cmd, false);
+
+		ReadFriendsList(LocalUserNum, FriendsList, FOnReadFriendsListComplete());
+	}
+	else if (FParse::Command(&Cmd, TEXT("GetFriendsList"))) /* ONLINE (EOS if using EOSPlus) FRIENDS GetFriendsList 0 default/onlinePlayers/inGamePlayers/inGameAndSessionPlayers */
+	{
+		int LocalUserNum = FCString::Atoi(*FParse::Token(Cmd, false));
+
+		FString FriendsList = FParse::Token(Cmd, false);
+
+		TArray< TSharedRef<FOnlineFriend> > Friends;
+		// Grab the friends data so we can print it out
+		if (GetFriendsList(LocalUserNum, FriendsList, Friends))
+		{
+			UE_LOG_ONLINE_FRIEND(Log, TEXT("FUserManagerEOS::GetFriendsList returned %d friends"), Friends.Num());
+
+			// Log each friend's data out
+			for (int32 Index = 0; Index < Friends.Num(); Index++)
+			{
+				const FOnlineFriend& Friend = *Friends[Index];
+				const FOnlineUserPresence& Presence = Friend.GetPresence();
+				UE_LOG_ONLINE_FRIEND(Log, TEXT("\t%s has unique id (%s)"), *Friend.GetDisplayName(), *Friend.GetUserId()->ToDebugString());
+				UE_LOG_ONLINE_FRIEND(Log, TEXT("\t\t Invite status (%s)"), EInviteStatus::ToString(Friend.GetInviteStatus()));
+				UE_LOG_ONLINE_FRIEND(Log, TEXT("\t\t Presence: %s"), *Presence.Status.StatusStr);
+				UE_LOG_ONLINE_FRIEND(Log, TEXT("\t\t State: %s"), EOnlinePresenceState::ToString(Presence.Status.State));
+				UE_LOG_ONLINE_FRIEND(Log, TEXT("\t\t bIsOnline (%s)"), Presence.bIsOnline ? TEXT("true") : TEXT("false"));
+				UE_LOG_ONLINE_FRIEND(Log, TEXT("\t\t bIsPlaying (%s)"), Presence.bIsPlaying ? TEXT("true") : TEXT("false"));
+				UE_LOG_ONLINE_FRIEND(Log, TEXT("\t\t bIsPlayingThisGame (%s)"), Presence.bIsPlayingThisGame ? TEXT("true") : TEXT("false"));
+				UE_LOG_ONLINE_FRIEND(Log, TEXT("\t\t bIsJoinable (%s)"), Presence.bIsJoinable ? TEXT("true") : TEXT("false"));
+				UE_LOG_ONLINE_FRIEND(Log, TEXT("\t\t bHasVoiceSupport (%s)"), Presence.bHasVoiceSupport ? TEXT("true") : TEXT("false"));
+			}
+		}
+	}
+	else if (FParse::Command(&Cmd, TEXT("GetFriend"))) /* ONLINE (EOS if using EOSPlus) FRIENDS GetFriend 0 "FriendUserId|FullStr" default/onlinePlayers/inGamePlayers/inGameAndSessionPlayers */
+	{
+		int LocalUserNum = FCString::Atoi(*FParse::Token(Cmd, false));
+
+		FString FriendUserIdStr = FParse::Token(Cmd, false);
+		FUniqueNetIdEOSRef FriendEosId = FUniqueNetIdEOS::Create(FriendUserIdStr);
+
+		FString FriendsList = FParse::Token(Cmd, false);
+
+		TSharedPtr<FOnlineFriend> Friend = GetFriend(LocalUserNum, *FriendEosId, FriendsList);
+		if (Friend.IsValid())
+		{
+			const FOnlineUserPresence& Presence = Friend->GetPresence();
+			UE_LOG_ONLINE_FRIEND(Log, TEXT("\t%s has unique id (%s)"), *Friend->GetDisplayName(), *Friend->GetUserId()->ToDebugString());
+			UE_LOG_ONLINE_FRIEND(Log, TEXT("\t\t Invite status (%s)"), EInviteStatus::ToString(Friend->GetInviteStatus()));
+			UE_LOG_ONLINE_FRIEND(Log, TEXT("\t\t Presence: %s"), *Presence.Status.StatusStr);
+			UE_LOG_ONLINE_FRIEND(Log, TEXT("\t\t State: %s"), EOnlinePresenceState::ToString(Presence.Status.State));
+			UE_LOG_ONLINE_FRIEND(Log, TEXT("\t\t bIsOnline (%s)"), Presence.bIsOnline ? TEXT("true") : TEXT("false"));
+			UE_LOG_ONLINE_FRIEND(Log, TEXT("\t\t bIsPlaying (%s)"), Presence.bIsPlaying ? TEXT("true") : TEXT("false"));
+			UE_LOG_ONLINE_FRIEND(Log, TEXT("\t\t bIsPlayingThisGame (%s)"), Presence.bIsPlayingThisGame ? TEXT("true") : TEXT("false"));
+			UE_LOG_ONLINE_FRIEND(Log, TEXT("\t\t bIsJoinable (%s)"), Presence.bIsJoinable ? TEXT("true") : TEXT("false"));
+			UE_LOG_ONLINE_FRIEND(Log, TEXT("\t\t bHasVoiceSupport (%s)"), Presence.bHasVoiceSupport ? TEXT("true") : TEXT("false"));
+		}
+	}
+	else if (FParse::Command(&Cmd, TEXT("IsFriend"))) /* ONLINE (EOS if using EOSPlus) FRIENDS IsFriend 0 "FriendUserId|FullStr" default/onlinePlayers/inGamePlayers/inGameAndSessionPlayers */
+	{
+		int LocalUserNum = FCString::Atoi(*FParse::Token(Cmd, false));
+
+		FString FriendUserIdStr = FParse::Token(Cmd, false);
+		FUniqueNetIdEOSRef FriendEosId = FUniqueNetIdEOS::Create(FriendUserIdStr);
+
+		FString FriendsList = FParse::Token(Cmd, false);
+
+		bool bIsFriend = IsFriend(LocalUserNum, *FriendEosId, FriendsList);
+		UE_LOG_ONLINE_FRIEND(Log, TEXT("UserId=%s bIsFriend=%s"), *FriendUserIdStr, *LexToString(bIsFriend));
+	}
+	else
+	{
+		UE_LOG_ONLINE_FRIEND(Warning, TEXT("Unknown FRIENDS command: %s"), *FParse::Token(Cmd, true));
+		bWasHandled = false;
+	}
+
+	return bWasHandled;
+#else
+	return false;
+#endif // !UE_BUILD_SHIPPING
+}
+
+// ~IOnlineFriends Interface
+
+struct FPresenceStrings
+{
+	FPresenceStrings(const FString& InKey, const FString& InValue)
+		: Key(*InKey), Value(*InValue)
+	{
+	}
+	FTCHARToUTF8 Key;
+	FTCHARToUTF8 Value;
+};
+
+struct FRichTextOptions :
+	public EOS_PresenceModification_SetRawRichTextOptions
+{
+	FRichTextOptions() :
+		EOS_PresenceModification_SetRawRichTextOptions()
+	{
+		ApiVersion = EOS_PRESENCE_SETRAWRICHTEXT_API_LATEST;
+		RichText = RichTextAnsi;
+	}
+	char RichTextAnsi[EOS_PRESENCE_RICH_TEXT_MAX_VALUE_LENGTH];
+};
+
+typedef TEOSCallback<EOS_Presence_SetPresenceCompleteCallback, EOS_Presence_SetPresenceCallbackInfo> FSetPresenceCallback;
+
+void FUserManagerEOS::SetPresence(const FUniqueNetId& UserId, const FOnlineUserPresenceStatus& Status, const FOnPresenceTaskCompleteDelegate& Delegate)
+{
+	const FUniqueNetIdEOS& EOSID = FUniqueNetIdEOS::Cast(UserId);
+	if (!StringToAccountIdMap.Contains(EOSID.UniqueNetIdStr))
+	{
+		UE_LOG_ONLINE(Error, TEXT("Can't SetPresence() for user (%s) since they are not logged in"), *EOSID.UniqueNetIdStr);
+		return;
+	}
+
+	EOS_HPresenceModification ChangeHandle = nullptr;
+	EOS_Presence_CreatePresenceModificationOptions Options = { };
+	Options.ApiVersion = EOS_PRESENCE_CREATEPRESENCEMODIFICATION_API_LATEST;
+	Options.LocalUserId = StringToAccountIdMap[EOSID.UniqueNetIdStr];
+	EOS_Presence_CreatePresenceModification(EOSSubsystem->PresenceHandle, &Options, &ChangeHandle);
+	if (ChangeHandle == nullptr)
+	{
+		UE_LOG_ONLINE(Error, TEXT("Failed to create a modification handle for setting presence"));
+		return;
+	}
+
+	EOS_PresenceModification_SetStatusOptions StatusOptions = { };
+	StatusOptions.ApiVersion = EOS_PRESENCE_SETSTATUS_API_LATEST;
+	StatusOptions.Status = ToEOS_Presence_EStatus(Status.State);
+	EOS_EResult SetStatusResult = EOS_PresenceModification_SetStatus(ChangeHandle, &StatusOptions);
+	if (SetStatusResult != EOS_EResult::EOS_Success)
+	{
+		UE_LOG_ONLINE(Error, TEXT("EOS_PresenceModification_SetStatus() failed with result code (%d)"), (int32)SetStatusResult);
+	}
+
+	// Convert the status string as the rich text string
+	FRichTextOptions TextOptions;
+	FCStringAnsi::Strncpy(TextOptions.RichTextAnsi, TCHAR_TO_UTF8(*Status.StatusStr), EOS_PRESENCE_RICH_TEXT_MAX_VALUE_LENGTH);
+	EOS_EResult SetRichTextResult = EOS_PresenceModification_SetRawRichText(ChangeHandle, &TextOptions);
+	if (SetRichTextResult != EOS_EResult::EOS_Success)
+	{
+		UE_LOG_ONLINE(Error, TEXT("EOS_PresenceModification_SetRawRichText() failed with result code (%s)"), ANSI_TO_TCHAR(EOS_EResult_ToString(SetRichTextResult)));
+	}
+
+	TArray<FPresenceStrings, TInlineAllocator<EOS_PRESENCE_DATA_MAX_KEYS>> RawStrings;
+	TArray<EOS_Presence_DataRecord, TInlineAllocator<EOS_PRESENCE_DATA_MAX_KEYS>> Records;
+	int32 CurrentIndex = 0;
+	// Loop through the properties building records
+	for (FPresenceProperties::TConstIterator It(Status.Properties); It && CurrentIndex < EOS_PRESENCE_DATA_MAX_KEYS; ++It, ++CurrentIndex)
+	{
+		const FPresenceStrings& RawString = RawStrings.Emplace_GetRef(It.Key(), It.Value().ToString());
+
+		EOS_Presence_DataRecord& Record = Records.Emplace_GetRef();
+		Record.ApiVersion = EOS_PRESENCE_DATARECORD_API_LATEST;
+		Record.Key = RawString.Key.Get();
+		Record.Value = RawString.Value.Get();
+	}
+	EOS_PresenceModification_SetDataOptions DataOptions = { };
+	DataOptions.ApiVersion = EOS_PRESENCE_SETDATA_API_LATEST;
+	DataOptions.RecordsCount = Records.Num();
+	DataOptions.Records = Records.GetData();
+	EOS_EResult SetDataResult = EOS_PresenceModification_SetData(ChangeHandle, &DataOptions);
+	if (SetDataResult != EOS_EResult::EOS_Success)
+	{
+		UE_LOG_ONLINE(Error, TEXT("EOS_PresenceModification_SetData() failed with result code (%s)"), ANSI_TO_TCHAR(EOS_EResult_ToString(SetDataResult)));
+	}
+
+	FSetPresenceCallback* CallbackObj = new FSetPresenceCallback();
+	CallbackObj->CallbackLambda = [this, Delegate](const EOS_Presence_SetPresenceCallbackInfo* Data)
+	{
+		if (Data->ResultCode == EOS_EResult::EOS_Success && AccountIdToStringMap.Contains(Data->LocalUserId))
+		{
+			FUniqueNetIdEOSRef EOSID = FUniqueNetIdEOS::Create(AccountIdToStringMap[Data->LocalUserId]);
+			Delegate.ExecuteIfBound(*EOSID, true);
+			return;
+		}
+		UE_LOG_ONLINE(Error, TEXT("SetPresence() failed with result code (%s)"), ANSI_TO_TCHAR(EOS_EResult_ToString(Data->ResultCode)));
+		Delegate.ExecuteIfBound(*FUniqueNetIdEOS::EmptyId(), false);
+	};
+
+	EOS_Presence_SetPresenceOptions PresOptions = { };
+	PresOptions.ApiVersion = EOS_PRESENCE_SETPRESENCE_API_LATEST;
+	PresOptions.LocalUserId = StringToAccountIdMap[EOSID.UniqueNetIdStr];
+	PresOptions.PresenceModificationHandle = ChangeHandle;
+	// Last step commit the changes
+	EOS_Presence_SetPresence(EOSSubsystem->PresenceHandle, &PresOptions, CallbackObj, CallbackObj->GetCallbackPtr());
+	EOS_PresenceModification_Release(ChangeHandle);
+}
+
+typedef TEOSCallback<EOS_Presence_OnQueryPresenceCompleteCallback, EOS_Presence_QueryPresenceCallbackInfo> FQueryPresenceCallback;
+
+void FUserManagerEOS::QueryPresence(const FUniqueNetId& UserId, const FOnPresenceTaskCompleteDelegate& Delegate)
+{
+	if (DefaultLocalUser < 0)
+	{
+		UE_LOG_ONLINE(Error, TEXT("Can't QueryPresence() due to no users being signed in"));
+		Delegate.ExecuteIfBound(UserId, false);
+		return;
+	}
+
+	const FUniqueNetIdEOS& EOSID = FUniqueNetIdEOS::Cast(UserId);
+	const FString& NetId = EOSID.UniqueNetIdStr;
+	if (!StringToAccountIdMap.Contains(NetId))
+	{
+		UE_LOG_ONLINE(Error, TEXT("Can't QueryPresence(%s) for unknown unique net id"), *NetId);
+		Delegate.ExecuteIfBound(UserId, false);
+		return;
+	}
+
+	EOS_Presence_HasPresenceOptions HasOptions = { };
+	HasOptions.ApiVersion = EOS_PRESENCE_HASPRESENCE_API_LATEST;
+	HasOptions.LocalUserId = UserNumToAccountIdMap[DefaultLocalUser];
+	HasOptions.TargetUserId = StringToAccountIdMap[NetId];
+	EOS_Bool bHasPresence = EOS_Presence_HasPresence(EOSSubsystem->PresenceHandle, &HasOptions);
+	if (bHasPresence == EOS_FALSE)
+	{
+		FQueryPresenceCallback* CallbackObj = new FQueryPresenceCallback();
+		CallbackObj->CallbackLambda = [this, Delegate](const EOS_Presence_QueryPresenceCallbackInfo* Data)
+		{
+			if (Data->ResultCode == EOS_EResult::EOS_Success && EpicAccountIdToOnlineUserMap.Contains(Data->TargetUserId))
+			{
+				// Update the presence data to the most recent
+				UpdatePresence(Data->TargetUserId);
+				FOnlineUserPtr OnlineUser = EpicAccountIdToOnlineUserMap[Data->TargetUserId];
+				Delegate.ExecuteIfBound(*OnlineUser->GetUserId(), true);
+				return;
+			}
+			const FString& TargetUser = MakeNetIdStringFromIds(Data->TargetUserId, nullptr);
+			UE_LOG_ONLINE(Error, TEXT("QueryPresence() for user (%s) failed with result code (%s)"), *TargetUser, ANSI_TO_TCHAR(EOS_EResult_ToString(Data->ResultCode)));
+			Delegate.ExecuteIfBound(*FUniqueNetIdEOS::EmptyId(), false);
+		};
+
+		// Query for updated presence
+		EOS_Presence_QueryPresenceOptions Options = { };
+		Options.ApiVersion = EOS_PRESENCE_QUERYPRESENCE_API_LATEST;
+		Options.LocalUserId = HasOptions.LocalUserId;
+		Options.TargetUserId = HasOptions.TargetUserId;
+		EOS_Presence_QueryPresence(EOSSubsystem->PresenceHandle, &Options, CallbackObj, CallbackObj->GetCallbackPtr());
+		return;
+	}
+
+	// Update the presence data to the most recent
+	UpdatePresence(HasOptions.TargetUserId);
+	// It's already present so trigger that it's done
+	Delegate.ExecuteIfBound(UserId, true);
+}
+
+void FUserManagerEOS::UpdatePresence(EOS_EpicAccountId AccountId)
+{
+	EOS_Presence_Info* PresenceInfo = nullptr;
+	EOS_Presence_CopyPresenceOptions Options = { };
+	Options.ApiVersion = EOS_PRESENCE_COPYPRESENCE_API_LATEST;
+	Options.LocalUserId = UserNumToAccountIdMap[DefaultLocalUser];
+	Options.TargetUserId = AccountId;
+	EOS_EResult CopyResult = EOS_Presence_CopyPresence(EOSSubsystem->PresenceHandle, &Options, &PresenceInfo);
+	if (CopyResult == EOS_EResult::EOS_Success)
+	{
+		const FString& NetId = AccountIdToStringMap[AccountId];
+		// Create it on demand if we don't have one yet
+		if (!NetIdStringToOnlineUserPresenceMap.Contains(NetId))
+		{
+			FOnlineUserPresenceRef PresenceRef = MakeShareable(new FOnlineUserPresence());
+			NetIdStringToOnlineUserPresenceMap.Emplace(NetId, PresenceRef);
+		}
+
+		FOnlineUserPresenceRef PresenceRef = NetIdStringToOnlineUserPresenceMap[NetId];
+		const FString ProductId(UTF8_TO_TCHAR(PresenceInfo->ProductId));
+		const FString ProdVersion(UTF8_TO_TCHAR(PresenceInfo->ProductVersion));
+		const FString Platform(UTF8_TO_TCHAR(PresenceInfo->Platform));
+		// Convert the presence data to our format
+		PresenceRef->Status.State = ToEOnlinePresenceState(PresenceInfo->Status);
+		PresenceRef->Status.StatusStr = UTF8_TO_TCHAR(PresenceInfo->RichText);
+		PresenceRef->bIsOnline = PresenceRef->Status.State == EOnlinePresenceState::Online;
+		PresenceRef->bIsPlaying = !ProductId.IsEmpty();
+		PresenceRef->bIsPlayingThisGame = ProductId == EOSSubsystem->ProductId && ProdVersion == EOSSubsystem->EOSSDKManager->GetProductVersion();
+//		PresenceRef->bIsJoinable = ???;
+//		PresenceRef->bHasVoiceSupport = ???;
+		PresenceRef->Status.Properties.Add(TEXT("ProductId"), ProductId);
+		PresenceRef->Status.Properties.Add(TEXT("ProductVersion"), ProdVersion);
+		PresenceRef->Status.Properties.Add(TEXT("Platform"), Platform);
+		for (int32 Index = 0; Index < PresenceInfo->RecordsCount; Index++)
+		{
+			const EOS_Presence_DataRecord& Record = PresenceInfo->Records[Index];
+			PresenceRef->Status.Properties.Add(Record.Key, UTF8_TO_TCHAR(Record.Value));
+		}
+
+		// Copy the presence if this is a friend that was updated, so that their data is in sync
+		UpdateFriendPresence(NetId, PresenceRef);
+
+		EOS_Presence_Info_Release(PresenceInfo);
+	}
+	else
+	{
+		UE_LOG_ONLINE(Error, TEXT("Failed to copy presence data with error code (%s)"), ANSI_TO_TCHAR(EOS_EResult_ToString(CopyResult)));
+	}
+}
+
+void FUserManagerEOS::UpdateFriendPresence(const FString& FriendId, FOnlineUserPresenceRef Presence)
+{
+	for (TMap<int32, FFriendsListEOSRef>::TConstIterator It(LocalUserNumToFriendsListMap); It; ++It)
+	{
+		FFriendsListEOSRef FriendsList = It.Value();
+		FOnlineFriendEOSPtr Friend = FriendsList->GetByNetIdString(FriendId);
+		if (Friend.IsValid())
+		{
+			Friend->SetPresence(Presence);
+		}
+	}
+}
+
+EOnlineCachedResult::Type FUserManagerEOS::GetCachedPresence(const FUniqueNetId& UserId, TSharedPtr<FOnlineUserPresence>& OutPresence)
+{
+	const FUniqueNetIdEOS& EOSID = FUniqueNetIdEOS::Cast(UserId);
+	if (NetIdStringToOnlineUserPresenceMap.Contains(EOSID.UniqueNetIdStr))
+	{
+		OutPresence = NetIdStringToOnlineUserPresenceMap[EOSID.UniqueNetIdStr];
+		return EOnlineCachedResult::Success;
+	}
+	return EOnlineCachedResult::NotFound;
+}
+
+EOnlineCachedResult::Type FUserManagerEOS::GetCachedPresenceForApp(const FUniqueNetId&, const FUniqueNetId& UserId, const FString&, TSharedPtr<FOnlineUserPresence>& OutPresence)
+{
+	return GetCachedPresence(UserId, OutPresence);
+}
+
+bool FUserManagerEOS::QueryUserInfo(int32 LocalUserNum, const TArray<FUniqueNetIdRef>& UserIds)
+{
+	TArray<FString> UserEasIdsNeedingExternalMappings;
+	UserEasIdsNeedingExternalMappings.Reserve(UserIds.Num());
+	
+	// Trigger a query for each user in the list
+	for (const FUniqueNetIdRef& NetId : UserIds)
+	{
+		const FUniqueNetIdEOS& EOSID = FUniqueNetIdEOS::Cast(*NetId);
+		// Skip querying for local users since we already have that data
+		if (StringToUserAccountMap.Contains(EOSID.UniqueNetIdStr))
+		{
+			continue;
+		}
+		// Check to see if we know about this user or not
+		if (StringToAccountIdMap.Contains(EOSID.UniqueNetIdStr))
+		{
+			EOS_EpicAccountId AccountId = StringToAccountIdMap[EOSID.UniqueNetIdStr];
+			ReadUserInfo(LocalUserNum, AccountId);
+		}
+		else
+		{
+			// We need to build this one from the string
+			EOS_EpicAccountId AccountId = EOS_EpicAccountId_FromString(TCHAR_TO_UTF8(*EOSID.EpicAccountIdStr));
+			if (EOS_EpicAccountId_IsValid(AccountId) == EOS_TRUE)
+			{
+				UserEasIdsNeedingExternalMappings.Add(EOSID.EpicAccountIdStr);
+				
+				// Registering the player will also query the user info data
+				AddRemotePlayer(LocalUserNum, EOSID.UniqueNetIdStr, AccountId);
+			}
+		}
+	}
+
+	const FUniqueNetIdEOSPtr LocalId = GetLocalUniqueNetIdEOS(LocalUserNum);
+	QueryExternalIdMappings(*LocalId, FExternalIdQueryOptions(), UserEasIdsNeedingExternalMappings, IgnoredMappingDelegate);
+	
+	return true;
+}
+
+typedef TEOSCallback<EOS_UserInfo_OnQueryUserInfoCallback, EOS_UserInfo_QueryUserInfoCallbackInfo> FReadUserInfoCallback;
+
+void FUserManagerEOS::ReadUserInfo(int32 LocalUserNum, EOS_EpicAccountId EpicAccountId)
+{
+	FReadUserInfoCallback* CallbackObj = new FReadUserInfoCallback();
+	CallbackObj->CallbackLambda = [this, LocalUserNum, EpicAccountId](const EOS_UserInfo_QueryUserInfoCallbackInfo* Data)
+	{
+		if (Data->ResultCode == EOS_EResult::EOS_Success)
+		{
+			IAttributeAccessInterfaceRef AttributeAccessRef = EpicAccountIdToAttributeAccessMap[Data->TargetUserId];
+			UpdateUserInfo(AttributeAccessRef, Data->LocalUserId, Data->TargetUserId);
+		}
+
+		// We mark this player as processed
+		IsFriendQueryUserInfoOngoingForLocalUserMap[LocalUserNum].RemoveSwap(EpicAccountId, false);
+
+		ProcessReadFriendsListComplete(LocalUserNum, true, TEXT(""));
+	};
+
+	EOS_UserInfo_QueryUserInfoOptions Options = { };
+	Options.ApiVersion = EOS_USERINFO_QUERYUSERINFO_API_LATEST;
+	Options.LocalUserId = UserNumToAccountIdMap[DefaultLocalUser];
+	Options.TargetUserId = EpicAccountId;
+	EOS_UserInfo_QueryUserInfo(EOSSubsystem->UserInfoHandle, &Options, CallbackObj, CallbackObj->GetCallbackPtr());
+
+	// We mark this player as pending for processing
+	IsFriendQueryUserInfoOngoingForLocalUserMap.FindOrAdd(LocalUserNum).Add(EpicAccountId);
+}
+
+bool FUserManagerEOS::GetAllUserInfo(int32 LocalUserNum, TArray<TSharedRef<FOnlineUser>>& OutUsers)
+{
+	OutUsers.Reset();
+	// Get remote users
+	for (TMap<FString, FOnlineUserPtr>::TConstIterator It(NetIdStringToOnlineUserMap); It; ++It)
+	{
+		if (It.Value().IsValid())
+		{
+			OutUsers.Add(It.Value().ToSharedRef());
+		}
+	}
+	// Get local users
+	for (TMap<FString, FUserOnlineAccountEOSRef>::TConstIterator It(StringToUserAccountMap); It; ++It)
+	{
+		OutUsers.Add(It.Value());
+	}
+	return true;
+}
+
+TSharedPtr<FOnlineUser> FUserManagerEOS::GetUserInfo(int32 LocalUserNum, const FUniqueNetId& UserId)
+{
+	TSharedPtr<FOnlineUser> OnlineUser;
+	const FUniqueNetIdEOS& EOSID = FUniqueNetIdEOS::Cast(UserId);
+	if (NetIdStringToOnlineUserMap.Contains(EOSID.UniqueNetIdStr))
+	{
+		OnlineUser = NetIdStringToOnlineUserMap[EOSID.UniqueNetIdStr];
+	}
+	return OnlineUser;
+}
+
+struct FQueryByDisplayNameOptions :
+	public EOS_UserInfo_QueryUserInfoByDisplayNameOptions
+{
+	FQueryByDisplayNameOptions() :
+		EOS_UserInfo_QueryUserInfoByDisplayNameOptions()
+	{
+		ApiVersion = EOS_USERINFO_QUERYUSERINFOBYDISPLAYNAME_API_LATEST;
+		DisplayName = DisplayNameAnsi;
+	}
+	char DisplayNameAnsi[EOS_OSS_STRING_BUFFER_LENGTH];
+};
+
+typedef TEOSCallback<EOS_UserInfo_OnQueryUserInfoByDisplayNameCallback, EOS_UserInfo_QueryUserInfoByDisplayNameCallbackInfo> FQueryInfoByNameCallback;
+
+bool FUserManagerEOS::QueryUserIdMapping(const FUniqueNetId& UserId, const FString& DisplayNameOrEmail, const FOnQueryUserMappingComplete& Delegate)
+{
+	const FUniqueNetIdEOS& EOSID = FUniqueNetIdEOS::Cast(UserId);
+	const FString& NetId = EOSID.UniqueNetIdStr;
+	if (!StringToAccountIdMap.Contains(NetId))
+	{
+		UE_LOG_ONLINE(Error, TEXT("Specified local user (%s) is not known"), *EOSID.UniqueNetIdStr);
+		Delegate.ExecuteIfBound(false, UserId, DisplayNameOrEmail, *FUniqueNetIdEOS::EmptyId(), FString::Printf(TEXT("Specified local user (%s) is not known"), *EOSID.UniqueNetIdStr));
+		return false;
+	}
+	int32 LocalUserNum = GetLocalUserNumFromUniqueNetId(UserId);
+
+	FQueryInfoByNameCallback* CallbackObj = new FQueryInfoByNameCallback();
+	CallbackObj->CallbackLambda = [LocalUserNum, DisplayNameOrEmail, this, Delegate](const EOS_UserInfo_QueryUserInfoByDisplayNameCallbackInfo* Data)
+	{
+		EOS_EResult Result = Data->ResultCode;
+		if (GetLoginStatus(LocalUserNum) != ELoginStatus::LoggedIn)
+		{
+			// Handle the user logging out while a read is in progress
+			Result = EOS_EResult::EOS_InvalidUser;
+		}
+
+		FString ErrorString;
+		bool bWasSuccessful = Result == EOS_EResult::EOS_Success;
+		if (bWasSuccessful)
+		{
+			const FString NetIdStr = LexToString(Data->TargetUserId);
+			FUniqueNetIdEOSPtr LocalUserId = UserNumToNetIdMap[DefaultLocalUser];
+			if (!EpicAccountIdToOnlineUserMap.Contains(Data->TargetUserId))
+			{
+				// Registering the player will also query the presence/user info data
+				AddRemotePlayer(LocalUserNum, NetIdStr, Data->TargetUserId);
+			}
+
+			Delegate.ExecuteIfBound(true, *LocalUserId, DisplayNameOrEmail, *FUniqueNetIdEOS::Create(NetIdStr), ErrorString);
+		}
+		else
+		{
+			ErrorString = FString::Printf(TEXT("QueryUserIdMapping(%d, '%s') failed with EOS result code (%s)"), DefaultLocalUser, *DisplayNameOrEmail, ANSI_TO_TCHAR(EOS_EResult_ToString(Result)));
+		}
+		Delegate.ExecuteIfBound(false, *FUniqueNetIdEOS::EmptyId(), DisplayNameOrEmail, *FUniqueNetIdEOS::EmptyId(), ErrorString);
+	};
+
+	FQueryByDisplayNameOptions Options;
+	FCStringAnsi::Strncpy(Options.DisplayNameAnsi, TCHAR_TO_UTF8(*DisplayNameOrEmail), EOS_OSS_STRING_BUFFER_LENGTH);
+	Options.LocalUserId = StringToAccountIdMap[NetId];
+	EOS_UserInfo_QueryUserInfoByDisplayName(EOSSubsystem->UserInfoHandle, &Options, CallbackObj, CallbackObj->GetCallbackPtr());
+
+	return true;
+}
+
+struct FQueryByStringIdsOptions :
+	public EOS_Connect_QueryExternalAccountMappingsOptions
+{
+	FQueryByStringIdsOptions(const uint32 InNumStringIds, EOS_ProductUserId InLocalUserId) :
+		EOS_Connect_QueryExternalAccountMappingsOptions()
+	{
+		PointerArray.AddZeroed(InNumStringIds);
+		for (int32 Index = 0; Index < PointerArray.Num(); Index++)
+		{
+			PointerArray[Index] = new char[EOS_CONNECT_EXTERNAL_ACCOUNT_ID_MAX_LENGTH+1];
+		}
+		ApiVersion = EOS_CONNECT_QUERYEXTERNALACCOUNTMAPPINGS_API_LATEST;
+		AccountIdType = EOS_EExternalAccountType::EOS_EAT_EPIC;
+		ExternalAccountIds = (const char**)PointerArray.GetData();
+		ExternalAccountIdCount = InNumStringIds;
+		LocalUserId = InLocalUserId;
+	}
+
+	~FQueryByStringIdsOptions()
+	{
+		for (int32 Index = 0; Index < PointerArray.Num(); Index++)
+		{
+			delete [] PointerArray[Index];
+		}
+	}
+	TArray<char*> PointerArray;
+};
+
+struct FGetAccountMappingOptions :
+	public EOS_Connect_GetExternalAccountMappingsOptions
+{
+	FGetAccountMappingOptions() :
+		EOS_Connect_GetExternalAccountMappingsOptions()
+	{
+		ApiVersion = EOS_CONNECT_GETEXTERNALACCOUNTMAPPINGS_API_LATEST;
+		AccountIdType = EOS_EExternalAccountType::EOS_EAT_EPIC;
+		TargetExternalUserId = AccountId;
+	}
+	char AccountId[EOS_CONNECT_EXTERNAL_ACCOUNT_ID_MAX_LENGTH+1];
+};
+
+typedef TEOSCallback<EOS_Connect_OnQueryExternalAccountMappingsCallback, EOS_Connect_QueryExternalAccountMappingsCallbackInfo> FQueryByStringIdsCallback;
+
+bool FUserManagerEOS::QueryExternalIdMappings(const FUniqueNetId& UserId, const FExternalIdQueryOptions& QueryOptions, const TArray<FString>& ExternalIds, const FOnQueryExternalIdMappingsComplete& Delegate)
+{
+	const FUniqueNetIdEOS& EOSID = FUniqueNetIdEOS::Cast(UserId);
+	if (!StringToProductUserIdMap.Contains(EOSID.UniqueNetIdStr))
+	{
+		Delegate.ExecuteIfBound(false, UserId, QueryOptions, ExternalIds, FString::Printf(TEXT("User (%s) is not logged in, so can't query external account ids"), *EOSID.UniqueNetIdStr));
+		return false;
+	}
+	int32 LocalUserNum = GetLocalUserNumFromUniqueNetId(UserId);
+
+	// Mark the queries as in progress
+	IsPlayerQueryExternalMappingsOngoingForLocalUserMap.FindOrAdd(LocalUserNum).Append(ExternalIds);
+
+	EOS_ProductUserId LocalUserId = StringToProductUserIdMap[EOSID.UniqueNetIdStr];
+	const int32 NumBatches = (ExternalIds.Num() / EOS_CONNECT_QUERYEXTERNALACCOUNTMAPPINGS_MAX_ACCOUNT_IDS) + 1;
+	int32 QueryStart = 0;
+	// Process queries in batches since there's a max that can be done at once
+	for (int32 BatchCount = 0; BatchCount < NumBatches; BatchCount++)
+	{
+		const uint32 AmountToProcess = FMath::Min(ExternalIds.Num() - QueryStart, EOS_CONNECT_QUERYEXTERNALACCOUNTMAPPINGS_MAX_ACCOUNT_IDS);
+		TArray<FString> BatchIds;
+		BatchIds.Empty(AmountToProcess);
+		FQueryByStringIdsOptions Options(AmountToProcess, LocalUserId);
+		// Build an options up per batch
+		for (uint32 ProcessedCount = 0; ProcessedCount < AmountToProcess; ProcessedCount++, QueryStart++)
+		{
+			FCStringAnsi::Strncpy(Options.PointerArray[ProcessedCount], TCHAR_TO_UTF8(*ExternalIds[ProcessedCount]), EOS_CONNECT_EXTERNAL_ACCOUNT_ID_MAX_LENGTH+1);
+			BatchIds.Add(ExternalIds[ProcessedCount]);
+		}
+		FQueryByStringIdsCallback* CallbackObj = new FQueryByStringIdsCallback();
+		CallbackObj->CallbackLambda = [LocalUserNum, QueryOptions, BatchIds, this, Delegate](const EOS_Connect_QueryExternalAccountMappingsCallbackInfo* Data)
+		{
+			EOS_EResult Result = Data->ResultCode;
+			if (GetLoginStatus(LocalUserNum) != ELoginStatus::LoggedIn)
+			{
+				// Handle the user logging out while a read is in progress
+				Result = EOS_EResult::EOS_InvalidUser;
+			}
+
+			FString ErrorString;
+			FUniqueNetIdEOSPtr EOSID = FUniqueNetIdEOS::EmptyId();
+			if (Result == EOS_EResult::EOS_Success)
+			{
+				EOSID = UserNumToNetIdMap[LocalUserNum];
+
+				FGetAccountMappingOptions Options;
+				Options.LocalUserId = UserNumToProductUserIdMap[DefaultLocalUser];
+				// Get the product id for each epic account passed in
+				for (const FString& StringId : BatchIds)
+				{
+					FCStringAnsi::Strncpy(Options.AccountId, TCHAR_TO_UTF8(*StringId), EOS_CONNECT_EXTERNAL_ACCOUNT_ID_MAX_LENGTH+1);
+					EOS_ProductUserId ProductUserId = EOS_Connect_GetExternalAccountMapping(EOSSubsystem->ConnectHandle, &Options);
+					if (EOS_ProductUserId_IsValid(ProductUserId) == EOS_TRUE)
+					{
+						EOS_EpicAccountId AccountId = EOS_EpicAccountId_FromString(Options.AccountId);
+						UpdateRemotePlayerProductUserId(AccountId, ProductUserId);
+					}
+				}
+			}
+			else
+			{
+				ErrorString = FString::Printf(TEXT("EOS_Connect_QueryExternalAccountMappings() failed with result code (%s)"), ANSI_TO_TCHAR(EOS_EResult_ToString(Result)));
+			}
+
+			// Mark all queries as complete
+			TArray<FString>& OngoingQueries = IsPlayerQueryExternalMappingsOngoingForLocalUserMap[LocalUserNum];
+			for (const FString& StringId : BatchIds)
+			{
+				OngoingQueries.RemoveSwap(StringId, false);
+			}
+			
+			const bool bWasSuccessful = Result == EOS_EResult::EOS_Success;
+			Delegate.ExecuteIfBound(bWasSuccessful, *EOSID, QueryOptions, BatchIds, ErrorString);
+		};
+
+		EOS_Connect_QueryExternalAccountMappings(EOSSubsystem->ConnectHandle, &Options, CallbackObj, CallbackObj->GetCallbackPtr());
+	}
+	return true;
+}
+
+void FUserManagerEOS::GetExternalIdMappings(const FExternalIdQueryOptions& QueryOptions, const TArray<FString>& ExternalIds, TArray<FUniqueNetIdPtr>& OutIds)
+{
+	OutIds.Reset();
+	for (const FString& AccountIdStr : ExternalIds)
+	{
+		OutIds.Add(GetExternalIdMapping(QueryOptions, AccountIdStr));
+	}
+}
+
+FUniqueNetIdPtr FUserManagerEOS::GetExternalIdMapping(const FExternalIdQueryOptions& QueryOptions, const FString& ExternalId)
+{
+	FUniqueNetIdPtr NetId;
+	EOS_EpicAccountId AccountId = EOS_EpicAccountId_FromString(TCHAR_TO_UTF8(*ExternalId));
+	if (EOS_EpicAccountId_IsValid(AccountId) == EOS_TRUE && AccountIdToStringMap.Contains(AccountId))
+	{
+		const FString& NetIdStr = AccountIdToStringMap[AccountId];
+		NetId = NetIdStringToOnlineUserMap[NetIdStr]->GetUserId();
+	}
+	return NetId;
+}
+
+#endif
\ No newline at end of file
Index: Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Public/OnlineSubsystemEOSModule.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Public/OnlineSubsystemEOSModule.h b/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Public/OnlineSubsystemEOSModule.h
new file mode 100644
--- /dev/null	(date 1641575208000)
+++ b/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Public/OnlineSubsystemEOSModule.h	(date 1641575208000)
@@ -0,0 +1,45 @@
+// Copyright Epic Games, Inc. All Rights Reserved.
+
+#pragma once
+
+#include "CoreMinimal.h"
+#include "Modules/ModuleInterface.h"
+
+/**
+ * Online subsystem module class  (EOS Implementation)
+ * Code related to the loading of the EOS module
+ */
+class FOnlineSubsystemEOSModule : public IModuleInterface
+{
+private:
+
+	/** Class responsible for creating instance(s) of the subsystem */
+	class FOnlineFactoryEOS* EOSFactory;
+
+public:
+
+	FOnlineSubsystemEOSModule() :
+		EOSFactory(NULL)
+	{}
+
+	virtual ~FOnlineSubsystemEOSModule() {}
+
+#if WITH_EDITOR
+	void OnPostEngineInit();
+	void OnPreExit();
+#endif
+
+	// IModuleInterface
+
+	virtual void StartupModule() override;
+	virtual void ShutdownModule() override;
+	virtual bool SupportsDynamicReloading() override
+	{
+		return false;
+	}
+
+	virtual bool SupportsAutomaticShutdown() override
+	{
+		return false;
+	}
+};
Index: Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Public/OnlineSubsystemEOS.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Public/OnlineSubsystemEOS.h b/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Public/OnlineSubsystemEOS.h
new file mode 100644
--- /dev/null	(date 1641576012000)
+++ b/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Public/OnlineSubsystemEOS.h	(date 1641576012000)
@@ -0,0 +1,218 @@
+// Copyright Epic Games, Inc. All Rights Reserved.
+
+#pragma once
+
+#include "CoreMinimal.h"
+#include "OnlineSubsystemNames.h"
+#include "OnlineSubsystemImpl.h"
+#include "SocketSubsystemEOS.h"
+
+#include COMPILED_PLATFORM_HEADER(EOSHelpers.h)
+
+DECLARE_STATS_GROUP(TEXT("EOS"), STATGROUP_EOS, STATCAT_Advanced);
+
+#if WITH_EOS_SDK
+
+#include "eos_sdk.h"
+
+class IEOSSDKManager;
+using IEOSPlatformHandlePtr = TSharedPtr<class IEOSPlatformHandle, ESPMode::ThreadSafe>;
+
+class IVoiceChatUser;
+class FEOSVoiceChatUser;
+using IVoiceChatPtr = TSharedPtr<class IVoiceChat, ESPMode::ThreadSafe>;
+using FOnlineSubsystemEOSVoiceChatUserWrapperRef = TSharedRef<class FOnlineSubsystemEOSVoiceChatUserWrapper, ESPMode::ThreadSafe>;
+
+class FUserManagerEOS;
+typedef TSharedPtr<class FUserManagerEOS, ESPMode::ThreadSafe> FUserManagerEOSPtr;
+
+class FOnlineSessionEOS;
+typedef TSharedPtr<class FOnlineSessionEOS, ESPMode::ThreadSafe> FOnlineSessionEOSPtr;
+
+class FOnlineStatsEOS;
+typedef TSharedPtr<class FOnlineStatsEOS, ESPMode::ThreadSafe> FOnlineStatsEOSPtr;
+
+class FOnlineLeaderboardsEOS;
+typedef TSharedPtr<class FOnlineLeaderboardsEOS, ESPMode::ThreadSafe> FOnlineLeaderboardsEOSPtr;
+
+class FOnlineAchievementsEOS;
+typedef TSharedPtr<class FOnlineAchievementsEOS, ESPMode::ThreadSafe> FOnlineAchievementsEOSPtr;
+
+class FOnlineStoreEOS;
+typedef TSharedPtr<class FOnlineStoreEOS, ESPMode::ThreadSafe> FOnlineStoreEOSPtr;
+
+class FOnlineTitleFileEOS;
+typedef TSharedPtr<class FOnlineTitleFileEOS, ESPMode::ThreadSafe> FOnlineTitleFileEOSPtr;
+
+class FOnlineUserCloudEOS;
+typedef TSharedPtr<class FOnlineUserCloudEOS, ESPMode::ThreadSafe> FOnlineUserCloudEOSPtr;
+
+typedef TSharedPtr<FPlatformEOSHelpers, ESPMode::ThreadSafe> FPlatformEOSHelpersPtr;
+
+/**
+ *	OnlineSubsystemEOS - Implementation of the online subsystem for EOS services
+ */
+class ONLINESUBSYSTEMEOS_API FOnlineSubsystemEOS : 
+	public FOnlineSubsystemImpl
+{
+public:
+	virtual ~FOnlineSubsystemEOS() = default;
+
+	/** Used to be called before RHIInit() */
+	static void ModuleInit();
+	static void ModuleShutdown();
+
+
+	FPlatformEOSHelpersPtr GetEOSHelpers() { return EOSHelpersPtr; };
+
+// IOnlineSubsystem
+	virtual IOnlineSessionPtr GetSessionInterface() const override;
+	virtual IOnlineFriendsPtr GetFriendsInterface() const override;
+	virtual IOnlineSharedCloudPtr GetSharedCloudInterface() const override;
+	virtual IOnlineUserCloudPtr GetUserCloudInterface() const override;
+	virtual IOnlineEntitlementsPtr GetEntitlementsInterface() const override;
+	virtual IOnlineLeaderboardsPtr GetLeaderboardsInterface() const override;
+	virtual IOnlineVoicePtr GetVoiceInterface() const override;
+	virtual IOnlineExternalUIPtr GetExternalUIInterface() const override;	
+	virtual IOnlineIdentityPtr GetIdentityInterface() const override;
+	virtual IOnlineTitleFilePtr GetTitleFileInterface() const override;
+	virtual IOnlineStoreV2Ptr GetStoreV2Interface() const override;
+	virtual IOnlinePurchasePtr GetPurchaseInterface() const override;
+	virtual IOnlineAchievementsPtr GetAchievementsInterface() const override;
+	virtual IOnlineUserPtr GetUserInterface() const override;
+	virtual IOnlinePresencePtr GetPresenceInterface() const override;
+	virtual FText GetOnlineServiceName() const override;
+	virtual IOnlineStatsPtr GetStatsInterface() const override;
+	virtual bool Exec(class UWorld* InWorld, const TCHAR* Cmd, FOutputDevice& Ar) override;
+	virtual void ReloadConfigs(const TSet<FString>& ConfigSections) override;
+
+	virtual IOnlineGroupsPtr GetGroupsInterface() const override { return nullptr; }
+	virtual IOnlinePartyPtr GetPartyInterface() const override { return nullptr; }
+	virtual IOnlineTimePtr GetTimeInterface() const override { return nullptr; }
+	virtual IOnlineEventsPtr GetEventsInterface() const override { return nullptr; }
+	virtual IOnlineSharingPtr GetSharingInterface() const override { return nullptr; }
+	virtual IOnlineMessagePtr GetMessageInterface() const override { return nullptr; }
+	virtual IOnlineChatPtr GetChatInterface() const override { return nullptr; }
+	virtual IOnlineTurnBasedPtr GetTurnBasedInterface() const override { return nullptr; }
+	virtual IOnlineTournamentPtr GetTournamentInterface() const override { return nullptr; }
+//~IOnlineSubsystem
+
+	virtual bool Init() override;
+	virtual bool Shutdown() override;
+	virtual FString GetAppId() const override;
+
+// FTSTickerObjectBase
+	virtual bool Tick(float DeltaTime) override;
+
+	IVoiceChatUser* GetVoiceChatUserInterface(const FUniqueNetId& LocalUserId);
+
+PACKAGE_SCOPE:
+	/** Only the factory makes instances */
+	FOnlineSubsystemEOS() = delete;
+	explicit FOnlineSubsystemEOS(FName InInstanceName);
+
+	FString ProductId;
+
+	IEOSSDKManager* EOSSDKManager;
+
+	/** EOS handles */
+	IEOSPlatformHandlePtr EOSPlatformHandle;
+	EOS_HAuth AuthHandle;
+	EOS_HUI UIHandle;
+	EOS_HFriends FriendsHandle;
+	EOS_HUserInfo UserInfoHandle;
+	EOS_HPresence PresenceHandle;
+	EOS_HConnect ConnectHandle;
+	EOS_HSessions SessionsHandle;
+	EOS_HStats StatsHandle;
+	EOS_HLeaderboards LeaderboardsHandle;
+	EOS_HMetrics MetricsHandle;
+	EOS_HAchievements AchievementsHandle;
+	EOS_HP2P P2PHandle;
+	EOS_HEcom EcomHandle;
+	EOS_HTitleStorage TitleStorageHandle;
+	EOS_HPlayerDataStorage PlayerDataStorageHandle;
+
+	/** Manager that handles all user interfaces */
+	FUserManagerEOSPtr UserManager;
+	/** The session interface object */
+	FOnlineSessionEOSPtr SessionInterfacePtr;
+	/** Stats interface pointer */
+	FOnlineStatsEOSPtr StatsInterfacePtr;
+	/** Leaderboards interface pointer */
+	FOnlineLeaderboardsEOSPtr LeaderboardsInterfacePtr;
+	FOnlineAchievementsEOSPtr AchievementsInterfacePtr;
+	/** EGS store interface pointer */
+	FOnlineStoreEOSPtr StoreInterfacePtr;
+	/** Title File interface pointer */
+	FOnlineTitleFileEOSPtr TitleFileInterfacePtr;
+	/** User Cloud interface pointer */
+	FOnlineUserCloudEOSPtr UserCloudInterfacePtr;
+
+	bool bWasLaunchedByEGS;
+	bool bIsDefaultOSS;
+	bool bIsPlatformOSS;
+
+	TSharedPtr<FSocketSubsystemEOS, ESPMode::ThreadSafe> SocketSubsystem;
+
+	static FPlatformEOSHelpersPtr EOSHelpersPtr;
+
+	FEOSVoiceChatUser* GetEOSVoiceChatUserInterface(const FUniqueNetId& LocalUserId);
+	void ReleaseVoiceChatUserInterface(const FUniqueNetId& LocalUserId);
+
+private:
+	bool PlatformCreate();
+
+	IVoiceChatPtr VoiceChatInterface;
+	TUniqueNetIdMap<FOnlineSubsystemEOSVoiceChatUserWrapperRef> LocalVoiceChatUsers;
+};
+
+#else
+
+class ONLINESUBSYSTEMEOS_API FOnlineSubsystemEOS :
+	public FOnlineSubsystemImpl
+{
+public:
+	explicit FOnlineSubsystemEOS(FName InInstanceName) :
+		FOnlineSubsystemImpl(EOS_SUBSYSTEM, InInstanceName)
+	{
+	}
+
+	virtual ~FOnlineSubsystemEOS() = default;
+
+	virtual IOnlineSessionPtr GetSessionInterface() const override { return nullptr; }
+	virtual IOnlineFriendsPtr GetFriendsInterface() const override { return nullptr; }
+	virtual IOnlineGroupsPtr GetGroupsInterface() const override { return nullptr; }
+	virtual IOnlinePartyPtr GetPartyInterface() const override { return nullptr; }
+	virtual IOnlineSharedCloudPtr GetSharedCloudInterface() const override { return nullptr; }
+	virtual IOnlineUserCloudPtr GetUserCloudInterface() const override { return nullptr; }
+	virtual IOnlineEntitlementsPtr GetEntitlementsInterface() const override { return nullptr; }
+	virtual IOnlineLeaderboardsPtr GetLeaderboardsInterface() const override { return nullptr; }
+	virtual IOnlineVoicePtr GetVoiceInterface() const override { return nullptr; }
+	virtual IOnlineExternalUIPtr GetExternalUIInterface() const override { return nullptr; }
+	virtual IOnlineTimePtr GetTimeInterface() const override { return nullptr; }
+	virtual IOnlineIdentityPtr GetIdentityInterface() const override { return nullptr; }
+	virtual IOnlineTitleFilePtr GetTitleFileInterface() const override { return nullptr; }
+	virtual IOnlineStoreV2Ptr GetStoreV2Interface() const override { return nullptr; }
+	virtual IOnlinePurchasePtr GetPurchaseInterface() const override { return nullptr; }
+	virtual IOnlineEventsPtr GetEventsInterface() const override { return nullptr; }
+	virtual IOnlineAchievementsPtr GetAchievementsInterface() const override { return nullptr; }
+	virtual IOnlineSharingPtr GetSharingInterface() const override { return nullptr; }
+	virtual IOnlineUserPtr GetUserInterface() const override { return nullptr; }
+	virtual IOnlineMessagePtr GetMessageInterface() const override { return nullptr; }
+	virtual IOnlinePresencePtr GetPresenceInterface() const override { return nullptr; }
+	virtual IOnlineChatPtr GetChatInterface() const override { return nullptr; }
+	virtual IOnlineStatsPtr GetStatsInterface() const override { return nullptr; }
+	virtual IOnlineTurnBasedPtr GetTurnBasedInterface() const override { return nullptr; }
+	virtual IOnlineTournamentPtr GetTournamentInterface() const override { return nullptr; }
+	virtual FText GetOnlineServiceName() const override { return NSLOCTEXT("OnlineSubsystemEOS", "OnlineServiceName", "EOS"); }
+
+	virtual bool Init() override { return false; }
+	virtual bool Shutdown() override { return true; }
+	virtual FString GetAppId() const override { return TEXT(""); }
+};
+
+#endif
+
+typedef TSharedPtr<FOnlineSubsystemEOS, ESPMode::ThreadSafe> FOnlineSubsystemEOSPtr;
+
Index: Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Public/EOSSettings.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Public/EOSSettings.h b/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Public/EOSSettings.h
new file mode 100644
--- /dev/null	(date 1641576012000)
+++ b/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Public/EOSSettings.h	(date 1641576012000)
@@ -0,0 +1,173 @@
+// Copyright Epic Games, Inc. All Rights Reserved.
+
+#pragma once
+
+#include "UObject/ObjectMacros.h"
+#include "Engine/RuntimeOptionsBase.h"
+#include "Engine/DataAsset.h"
+#include "EOSSettings.generated.h"
+
+/** Native version of the UObject based config data */
+struct FEOSArtifactSettings
+{
+	FString ArtifactName;
+	FString ClientId;
+	FString ClientSecret;
+	FString ProductId;
+	FString SandboxId;
+	FString DeploymentId;
+	FString EncryptionKey;
+
+	void ParseRawArrayEntry(const FString& RawLine);
+};
+
+UCLASS(Deprecated)
+class UDEPRECATED_EOSArtifactSettings :
+	public UDataAsset
+{
+	GENERATED_BODY()
+
+public:
+	UDEPRECATED_EOSArtifactSettings()
+	{
+	}
+};
+
+USTRUCT(BlueprintType)
+struct FArtifactSettings
+{
+	GENERATED_BODY()
+
+public:
+	/** This needs to match what the launcher passes in the -epicapp command line arg */
+	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category="EOS Settings")
+	FString ArtifactName;
+
+	UPROPERTY(Config, EditAnywhere, BlueprintReadOnly, Category="EOS Artifact Settings")
+	FString ClientId;
+
+	UPROPERTY(Config, EditAnywhere, BlueprintReadOnly, Category="EOS Artifact Settings")
+	FString ClientSecret;
+
+	UPROPERTY(Config, EditAnywhere, BlueprintReadOnly, Category="EOS Artifact Settings")
+	FString ProductId;
+
+	UPROPERTY(Config, EditAnywhere, BlueprintReadOnly, Category="EOS Artifact Settings")
+	FString SandboxId;
+
+	UPROPERTY(Config, EditAnywhere, BlueprintReadOnly, Category="EOS Artifact Settings")
+	FString DeploymentId;
+
+	UPROPERTY(Config, EditAnywhere, BlueprintReadOnly, Category="EOS Artifact Settings")
+	FString EncryptionKey;
+
+	FEOSArtifactSettings ToNative() const;
+};
+
+/** Native version of the UObject based config data */
+struct FEOSSettings
+{
+	FString CacheDir;
+	FString DefaultArtifactName;
+	int32 TickBudgetInMilliseconds;
+	int32 TitleStorageReadChunkLength;
+	bool bEnableOverlay;
+	bool bEnableSocialOverlay;
+	bool bShouldEnforceBeingLaunchedByEGS;
+	bool bUseEAS;
+	bool bUseEOSConnect;
+	bool bUseEOSSessions;
+	bool bMirrorStatsToEOS;
+	bool bMirrorAchievementsToEOS;
+	bool bMirrorPresenceToEAS;
+	TArray<FEOSArtifactSettings> Artifacts;
+	TArray<FString> TitleStorageTags;
+};
+
+UCLASS(Config=Engine, DefaultConfig)
+class ONLINESUBSYSTEMEOS_API UEOSSettings :
+	public URuntimeOptionsBase
+{
+	GENERATED_BODY()
+
+public:
+	/**
+	 * The directory any PDS/TDS files are cached into. This is per artifact e.g.:
+	 *
+	 * <UserDir>/<ArtifactId>/<CacheDir>
+	 */
+	UPROPERTY(Config, EditAnywhere, BlueprintReadOnly, Category="EOS Settings")
+	FString CacheDir = TEXT("CacheDir");
+
+	/** Used when launched from a store other than EGS or when the specified artifact name was not present */
+	UPROPERTY(Config, EditAnywhere, BlueprintReadOnly, Category="EOS Settings")
+	FString DefaultArtifactName;
+
+	/** Used to throttle how much time EOS ticking can take */
+	UPROPERTY(Config, EditAnywhere, BlueprintReadOnly, Category="EOS Settings")
+	int32 TickBudgetInMilliseconds = 0;
+
+	/** Set to true to enable the overlay (ecom features) */
+	UPROPERTY(Config, EditAnywhere, BlueprintReadOnly, Category="EOS Settings")
+	bool bEnableOverlay = false;
+
+	/** Set to true to enable the social overlay (friends, invites, etc.) */
+	UPROPERTY(Config, EditAnywhere, BlueprintReadOnly, Category="EOS Settings")
+	bool bEnableSocialOverlay = false;
+
+	/** Set to true to enable the social overlay (friends, invites, etc.) */
+	UPROPERTY(Config, EditAnywhere, BlueprintReadOnly, Category="EOS Settings", DisplayName="Require Being Launched by the Epic Games Store")
+	bool bShouldEnforceBeingLaunchedByEGS = false;
+
+	/** Tag combinations for paged queries in title file enumerations, separate tags within groups using `+` */
+	UPROPERTY(Config, EditAnywhere, BlueprintReadOnly, Category="EOS Settings")
+	TArray<FString> TitleStorageTags;
+
+	/** Chunk size used when reading a title file */
+	UPROPERTY(Config, EditAnywhere, BlueprintReadOnly, Category="EOS Settings")
+	int32 TitleStorageReadChunkLength = 0;
+
+	/** Per artifact SDK settings. A game might have a FooStaging, FooQA, and public Foo artifact */
+	UPROPERTY(Config, EditAnywhere, BlueprintReadOnly, Category="EOS Settings")
+	TArray<FArtifactSettings> Artifacts;
+
+	/** Set to true to have Epic Accounts used (friends list will be unified with the default platform) */
+	UPROPERTY(Config, EditAnywhere, BlueprintReadOnly, Category="Crossplay Settings", DisplayName="Use Epic Account Services")
+	bool bUseEAS = false;
+
+	/** Set to true to have EOS Connect APIs used to link accounts for crossplay */
+	UPROPERTY(Config, EditAnywhere, BlueprintReadOnly, Category="Crossplay Settings", DisplayName="Use Crossplatform User IDs")
+	bool bUseEOSConnect = false;
+
+	/** Set to true to write stats to EOS as well as the default platform */
+	UPROPERTY(Config, EditAnywhere, BlueprintReadOnly, Category="Crossplay Settings")
+	bool bMirrorStatsToEOS = false;
+
+	/** Set to true to write achievement data to EOS as well as the default platform */
+	UPROPERTY(Config, EditAnywhere, BlueprintReadOnly, Category="Crossplay Settings")
+	bool bMirrorAchievementsToEOS = false;
+
+	/** Set to true to use EOS for session registration with data mirrored to the default platform */
+	UPROPERTY(Config, EditAnywhere, BlueprintReadOnly, Category="Crossplay Settings", DisplayName="Use Crossplay Sessions")
+	bool bUseEOSSessions = false;
+
+	/** Set to true to have Epic Accounts presence information updated when the default platform is updated */
+	UPROPERTY(Config, EditAnywhere, BlueprintReadOnly, Category="Crossplay Settings")
+	bool bMirrorPresenceToEAS = false;
+
+	/** Find the Settings for an artifact by name */
+	static bool GetSettingsForArtifact(const FString& ArtifactName, FEOSArtifactSettings& OutSettings);
+
+	static FEOSSettings GetSettings();
+	FEOSSettings ToNative() const;
+
+private:
+#if WITH_EDITOR
+	virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent) override;
+#endif
+	static bool AutoGetSettingsForArtifact(const FString& ArtifactName, FEOSArtifactSettings& OutSettings);
+	static bool ManualGetSettingsForArtifact(const FString& ArtifactName, FEOSArtifactSettings& OutSettings);
+
+	static FEOSSettings AutoGetSettings();
+	static const FEOSSettings& ManualGetSettings();
+};
\ No newline at end of file
Index: Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Private/NetDriverEOS.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Private/NetDriverEOS.h b/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Private/NetDriverEOS.h
new file mode 100644
--- /dev/null	(date 1641575208000)
+++ b/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Private/NetDriverEOS.h	(date 1641575208000)
@@ -0,0 +1,36 @@
+// Copyright Epic Games, Inc. All Rights Reserved.
+
+#pragma once
+
+#include "CoreMinimal.h"
+#include "IpNetDriver.h"
+#include "NetDriverEOS.generated.h"
+
+class ISocketSubsystem;
+
+UCLASS(Transient, Config=Engine)
+class ONLINESUBSYSTEMEOS_API UNetDriverEOS
+	: public UIpNetDriver
+{
+	GENERATED_BODY()
+
+public:
+//~ Begin UNetDriver Interface
+	virtual bool IsAvailable() const override;
+	virtual bool InitBase(bool bInitAsClient, FNetworkNotify* InNotify, const FURL& URL, bool bReuseAddressAndPort, FString& Error) override;
+	virtual bool InitConnect(FNetworkNotify* InNotify, const FURL& ConnectURL, FString& Error) override;
+	virtual bool InitListen(FNetworkNotify* InNotify, FURL& LocalURL, bool bReuseAddressAndPort, FString& Error) override;
+	virtual ISocketSubsystem* GetSocketSubsystem() override;
+	virtual void Shutdown() override;
+	virtual int GetClientPort() override;
+//~ End UNetDriver Interface
+
+	UWorld* FindWorld() const;
+
+public:
+	UPROPERTY()
+	bool bIsPassthrough;
+
+	UPROPERTY(Config)
+	bool bIsUsingP2PSockets;
+};
Index: Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Private/UserManagerEOS.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Private/UserManagerEOS.h b/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Private/UserManagerEOS.h
new file mode 100644
--- /dev/null	(date 1641576012000)
+++ b/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Private/UserManagerEOS.h	(date 1641576012000)
@@ -0,0 +1,483 @@
+// Copyright Epic Games, Inc. All Rights Reserved.
+
+#pragma once
+
+#include "OnlineSubsystemEOSTypes.h"
+#include "Interfaces/OnlineExternalUIInterface.h"
+
+#if WITH_EOS_SDK
+	#include "eos_auth_types.h"
+	#include "eos_friends_types.h"
+	#include "eos_connect_types.h"
+
+class FOnlineSubsystemEOS;
+class IOnlineSubsystem;
+
+typedef TSharedPtr<FOnlineUser> FOnlineUserPtr;
+typedef TSharedRef<FOnlineUser> FOnlineUserRef;
+
+/**
+* Concrete online user class built from the reusable templates
+*/
+class FOnlineUserEOS :
+	public TOnlineUserEOS<FOnlineUser, IAttributeAccessInterface>
+{
+public:
+	FOnlineUserEOS(FUniqueNetIdEOSRef InUserId) :
+		TOnlineUserEOS<FOnlineUser, IAttributeAccessInterface>(InUserId)
+	{
+	}
+	virtual ~FOnlineUserEOS() = default;
+};
+
+typedef TSharedPtr<FOnlineUserEOS> FOnlineUserEOSPtr;
+typedef TSharedRef<FOnlineUserEOS> FOnlineUserEOSRef;
+
+/**
+ * Info associated with an user account generated by this online service
+ */
+class FUserOnlineAccountEOS : 
+	public TUserOnlineAccountEOS<FUserOnlineAccount>
+{
+public:
+	FUserOnlineAccountEOS(FUniqueNetIdEOSRef InUserId)
+		: TUserOnlineAccountEOS<FUserOnlineAccount>(InUserId)
+	{
+	}
+	virtual ~FUserOnlineAccountEOS() = default;
+};
+
+typedef TSharedPtr<FUserOnlineAccountEOS> FUserOnlineAccountEOSPtr;
+typedef TSharedRef<FUserOnlineAccountEOS> FUserOnlineAccountEOSRef;
+
+/**
+ * Concrete friend class built from the reusable templates
+ */
+class FOnlineFriendEOS :
+	public TOnlineFriendEOS<FOnlineFriend>
+{
+public:
+	FOnlineFriendEOS(FUniqueNetIdEOSRef InUserId) :
+		TOnlineFriendEOS<FOnlineFriend>(InUserId)
+	{
+	}
+	virtual ~FOnlineFriendEOS() = default;
+};
+
+typedef TSharedPtr<FOnlineFriendEOS> FOnlineFriendEOSPtr;
+typedef TSharedRef<FOnlineFriendEOS> FOnlineFriendEOSRef;
+
+/**
+ * Concrete blocked player class built from the reusable templates
+ */
+class FOnlineBlockedPlayerEOS :
+	public TOnlineBlockedPlayerEOS<FOnlineBlockedPlayer>
+{
+public:
+	FOnlineBlockedPlayerEOS(FUniqueNetIdEOSRef InUserId) :
+		TOnlineBlockedPlayerEOS<FOnlineBlockedPlayer>(InUserId)
+	{
+	}
+	virtual ~FOnlineBlockedPlayerEOS() = default;
+};
+
+typedef TSharedPtr<FOnlineBlockedPlayerEOS> FOnlineBlockedPlayerEOSPtr;
+typedef TSharedRef<FOnlineBlockedPlayerEOS> FOnlineBlockedPlayerEOSRef;
+
+/**
+ * Concrete blocked player class built from the reusable templates
+ */
+class FOnlineRecentPlayerEOS :
+	public TOnlineRecentPlayerEOS<FOnlineRecentPlayer>
+{
+public:
+	FOnlineRecentPlayerEOS(FUniqueNetIdEOSRef InUserId) :
+		TOnlineRecentPlayerEOS<FOnlineRecentPlayer>(InUserId)
+	{
+	}
+	virtual ~FOnlineRecentPlayerEOS() = default;
+};
+
+typedef TSharedPtr<FOnlineRecentPlayerEOS> FOnlineRecentPlayerEOSPtr;
+typedef TSharedRef<FOnlineRecentPlayerEOS> FOnlineRecentPlayerEOSRef;
+
+template<class ListClass, class ListClassReturnType>
+class TOnlinePlayerList
+{
+	/** The user that owns this list */
+	int32 LocalUserNum;
+	/** The net id that owns this list */
+	FUniqueNetIdEOSRef OwningNetId;
+	/** The array of list class entries */
+	TArray<ListClass> ListEntries;
+	/** Indexed by string form of account id for fast look up */
+	TMap<FString, ListClass> NetIdStringToListEntryMap;
+
+public:
+	TOnlinePlayerList(int32 InLocalUserNum, FUniqueNetIdEOSRef InOwningNetId)
+		: LocalUserNum(InLocalUserNum)
+		, OwningNetId(InOwningNetId)
+	{
+	}
+
+	const TArray<ListClass>& GetList()
+	{
+		return ListEntries;
+	}
+
+	void Add(const FString& InNetId, ListClass InListEntry)
+	{
+		ListEntries.Add(InListEntry);
+		NetIdStringToListEntryMap.Add(InNetId, InListEntry);
+	}
+
+	void Remove(const FString& InNetId, ListClass InListEntry)
+	{
+		const ListClass* Found = NetIdStringToListEntryMap.Find(InNetId);
+		if (Found != nullptr)
+		{
+			NetIdStringToListEntryMap.Remove(InNetId);
+		}
+		ListEntries.Remove(InListEntry);
+	}
+
+	void Empty(int32 Slack = 0)
+	{
+		ListEntries.Empty(Slack);
+		NetIdStringToListEntryMap.Empty(Slack);
+	}
+
+	void UpdateNetIdStr(const FString& PrevNetId, const FString& NewNetId)
+	{
+		ListClass ListEntry = NetIdStringToListEntryMap[PrevNetId];
+		NetIdStringToListEntryMap.Remove(PrevNetId);
+		NetIdStringToListEntryMap.Add(NewNetId, ListEntry);
+	}
+
+	ListClassReturnType GetByIndex(int32 Index)
+	{
+		if (ListEntries.IsValidIndex(Index))
+		{
+			return ListEntries[Index];
+		}
+		return ListClassReturnType();
+	}
+
+	ListClassReturnType GetByNetIdString(const FString& NetId)
+	{
+		const ListClass* Found = NetIdStringToListEntryMap.Find(NetId);
+		if (Found != nullptr)
+		{
+			return *Found;
+		}
+		return ListClassReturnType();
+	}
+};
+
+class FFriendsListEOS :
+	public TOnlinePlayerList<FOnlineFriendEOSRef, FOnlineFriendEOSPtr>
+{
+public:
+	FFriendsListEOS(int32 InLocalUserNum, FUniqueNetIdEOSRef InOwningNetId)
+		: TOnlinePlayerList<FOnlineFriendEOSRef, FOnlineFriendEOSPtr>(InLocalUserNum, InOwningNetId)
+	{
+	}
+	virtual ~FFriendsListEOS() = default;
+};
+
+typedef TSharedRef<FFriendsListEOS> FFriendsListEOSRef;
+
+class FBlockedPlayersListEOS :
+	public TOnlinePlayerList<FOnlineBlockedPlayerEOSRef, FOnlineBlockedPlayerEOSPtr>
+{
+public:
+	FBlockedPlayersListEOS(int32 InLocalUserNum, FUniqueNetIdEOSRef InOwningNetId)
+		: TOnlinePlayerList<FOnlineBlockedPlayerEOSRef, FOnlineBlockedPlayerEOSPtr>(InLocalUserNum, InOwningNetId)
+	{
+	}
+	virtual ~FBlockedPlayersListEOS() = default;
+};
+
+typedef TSharedRef<FBlockedPlayersListEOS> FBlockedPlayersListEOSRef;
+
+class FRecentPlayersListEOS :
+	public TOnlinePlayerList<FOnlineRecentPlayerEOSRef, FOnlineRecentPlayerEOSPtr>
+{
+public:
+	FRecentPlayersListEOS(int32 InLocalUserNum, FUniqueNetIdEOSRef InOwningNetId)
+		: TOnlinePlayerList<FOnlineRecentPlayerEOSRef, FOnlineRecentPlayerEOSPtr>(InLocalUserNum, InOwningNetId)
+	{
+	}
+	virtual ~FRecentPlayersListEOS() = default;
+};
+
+typedef TSharedRef<FRecentPlayersListEOS> FRecentPlayersListEOSRef;
+
+struct FNotificationIdCallbackPair
+{
+	EOS_NotificationId NotificationId;
+	FCallbackBase* Callback;
+
+	FNotificationIdCallbackPair()
+		: NotificationId(EOS_INVALID_NOTIFICATIONID)
+		, Callback(nullptr)
+	{
+	}
+
+	virtual ~FNotificationIdCallbackPair()
+	{
+		delete Callback;
+	}
+};
+
+/**
+ * EOS service implementation of the online identity, friends, and user info interfaces
+ *
+ * Centrally managed since they share common data
+ */
+class FUserManagerEOS
+	: public IOnlineIdentity
+	, public IOnlineExternalUI
+	, public IOnlineFriends
+	, public IOnlinePresence
+	, public IOnlineUser
+{
+public:
+	/**
+	 * Constructor
+	 *
+	 * @param InSubsystem online subsystem being used
+	 */
+	FUserManagerEOS(FOnlineSubsystemEOS* InSubsystem);
+
+	/**
+	 * Destructor
+	 */
+	virtual ~FUserManagerEOS();
+
+// IOnlineIdentity Interface
+	virtual bool Login(int32 LocalUserNum, const FOnlineAccountCredentials& AccountCredentials) override;
+	virtual bool Logout(int32 LocalUserNum) override;
+	virtual bool AutoLogin(int32 LocalUserNum) override;
+	virtual TSharedPtr<FUserOnlineAccount> GetUserAccount(const FUniqueNetId& UserId) const override;
+	virtual TArray<TSharedPtr<FUserOnlineAccount>> GetAllUserAccounts() const override;
+	virtual FUniqueNetIdPtr GetUniquePlayerId(int32 LocalUserNum) const override;
+	virtual FUniqueNetIdPtr CreateUniquePlayerId(uint8* Bytes, int32 Size) override;
+	virtual FUniqueNetIdPtr CreateUniquePlayerId(const FString& Str) override;
+	virtual ELoginStatus::Type GetLoginStatus(int32 LocalUserNum) const override;
+	virtual ELoginStatus::Type GetLoginStatus(const FUniqueNetId& UserId) const override;
+	virtual FString GetPlayerNickname(int32 LocalUserNum) const override;
+	virtual FString GetPlayerNickname(const FUniqueNetId& UserId) const override;
+	virtual FString GetAuthToken(int32 LocalUserNum) const override;
+	virtual void GetUserPrivilege(const FUniqueNetId& UserId, EUserPrivileges::Type Privilege, const FOnGetUserPrivilegeCompleteDelegate& Delegate) override;
+	virtual FString GetAuthType() const override;
+	virtual void RevokeAuthToken(const FUniqueNetId& LocalUserId, const FOnRevokeAuthTokenCompleteDelegate& Delegate) override;
+	virtual FPlatformUserId GetPlatformUserIdFromUniqueNetId(const FUniqueNetId& UniqueNetId) const override;
+// ~IOnlineIdentity Interface
+	ELoginStatus::Type GetLoginStatus(const FUniqueNetIdEOS& UserId) const;
+
+// IOnlineExternalUI Interface
+	virtual bool ShowLoginUI(const int ControllerIndex, bool bShowOnlineOnly, bool bShowSkipButton, const FOnLoginUIClosedDelegate& Delegate = FOnLoginUIClosedDelegate()) override;
+	virtual bool ShowAccountCreationUI(const int ControllerIndex, const FOnAccountCreationUIClosedDelegate& Delegate = FOnAccountCreationUIClosedDelegate()) override;
+	virtual bool ShowFriendsUI(int32 LocalUserNum) override;
+	virtual bool ShowInviteUI(int32 LocalUserNum, FName SessionName = NAME_GameSession) override;
+	virtual bool ShowAchievementsUI(int32 LocalUserNum) override;
+	virtual bool ShowLeaderboardUI(const FString& LeaderboardName) override;
+	virtual bool ShowWebURL(const FString& Url, const FShowWebUrlParams& ShowParams, const FOnShowWebUrlClosedDelegate& Delegate = FOnShowWebUrlClosedDelegate()) override;
+	virtual bool CloseWebURL() override;
+	virtual bool ShowProfileUI(const FUniqueNetId& Requestor, const FUniqueNetId& Requestee, const FOnProfileUIClosedDelegate& Delegate = FOnProfileUIClosedDelegate()) override;
+	virtual bool ShowAccountUpgradeUI(const FUniqueNetId& UniqueId) override;
+	virtual bool ShowStoreUI(int32 LocalUserNum, const FShowStoreParams& ShowParams, const FOnShowStoreUIClosedDelegate& Delegate = FOnShowStoreUIClosedDelegate()) override;
+	virtual bool ShowSendMessageUI(int32 LocalUserNum, const FShowSendMessageParams& ShowParams, const FOnShowSendMessageUIClosedDelegate& Delegate = FOnShowSendMessageUIClosedDelegate()) override;
+// ~IOnlineExternalUI Interface
+
+// IOnlineFriends Interface
+	virtual bool ReadFriendsList(int32 LocalUserNum, const FString& ListName, const FOnReadFriendsListComplete& Delegate = FOnReadFriendsListComplete()) override;
+	virtual bool DeleteFriendsList(int32 LocalUserNum, const FString& ListName, const FOnDeleteFriendsListComplete& Delegate = FOnDeleteFriendsListComplete()) override;
+	virtual bool SendInvite(int32 LocalUserNum, const FUniqueNetId& FriendId, const FString& ListName, const FOnSendInviteComplete& Delegate = FOnSendInviteComplete()) override;
+	virtual bool AcceptInvite(int32 LocalUserNum, const FUniqueNetId& FriendId, const FString& ListName, const FOnAcceptInviteComplete& Delegate = FOnAcceptInviteComplete()) override;
+	virtual bool RejectInvite(int32 LocalUserNum, const FUniqueNetId& FriendId, const FString& ListName) override;
+	virtual bool DeleteFriend(int32 LocalUserNum, const FUniqueNetId& FriendId, const FString& ListName) override;
+	virtual bool GetFriendsList(int32 LocalUserNum, const FString& ListName, TArray< TSharedRef<FOnlineFriend> >& OutFriends) override;
+	virtual TSharedPtr<FOnlineFriend> GetFriend(int32 LocalUserNum, const FUniqueNetId& FriendId, const FString& ListName) override;
+	virtual bool IsFriend(int32 LocalUserNum, const FUniqueNetId& FriendId, const FString& ListName) override;
+	virtual bool QueryRecentPlayers(const FUniqueNetId& UserId, const FString& Namespace) override;
+	virtual bool GetRecentPlayers(const FUniqueNetId& UserId, const FString& Namespace, TArray< TSharedRef<FOnlineRecentPlayer> >& OutRecentPlayers) override;
+	virtual bool BlockPlayer(int32 LocalUserNum, const FUniqueNetId& PlayerId) override;
+	virtual bool UnblockPlayer(int32 LocalUserNum, const FUniqueNetId& PlayerId) override;
+	virtual bool QueryBlockedPlayers(const FUniqueNetId& UserId) override;
+	virtual bool GetBlockedPlayers(const FUniqueNetId& UserId, TArray< TSharedRef<FOnlineBlockedPlayer> >& OutBlockedPlayers) override;
+	virtual void DumpBlockedPlayers() const override;
+	virtual void SetFriendAlias(int32 LocalUserNum, const FUniqueNetId& FriendId, const FString& ListName, const FString& Alias, const FOnSetFriendAliasComplete& Delegate = FOnSetFriendAliasComplete()) override;
+	virtual void DeleteFriendAlias(int32 LocalUserNum, const FUniqueNetId& FriendId, const FString& ListName, const FOnDeleteFriendAliasComplete& Delegate = FOnDeleteFriendAliasComplete()) override;
+	virtual void DumpRecentPlayers() const override;
+// ~IOnlineFriends Interface
+
+	bool HandleFriendsExec(UWorld* InWorld, const TCHAR* Cmd, FOutputDevice& Ar);
+
+// IOnlinePresence Interface
+	virtual void SetPresence(const FUniqueNetId& User, const FOnlineUserPresenceStatus& Status, const FOnPresenceTaskCompleteDelegate& Delegate = FOnPresenceTaskCompleteDelegate()) override;
+	virtual void QueryPresence(const FUniqueNetId& User, const FOnPresenceTaskCompleteDelegate& Delegate = FOnPresenceTaskCompleteDelegate()) override;
+	virtual EOnlineCachedResult::Type GetCachedPresence(const FUniqueNetId& User, TSharedPtr<FOnlineUserPresence>& OutPresence) override;
+	virtual EOnlineCachedResult::Type GetCachedPresenceForApp(const FUniqueNetId& LocalUserId, const FUniqueNetId& User, const FString& AppId, TSharedPtr<FOnlineUserPresence>& OutPresence) override;
+// ~IOnlinePresence Interface
+
+// IOnlineUser Interface
+	virtual bool QueryUserInfo(int32 LocalUserNum, const TArray<FUniqueNetIdRef>& UserIds) override;
+	virtual bool GetAllUserInfo(int32 LocalUserNum, TArray<TSharedRef<class FOnlineUser>>& OutUsers) override;
+	virtual TSharedPtr<FOnlineUser> GetUserInfo(int32 LocalUserNum, const class FUniqueNetId& UserId) override;
+	virtual bool QueryUserIdMapping(const FUniqueNetId& UserId, const FString& DisplayNameOrEmail, const FOnQueryUserMappingComplete& Delegate = FOnQueryUserMappingComplete()) override;
+	virtual bool QueryExternalIdMappings(const FUniqueNetId& UserId, const FExternalIdQueryOptions& QueryOptions, const TArray<FString>& ExternalIds, const FOnQueryExternalIdMappingsComplete& Delegate = FOnQueryExternalIdMappingsComplete()) override;
+	virtual void GetExternalIdMappings(const FExternalIdQueryOptions& QueryOptions, const TArray<FString>& ExternalIds, TArray<FUniqueNetIdPtr>& OutIds) override;
+	virtual FUniqueNetIdPtr GetExternalIdMapping(const FExternalIdQueryOptions& QueryOptions, const FString& ExternalId) override;
+// ~IOnlineUser Interface
+
+PACKAGE_SCOPE:
+	EOS_EpicAccountId GetLocalEpicAccountId(int32 LocalUserNum) const;
+	EOS_EpicAccountId GetLocalEpicAccountId() const;
+	EOS_ProductUserId GetLocalProductUserId(int32 LocalUserNum) const;
+	EOS_ProductUserId GetLocalProductUserId() const;
+	EOS_EpicAccountId GetLocalEpicAccountId(EOS_ProductUserId UserId) const;
+	EOS_ProductUserId GetLocalProductUserId(EOS_EpicAccountId AccountId) const;
+	FUniqueNetIdEOSPtr GetLocalUniqueNetIdEOS(int32 LocalUserNum) const;
+	FUniqueNetIdEOSPtr GetLocalUniqueNetIdEOS(EOS_ProductUserId UserId) const;
+	FUniqueNetIdEOSPtr GetLocalUniqueNetIdEOS(EOS_EpicAccountId AccountId) const;
+	FUniqueNetIdEOSPtr GetLocalUniqueNetIdEOS() const
+	{
+		return GetLocalUniqueNetIdEOS(GetDefaultLocalUser());
+	}
+
+	int32 GetLocalUserNumFromUniqueNetId(const FUniqueNetId& NetId) const;
+	bool IsLocalUser(const FUniqueNetId& NetId) const;
+
+	EOS_EpicAccountId GetEpicAccountId(const FUniqueNetId& NetId) const;
+	EOS_ProductUserId GetProductUserId(const FUniqueNetId& NetId) const;
+
+	typedef TFunction<void(const EOS_ProductUserId& ProductUserId, EOS_EpicAccountId& EpicAccountId)> GetEpicAccountIdAsyncCallback;
+	bool GetEpicAccountIdFromProductUserId(const EOS_ProductUserId& ProductUserId, EOS_EpicAccountId& OutEpicAccountId) const;
+	void GetEpicAccountIdAsync(const EOS_ProductUserId& ProductUserId, const GetEpicAccountIdAsyncCallback& Callback) const;
+
+	FOnlineUserPtr GetLocalOnlineUser(int32 LocalUserNum) const;
+	FOnlineUserPtr GetOnlineUser(EOS_ProductUserId UserId) const;
+	FOnlineUserPtr GetOnlineUser(EOS_EpicAccountId AccountId) const;
+
+	/**
+	 * Should use the initialization constructor instead
+	 */
+	FUserManagerEOS() = delete;
+
+	bool ConnectLoginEAS(int32 LocalUserNum, EOS_EpicAccountId AccountId);
+	void LoginViaExternalAuth(int32 LocalUserNum);
+	void CreateConnectedLogin(int32 LocalUserNum, EOS_EpicAccountId AccountId, EOS_ContinuanceToken Token);
+	void LinkEAS(int32 LocalUserNum, EOS_ContinuanceToken Token);
+	void RefreshConnectLogin(int32 LocalUserNum);
+	bool ConnectLoginNoEAS(int32 LocalUserNum);
+
+	void FullLoginCallback(int32 LocalUserNum, EOS_EpicAccountId AccountId, EOS_ProductUserId UserId);
+	void FriendStatusChanged(const EOS_Friends_OnFriendsUpdateInfo* Data);
+	void LoginStatusChanged(const EOS_Auth_LoginStatusChangedCallbackInfo* Data);
+
+	int32 GetDefaultLocalUser() const { return DefaultLocalUser; }
+
+private:
+	void RemoveLocalUser(int32 LocalUserNum);
+	void AddLocalUser(int32 LocalUserNum, EOS_EpicAccountId EpicAccountId, EOS_ProductUserId UserId);
+
+	void AddFriend(int32 LocalUserNum, EOS_EpicAccountId EpicAccountId);
+	void AddRemotePlayer(int32 LocalUserNum, const FString& NetId, EOS_EpicAccountId EpicAccountId);
+	void AddRemotePlayer(int32 LocalUserNum, const FString& NetId, EOS_EpicAccountId EpicAccountId, FUniqueNetIdEOSPtr UniqueNetId, FOnlineUserPtr OnlineUser, IAttributeAccessInterfaceRef AttributeRef);
+	void UpdateRemotePlayerProductUserId(EOS_EpicAccountId AccountId, EOS_ProductUserId UserId);
+	void ReadUserInfo(int32 LocalUserNum, EOS_EpicAccountId EpicAccountId);
+
+	void UpdateUserInfo(IAttributeAccessInterfaceRef AttriubteAccessRef, EOS_EpicAccountId LocalId, EOS_EpicAccountId TargetId);
+	bool IsFriendQueryUserInfoOngoing(int32 LocalUserNum);
+	void ProcessReadFriendsListComplete(int32 LocalUserNum, bool bWasSuccessful, const FString& ErrorStr);
+
+	void UpdatePresence(EOS_EpicAccountId AccountId);
+	void UpdateFriendPresence(const FString& FriendId, FOnlineUserPresenceRef Presence);
+
+	IOnlineSubsystem* GetPlatformOSS();
+	void GetPlatformAuthToken(int32 LocalUserNum, const FOnGetLinkedAccountAuthTokenCompleteDelegate& Delegate);
+
+	/** Cached pointer to owning subsystem */
+	FOnlineSubsystemEOS* EOSSubsystem;
+
+	/** Default local user when no local user is specified */
+	int32 DefaultLocalUser;
+
+	/** Notification state for SDK events */
+	EOS_NotificationId LoginNotificationId;
+	FCallbackBase* LoginNotificationCallback;
+	EOS_NotificationId FriendsNotificationId;
+	FCallbackBase* FriendsNotificationCallback;
+	EOS_NotificationId PresenceNotificationId;
+	FCallbackBase* PresenceNotificationCallback;
+	TMap<int32, FNotificationIdCallbackPair*> LocalUserNumToConnectLoginNotifcationMap;
+
+	/** Ids mapped to locally registered users */
+	TMap<int32, EOS_EpicAccountId> UserNumToAccountIdMap;
+	TMap<EOS_EpicAccountId, int32> AccountIdToUserNumMap;
+	TMap<int32, FUniqueNetIdEOSPtr> UserNumToNetIdMap;
+	TMap<int32, EOS_ProductUserId> UserNumToProductUserIdMap;
+	TMap<EOS_ProductUserId, int32> ProductUserIdToUserNumMap;
+	TMap<FString, FUserOnlineAccountEOSRef> StringToUserAccountMap;
+
+	/** General account mappings */
+	TMap<EOS_EpicAccountId, FString> AccountIdToStringMap;
+	TMap<EOS_ProductUserId, FString> ProductUserIdToStringMap;
+	TMap<FString, EOS_EpicAccountId> StringToAccountIdMap;
+	TMap<FString, EOS_ProductUserId> StringToProductUserIdMap;
+
+	/** Per user friends lists accessible by user num or net id */
+	TMap<int32, FFriendsListEOSRef> LocalUserNumToFriendsListMap;
+	TMap<FString, FFriendsListEOSRef> NetIdStringToFriendsListMap;
+	/** Per user blocked player lists accessible by user num or net id */
+	TMap<int32, FBlockedPlayersListEOSRef> LocalUserNumToBlockedPlayerListMap;
+	TMap<FString, FBlockedPlayersListEOSRef> NetIdStringToBlockedPlayerListMap;
+	/** Per user recent player lists accessible by user num or net id */
+	TMap<int32, FRecentPlayersListEOSRef> LocalUserNumToRecentPlayerListMap;
+	TMap<FString, FRecentPlayersListEOSRef> NetIdStringToRecentPlayerListMap;
+
+	/** Ids mapped to remote users */
+	TMap<FString, FOnlineUserPtr> NetIdStringToOnlineUserMap;
+	TMap<EOS_EpicAccountId, FOnlineUserPtr> EpicAccountIdToOnlineUserMap;
+	TMap<FString, IAttributeAccessInterfaceRef> NetIdStringToAttributeAccessMap;
+	TMap<EOS_EpicAccountId, IAttributeAccessInterfaceRef> EpicAccountIdToAttributeAccessMap;
+
+	/** Ids mapped to remote user presence */
+	TMap<FString, FOnlineUserPresenceRef> NetIdStringToOnlineUserPresenceMap;
+
+	/** Id map to keep track of which friends have been processed during async user info queries */
+	TMap<int32, TArray<EOS_EpicAccountId>> IsFriendQueryUserInfoOngoingForLocalUserMap;
+	/** Id map to keep track of which players still need their external id synced */
+	TMap<int32, TArray<FString>> IsPlayerQueryExternalMappingsOngoingForLocalUserMap;
+
+	/** Cache for the info passed on to ReadFriendsList, kept while user info queries complete */
+	struct ReadUserListInfo
+	{
+		const int32 LocalUserNum;
+		const FString ListName;
+		const FOnReadFriendsListComplete Delegate;
+
+		ReadUserListInfo(int32 InLocalUserNum, const FString& InListName, FOnReadFriendsListComplete InDelegate)
+			: LocalUserNum(InLocalUserNum), ListName(InListName), Delegate(MoveTemp(InDelegate))
+		{
+		}
+
+		void ExecuteDelegateIfBound(bool bWasSuccessful, const FString& ErrorStr) const
+		{
+			Delegate.ExecuteIfBound(LocalUserNum, bWasSuccessful, ListName, ErrorStr);
+		};
+	};
+
+	TMap<int32, TArray<ReadUserListInfo>> CachedReadUserListInfoForLocalUserMap;
+
+	/** Identifier for the external UI notification callback */
+	EOS_NotificationId DisplaySettingsUpdatedId;
+	FCallbackBase* DisplaySettingsUpdatedCallback;
+
+	/** Last Login Credentials used for a login attempt */
+	TMap<int32, TSharedRef<FOnlineAccountCredentials>> LocalUserNumToLastLoginCredentials;
+};
+
+#endif
Index: Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Private/SocketSubsystemEOS.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Private/SocketSubsystemEOS.h b/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Private/SocketSubsystemEOS.h
new file mode 100644
--- /dev/null	(date 1641575208000)
+++ b/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Private/SocketSubsystemEOS.h	(date 1641575208000)
@@ -0,0 +1,91 @@
+// Copyright Epic Games, Inc. All Rights Reserved.
+
+#pragma once
+
+#include "CoreMinimal.h"
+#include "SocketSubsystem.h"
+
+#if WITH_EOS_SDK
+	#if defined(EOS_PLATFORM_BASE_FILE_NAME)
+	#include EOS_PLATFORM_BASE_FILE_NAME
+	#endif
+
+	#include "eos_p2p_types.h"
+#endif
+
+class UNetConnectionEOS;
+class FSocket;
+class FResolveInfoCached;
+class FResolveInfo;
+class FInternetAddr;
+class FInternetAddrEOS;
+class FSocketEOS;
+class FOnlineSubsystemEOS;
+
+typedef TSet<uint8> FChannelSet;
+
+class FSocketSubsystemEOS
+	: public ISocketSubsystem
+{
+public:
+	FSocketSubsystemEOS(FOnlineSubsystemEOS* InSubsystemEOS);
+	virtual ~FSocketSubsystemEOS();
+
+//~ Begin ISocketSubsystem Interface
+	virtual bool Init(FString& Error) override;
+	virtual void Shutdown() override;
+	virtual FSocket* CreateSocket(const FName& SocketType, const FString& SocketDescription, const FName& ProtocolType) override;
+	virtual FResolveInfoCached* CreateResolveInfoCached(TSharedPtr<FInternetAddr> Addr) const override;
+	virtual void DestroySocket(FSocket* Socket) override;
+	virtual FAddressInfoResult GetAddressInfo(const TCHAR* HostName, const TCHAR* ServiceName = nullptr, EAddressInfoFlags QueryFlags = EAddressInfoFlags::Default, const FName ProtocolTypeName = NAME_None, ESocketType SocketType = ESocketType::SOCKTYPE_Unknown) override;
+	virtual bool RequiresChatDataBeSeparate() override;
+	virtual bool RequiresEncryptedPackets() override;
+	virtual bool GetHostName(FString& HostName) override;
+	virtual TSharedRef<FInternetAddr> CreateInternetAddr() override;
+	virtual TSharedPtr<FInternetAddr> GetAddressFromString(const FString& InString) override;
+	virtual bool HasNetworkDevice() override;
+	virtual const TCHAR* GetSocketAPIName() const override;
+	virtual ESocketErrors GetLastErrorCode() override;
+	virtual ESocketErrors TranslateErrorCode(int32 Code) override;
+	virtual bool GetLocalAdapterAddresses(TArray<TSharedPtr<FInternetAddr>>& OutAdresses) override;
+	virtual TSharedRef<FInternetAddr> GetLocalBindAddr(FOutputDevice& Out) override;
+	virtual TArray<TSharedRef<FInternetAddr>> GetLocalBindAddresses() override;
+	TSharedRef<FInternetAddr> GetLocalBindAddr(const UWorld* const OwningWorld, FOutputDevice& Out);
+	virtual bool IsSocketWaitSupported() const override;
+//~ End ISocketSubsystem Interface
+
+	void SetLastSocketError(const ESocketErrors NewSocketError);
+
+#if WITH_EOS_SDK
+	EOS_HP2P GetP2PHandle();
+	EOS_ProductUserId GetLocalUserId();
+#endif
+
+	/**
+	 * Bind our socket name & channel and ensure no other connections are using this combination
+	 *
+	 * @param Address The address to bind to
+	 * @return True if we bound successfully, false if not and LastSocketError will be set with a reason
+	 */
+	bool BindChannel(const FInternetAddrEOS& Address);
+
+	/**
+	 * Unbind a previously bound socket name and channel.
+	 *
+	 * @param Address The Address to unbind
+	 * @return True if we released the port successfully, false if not and LastSocketError will be set with a reason
+	 */
+	bool UnbindChannel(const FInternetAddrEOS& Address);
+
+private:
+	FOnlineSubsystemEOS* SubsystemEOS;
+
+	/** All sockets allocated by this subsystem */
+	TArray<TUniquePtr<FSocketEOS>> TrackedSockets;
+
+	/** All bound socket addresses */
+	TMap<FString, FChannelSet> BoundAddresses;
+
+	/** The last error we received */
+	ESocketErrors LastSocketError;
+};
Index: Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Private/InternetAddrEOS.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Private/InternetAddrEOS.h b/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Private/InternetAddrEOS.h
new file mode 100644
--- /dev/null	(date 1641575208000)
+++ b/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Private/InternetAddrEOS.h	(date 1641575208000)
@@ -0,0 +1,176 @@
+// Copyright Epic Games, Inc. All Rights Reserved.
+
+#pragma once
+
+#include "CoreMinimal.h"
+#include "IPAddress.h"
+
+#if WITH_EOS_SDK
+#if defined(EOS_PLATFORM_BASE_FILE_NAME)
+#include EOS_PLATFORM_BASE_FILE_NAME
+#endif
+#include "eos_common.h"
+#endif
+
+DECLARE_LOG_CATEGORY_EXTERN(LogSocketSubsystemEOS, Log, All);
+
+#define EOS_SOCKET_NAME_SIZE 33
+
+class FInternetAddrEOS
+	: public FInternetAddr
+{
+public:
+	FInternetAddrEOS();
+	FInternetAddrEOS(const FString& InRemoteUserId, const FString& InSocketName, const int32 InChannel);
+#if WITH_EOS_SDK
+	FInternetAddrEOS(const EOS_ProductUserId InRemoteUserId, const FString& InSocketName, const int32 InChannel);
+#endif
+	virtual ~FInternetAddrEOS() = default;
+
+//~ Begin FInternetAddr Interface
+	virtual void SetIp(uint32 InAddr) override;
+	virtual void SetIp(const TCHAR* InAddr, bool& bIsValid) override;
+	virtual void GetIp(uint32& OutAddr) const override;
+	virtual void SetPort(int32 InPort) override;
+	virtual int32 GetPort() const override;
+	virtual void SetRawIp(const TArray<uint8>& RawAddr) override;
+	virtual TArray<uint8> GetRawIp() const override;
+	virtual void SetAnyAddress() override;
+	virtual void SetBroadcastAddress() override;
+	virtual void SetLoopbackAddress() override;
+	virtual FString ToString(bool bAppendPort) const override;
+	virtual uint32 GetTypeHash() const override;
+	virtual bool IsValid() const override;
+	virtual TSharedRef<FInternetAddr> Clone() const override;
+//~ End FInternetAddr Interface
+
+	FORCEINLINE FInternetAddrEOS& operator=(const FInternetAddrEOS& Other)
+	{
+		LocalUserId = Other.LocalUserId;
+		RemoteUserId = Other.RemoteUserId;
+		FCStringAnsi::Strcpy(SocketName, Other.SocketName);
+		Channel = Other.Channel;
+		return *this;
+	}
+	
+	FORCEINLINE friend bool operator==(const FInternetAddrEOS& A, const FInternetAddrEOS& B)
+	{
+		return A.Channel == B.Channel
+#if WITH_EOS_SDK
+			&& A.LocalUserId == B.LocalUserId
+			&& A.RemoteUserId == B.RemoteUserId
+#endif
+			&& FCStringAnsi::Stricmp(A.GetSocketName(), B.GetSocketName()) == 0;
+	}
+
+	FORCEINLINE friend bool operator!=(const FInternetAddrEOS& A, const FInternetAddrEOS& B)
+	{
+		return !(A == B);
+	}
+
+	FORCEINLINE friend uint32 GetTypeHash(const FInternetAddrEOS& Address)
+	{
+		return Address.GetTypeHash();
+	}
+
+	friend bool operator<(const FInternetAddrEOS& Left, const FInternetAddrEOS& Right)
+	{
+#if WITH_EOS_SDK
+		if (Left.GetLocalUserId() < Right.GetLocalUserId())
+		{
+			return true;
+		}
+		else if (Left.GetRemoteUserId() < Right.GetRemoteUserId())
+		{
+			return true;
+		}
+		else
+#endif
+		if (FCStringAnsi::Stricmp(Left.GetSocketName(), Right.GetSocketName()) < 0)
+		{
+			return true;
+		}
+
+		return Left.GetChannel() < Right.GetChannel();
+	}
+
+#if WITH_EOS_SDK
+	EOS_ProductUserId GetLocalUserId() const
+	{
+		return LocalUserId;
+	}
+
+	void SetLocalUserId(EOS_ProductUserId InLocalUserId)
+	{
+		LocalUserId = InLocalUserId;
+	}
+
+	void SetRemoteUserId(EOS_ProductUserId InRemoteUserId)
+	{
+		RemoteUserId = InRemoteUserId;
+	}
+
+	EOS_ProductUserId GetRemoteUserId() const
+	{
+		return RemoteUserId;
+	}
+#else
+	void* GetLocalUserId() const
+	{
+		return LocalUserId;
+	}
+
+	void SetLocalUserId(void* InLocalUserId)
+	{
+		LocalUserId = InLocalUserId;
+	}
+
+	void SetRemoteUserId(void* InRemoteUserId)
+	{
+		RemoteUserId = InRemoteUserId;
+	}
+
+	void* GetRemoteUserId() const
+	{
+		return RemoteUserId;
+	}
+#endif
+	
+	const char* GetSocketName() const
+	{
+		return SocketName;
+	}
+
+	void SetSocketName(const FString& InSocketName)
+	{
+		FCStringAnsi::Strncpy(SocketName, TCHAR_TO_UTF8(*InSocketName), EOS_SOCKET_NAME_SIZE);
+	}
+
+	void SetSocketName(const char* InSocketName)
+	{
+		FCStringAnsi::Strncpy(SocketName, InSocketName, EOS_SOCKET_NAME_SIZE);
+	}
+
+	uint8 GetChannel() const
+	{
+		return Channel;
+	}
+
+	void SetChannel(uint8 InChannel)
+	{
+		Channel = InChannel;
+	}
+
+private:
+#if WITH_EOS_SDK
+	EOS_ProductUserId LocalUserId;
+	EOS_ProductUserId RemoteUserId;
+#else
+	void* LocalUserId;
+	void* RemoteUserId;
+#endif
+	char SocketName[EOS_SOCKET_NAME_SIZE];
+	uint8 Channel;
+
+	friend class SocketSubsystemEOS;
+};
Index: Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Private/OnlineUserCloudEOS.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Private/OnlineUserCloudEOS.cpp b/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Private/OnlineUserCloudEOS.cpp
new file mode 100644
--- /dev/null	(date 1641575208000)
+++ b/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Private/OnlineUserCloudEOS.cpp	(date 1641575208000)
@@ -0,0 +1,952 @@
+// Copyright Epic Games, Inc. All Rights Reserved.
+
+#include "OnlineUserCloudEOS.h"
+#include "OnlineSubsystem.h"
+#include "OnlineSubsystemEOS.h"
+#include "OnlineSubsystemEOSTypes.h"
+#include "UserManagerEOS.h"
+#include "EOSSettings.h"
+
+#if WITH_EOS_SDK
+#include "eos_playerdatastorage.h"
+
+typedef TEOSCallback<EOS_PlayerDataStorage_OnQueryFileListCompleteCallback, EOS_PlayerDataStorage_QueryFileListCallbackInfo> FOnQueryFileListCallback;
+
+typedef TEOSCallbackWithNested2ForNested1Param3<EOS_PlayerDataStorage_OnWriteFileCompleteCallback, EOS_PlayerDataStorage_WriteFileCallbackInfo,
+	EOS_PlayerDataStorage_OnWriteFileDataCallback, EOS_PlayerDataStorage_WriteFileDataCallbackInfo, EOS_PlayerDataStorage_EWriteResult,
+	EOS_PlayerDataStorage_OnFileTransferProgressCallback, EOS_PlayerDataStorage_FileTransferProgressCallbackInfo
+> FWriteUserFileCompleteCallback;
+
+typedef TEOSCallbackWithNested2<EOS_PlayerDataStorage_OnReadFileCompleteCallback, EOS_PlayerDataStorage_ReadFileCallbackInfo,
+	EOS_PlayerDataStorage_OnReadFileDataCallback, EOS_PlayerDataStorage_ReadFileDataCallbackInfo, EOS_PlayerDataStorage_EReadResult,
+	EOS_PlayerDataStorage_OnFileTransferProgressCallback, EOS_PlayerDataStorage_FileTransferProgressCallbackInfo
+> FReadUserFileCompleteCallback;
+
+typedef TEOSCallback<EOS_PlayerDataStorage_OnDeleteFileCompleteCallback, EOS_PlayerDataStorage_DeleteFileCallbackInfo> FOnDeleteFileCallback;
+
+void FEOSUserCloudFile::Unload()
+{
+	if (bIsLoaded)
+	{
+		Contents.Empty();
+		bIsLoaded = false;
+	}
+	else if (bInProgress)
+	{
+		UE_LOG_ONLINE_CLOUD(Warning, TEXT("[FEOSUserCloudFile::Unload] Could not unload. File %s is being read or written"), *Filename);
+	}
+}
+
+bool FOnlineUserCloudEOS::GetFileContents(const FUniqueNetId& UserId, const FString& FileName, TArray<uint8>& FileContents)
+{
+	FUniqueNetIdPtr UniqueNetId = EOSSubsystem->UserManager->GetUniquePlayerId(EOSSubsystem->UserManager->GetLocalUserNumFromUniqueNetId(UserId));
+	if (!UniqueNetId.IsValid())
+	{
+		UE_LOG_ONLINE_CLOUD(Warning, TEXT("[FOnlineUserCloudEOS::GetFileContents] Unable to get file contents. User %s is not a local user"), *UserId.ToString());
+		return false;
+	}
+
+	bool bResult = false;
+
+	FUserCloudFileCollection* UserCloudFileCollection = FileSetsPerUser.Find(UniqueNetId.ToSharedRef());
+	if (UserCloudFileCollection != nullptr)
+	{
+		FEOSUserCloudFile* UserCloudFile = UserCloudFileCollection->Find(FileName);
+		if (UserCloudFile != nullptr)
+		{
+			if (UserCloudFile->bIsLoaded)
+			{
+				FileContents = UserCloudFile->Contents;
+
+				UE_LOG_ONLINE_CLOUD(Verbose, TEXT("[FOnlineUserCloudEOS::GetFileContents] Got data for file %s with a size of %d bytes"), *FileName, FileContents.Num());
+
+				bResult = true;
+			}
+			else
+			{
+				// Are we still downloading?
+				if (UserCloudFile->bInProgress)
+				{
+					UE_LOG_ONLINE_CLOUD(Warning, TEXT("[FOnlineUserCloudEOS::GetFileContents] Unable to get file contents. File %s is being read or written"), *FileName);
+				}
+				// Contents have been cleared
+				else
+				{
+					UE_LOG_ONLINE_CLOUD(Warning, TEXT("[FOnlineUserCloudEOS::GetFileContents] Unable to get file contents. File %s has not been loaded"), *FileName);
+				}
+			}
+		}
+		else
+		{
+			UE_LOG_ONLINE_CLOUD(Warning, TEXT("[FOnlineUserCloudEOS::GetFileContents] Unable to get file contents. Unknown file %s"), *FileName);
+		}
+	}
+	else
+	{
+		UE_LOG_ONLINE_CLOUD(Warning, TEXT("[FOnlineUserCloudEOS::GetFileContents] Unable to get file contents. Unknown user %s"), *UserId.ToString());
+	}
+
+	return bResult;
+}
+
+bool FOnlineUserCloudEOS::ClearFiles(const FUniqueNetId& UserId)
+{
+	FUniqueNetIdPtr UniqueNetId = EOSSubsystem->UserManager->GetUniquePlayerId(EOSSubsystem->UserManager->GetLocalUserNumFromUniqueNetId(UserId));
+	if (!UniqueNetId.IsValid())
+	{
+		UE_LOG_ONLINE_CLOUD(Warning, TEXT("[FOnlineUserCloudEOS::ClearFiles] Unable to get clear files. User %s is not a local user"), *UserId.ToString());
+		return false;
+	}
+
+	bool bResult = true;
+
+	// First we check if all the files for this user can be deleted, without actually deleting any.
+	FUserCloudFileCollection* UserCloudFileCollection = FileSetsPerUser.Find(UniqueNetId.ToSharedRef());
+	if (UserCloudFileCollection != nullptr)
+	{
+		for (TPair<FString, FEOSUserCloudFile>& Entry : *UserCloudFileCollection)
+		{
+			if (Entry.Value.bInProgress)
+			{
+				UE_LOG_ONLINE_CLOUD(Warning, TEXT("[FOnlineUserCloudEOS::ClearFiles] Unable to clear files. File %s for user %s is in the process of being read or written"), *Entry.Key, *UserId.ToString());
+				bResult = false;
+				break;
+			}
+		}
+	}
+	else
+	{
+		UE_LOG_ONLINE_CLOUD(Warning, TEXT("[FOnlineUserCloudEOS::ClearFiles] Unable to clear files. Unknown user %s"), *UserId.ToString());
+		bResult = false;
+	}
+
+	// Then, if all files are ok for clearing, we do so
+	if (bResult)
+	{
+		FileSetsPerUser.Remove(UniqueNetId.ToSharedRef());
+
+		UE_LOG_ONLINE_CLOUD(Verbose, TEXT("[FOnlineUserCloudEOS::ClearFiles] Cleared all files for user %s"), *UserId.ToString());
+	}
+	
+	return bResult;
+}
+
+bool FOnlineUserCloudEOS::ClearFile(const FUniqueNetId& UserId, const FString& FileName)
+{
+	FUniqueNetIdPtr UniqueNetId = EOSSubsystem->UserManager->GetUniquePlayerId(EOSSubsystem->UserManager->GetLocalUserNumFromUniqueNetId(UserId));
+	if (!UniqueNetId.IsValid())
+	{
+		UE_LOG_ONLINE_CLOUD(Warning, TEXT("[FOnlineUserCloudEOS::ClearFile] Unable to get clear file. User %s is not a local user"), *UserId.ToString());
+		return false;
+	}
+
+	bool bResult = false;
+
+	FUserCloudFileCollection* UserCloudFileCollection = FileSetsPerUser.Find(UniqueNetId.ToSharedRef());
+	if (UserCloudFileCollection != nullptr)
+	{
+		FEOSUserCloudFile* UserCloudFile = UserCloudFileCollection->Find(FileName);
+		if (UserCloudFile != nullptr)
+		{
+			if (UserCloudFile->bInProgress)
+			{
+				UE_LOG_ONLINE_CLOUD(Warning, TEXT("[FOnlineUserCloudEOS::ClearFile] Unable to clear file. File %s for user %s is in the process of being read or written"), *FileName, *UserId.ToString());
+			}
+			else
+			{
+				UserCloudFileCollection->Remove(FileName);
+
+				UE_LOG_ONLINE_CLOUD(Verbose, TEXT("[FOnlineUserCloudEOS::ClearFile] Cleared file %s for user %s"), *FileName, *UserId.ToString());
+
+				bResult = true;
+			}
+		}
+		else
+		{
+			UE_LOG_ONLINE_CLOUD(Warning, TEXT("[FOnlineUserCloudEOS::ClearFile] Unable to clear file. Unknown file %s"), *FileName);
+		}
+	}
+	else
+	{
+		UE_LOG_ONLINE_CLOUD(Warning, TEXT("[FOnlineUserCloudEOS::ClearFile] Unable to clear file. Unknown user %s"), *UserId.ToString());
+	}
+
+	return bResult;
+}
+
+void FOnlineUserCloudEOS::EnumerateUserFiles(const FUniqueNetId& UserId)
+{
+	EOS_ProductUserId LocalUserId = EOSSubsystem->UserManager->GetProductUserId(UserId);
+
+	if (LocalUserId == nullptr)
+	{
+		EOSSubsystem->ExecuteNextTick([this, UserIdRef = UserId.AsShared()]() {
+				UE_LOG_ONLINE_CLOUD(Warning, TEXT("[FOnlineUserCloudEOS::EnumerateUserFiles] Could not retrieve EOS_ProductUserId for user %s"), *UserIdRef->ToString());
+				TriggerOnEnumerateUserFilesCompleteDelegates(false, *UserIdRef);
+			});
+
+		return;
+	}
+
+	EOS_PlayerDataStorage_QueryFileListOptions Options = {};
+	Options.ApiVersion = EOS_PLAYERDATASTORAGE_QUERYFILELISTOPTIONS_API_LATEST;
+	Options.LocalUserId = LocalUserId;
+
+	FOnQueryFileListCallback* CallbackObj = new FOnQueryFileListCallback();
+	CallbackObj->CallbackLambda = [this](const EOS_PlayerDataStorage_QueryFileListCallbackInfo* Data)
+	{
+		bool bWasSuccessful = Data->ResultCode == EOS_EResult::EOS_Success || Data->ResultCode == EOS_EResult::EOS_NotFound; // If the user doesn't have any files yet, we will get a NotFound error, but the query was valid
+
+		FUniqueNetIdEOSPtr UniqueNetIdPtr = EOSSubsystem->UserManager->GetLocalUniqueNetIdEOS(Data->LocalUserId);
+		if (UniqueNetIdPtr.IsValid())
+		{
+			if (bWasSuccessful)
+			{
+				uint32 FileCount = Data->FileCount;
+				UE_LOG_ONLINE_CLOUD(Verbose, TEXT("[FOnlineUserCloudEOS::EnumerateUserFiles] Found %d files for user %s"), FileCount, *UniqueNetIdPtr->ToString());
+
+				TArray<FCloudFileHeader>& QueryFileSet = QueryFileSetsPerUser.FindOrAdd(UniqueNetIdPtr.ToSharedRef());
+				QueryFileSet.Empty();
+
+				for (uint32 Index = 0; Index < FileCount; ++Index)
+				{
+					EOS_PlayerDataStorage_CopyFileMetadataAtIndexOptions CopyFileMetadataAtIndexOptions = { };
+					CopyFileMetadataAtIndexOptions.ApiVersion = EOS_PLAYERDATASTORAGE_COPYFILEMETADATAATINDEXOPTIONS_API_LATEST;
+					CopyFileMetadataAtIndexOptions.LocalUserId = Data->LocalUserId;
+					CopyFileMetadataAtIndexOptions.Index = Index;
+
+					EOS_PlayerDataStorage_FileMetadata* FileMetadata = nullptr;
+					EOS_EResult Result = EOS_PlayerDataStorage_CopyFileMetadataAtIndex(EOSSubsystem->PlayerDataStorageHandle, &CopyFileMetadataAtIndexOptions, &FileMetadata);
+					if (Result == EOS_EResult::EOS_Success)
+					{
+						if (FileMetadata && FileMetadata->Filename)
+						{
+							QueryFileSet.Emplace(FCloudFileHeader(ANSI_TO_TCHAR(FileMetadata->Filename), ANSI_TO_TCHAR(FileMetadata->Filename), FileMetadata->FileSizeBytes));
+
+							UE_LOG_ONLINE_CLOUD(VeryVerbose, TEXT("[FOnlineUserCloudEOS::EnumerateUserFiles] Cached metadata for file %s with size %d"), ANSI_TO_TCHAR(FileMetadata->Filename), FileMetadata->FileSizeBytes);
+						}
+
+						EOS_PlayerDataStorage_FileMetadata_Release(FileMetadata);
+					}
+					else
+					{
+						UE_LOG_ONLINE_CLOUD(Warning, TEXT("[FOnlineUserCloudEOS::EnumerateUserFiles] EOS_PlayerDataStorage_CopyFileMetadataAtIndex was not successful. Finished with error %s on file with index %d"), ANSI_TO_TCHAR(EOS_EResult_ToString(Result)), Index);
+					}
+				}
+			}
+			else
+			{
+				UE_LOG_ONLINE_CLOUD(Warning, TEXT("[FOnlineUserCloudEOS::EnumerateUserFiles] EOS_PlayerDataStorage_QueryFileList was not successful. Finished with error %s"), ANSI_TO_TCHAR(EOS_EResult_ToString(Data->ResultCode)));
+			}
+		}
+		else
+		{
+			UE_LOG_ONLINE_CLOUD(Warning, TEXT("[FOnlineUserCloudEOS::EnumerateUserFiles] UniqueNetId not found for EOS_ProductUserId %s"), Data->LocalUserId);
+		}
+
+		TriggerOnEnumerateUserFilesCompleteDelegates(bWasSuccessful, *UniqueNetIdPtr);
+	};
+
+	EOS_PlayerDataStorage_QueryFileList(EOSSubsystem->PlayerDataStorageHandle, &Options, CallbackObj, CallbackObj->GetCallbackPtr());
+}
+
+void FOnlineUserCloudEOS::GetUserFileList(const FUniqueNetId& UserId, TArray<FCloudFileHeader>& UserFiles)
+{
+	FUniqueNetIdPtr UniqueNetId = EOSSubsystem->UserManager->GetUniquePlayerId(EOSSubsystem->UserManager->GetLocalUserNumFromUniqueNetId(UserId));
+	if (!UniqueNetId.IsValid())
+	{
+		UE_LOG_ONLINE_CLOUD(Warning, TEXT("[FOnlineUserCloudEOS::GetUserFileList] Unable to get user file list. User %s is not a local user"), *UserId.ToString());
+		return;
+	}
+
+	if (const TArray<FCloudFileHeader>* const UserFileSets = QueryFileSetsPerUser.Find(UniqueNetId.ToSharedRef()))
+	{
+		UserFiles = *UserFileSets;
+	}
+	else
+	{
+		UE_LOG_ONLINE_CLOUD(Warning, TEXT("[FOnlineUserCloudEOS::GetUserFileList] User %s doesn't have any cached files."), *UserId.ToString());
+	}
+}
+
+bool FOnlineUserCloudEOS::ReadUserFile(const FUniqueNetId& UserId, const FString& FileName)
+{
+	FUniqueNetIdPtr UniqueNetId = EOSSubsystem->UserManager->GetUniquePlayerId(EOSSubsystem->UserManager->GetLocalUserNumFromUniqueNetId(UserId));
+	if (!UniqueNetId.IsValid())
+	{
+		EOSSubsystem->ExecuteNextTick([this, UserIdRef = UserId.AsShared(), FileName]()
+			{
+				UE_LOG_ONLINE_CLOUD(Warning, TEXT("[FOnlineUserCloudEOS::ReadUserFile] Unable to get read user file. User %s is not a local user"), *UserIdRef->ToString());
+				TriggerOnReadUserFileCompleteDelegates(false, *UserIdRef, FileName);
+			});		
+		return true;
+	}
+
+	FUniqueNetIdRef SharedUserId = UniqueNetId.ToSharedRef();
+
+	// If this file is already being read or written, don't try to start it again.
+	FUserCloudFileCollection* UserCloudFileCollection = FileSetsPerUser.Find(SharedUserId);
+	if (UserCloudFileCollection != nullptr)
+	{
+		FEOSUserCloudFile* UserCloudFile = UserCloudFileCollection->Find(FileName);
+		if (UserCloudFile != nullptr && UserCloudFile->bInProgress)
+		{
+			EOSSubsystem->ExecuteNextTick([this, UserIdRef = UserId.AsShared(), FileName]()
+				{
+					UE_LOG_ONLINE_CLOUD(Warning, TEXT("[FOnlineUserCloudEOS::ReadUserFile] File %s for user %s is already in the process of being read or written"), *FileName, *UserIdRef->ToString());
+					TriggerOnReadUserFileCompleteDelegates(false, *UserIdRef, FileName);
+				});
+
+			return true;
+		}
+	}
+
+	// We prepare all the components for the Options object
+
+	FTCHARToUTF8 FileNameUtf8(*FileName);
+
+	int32 ReadChunkSize = UEOSSettings::GetSettings().TitleStorageReadChunkLength;
+	if (ReadChunkSize <= 0)
+	{
+		UE_LOG_ONLINE_CLOUD(Warning, TEXT("[FOnlineUserCloudEOS::ReadUserFile] invalid size TitleStorageReadChunkLength %d. ReadChunkSize set to 16KB by default"), ReadChunkSize);
+		ReadChunkSize = 16 * 1024;
+	}
+
+	FReadUserFileCompleteCallback* CallbackObj = new FReadUserFileCompleteCallback();
+
+	CallbackObj->SetNested1CallbackLambda([this, SharedUserId, FileName](const EOS_PlayerDataStorage_ReadFileDataCallbackInfo* Data)
+		{
+			UE_LOG_ONLINE_CLOUD(VeryVerbose, TEXT("[FOnlineUserCloudEOS::ReadUserFile] Reading %d bytes of file %s's data"), Data->DataChunkLengthBytes, *FileName);
+
+			FUserCloudFileCollection* UserCloudFileCollection = FileSetsPerUser.Find(SharedUserId);
+			if (UserCloudFileCollection != nullptr)
+			{
+				FEOSUserCloudFile* UserCloudFile = UserCloudFileCollection->Find(FileName);
+				if (UserCloudFile != nullptr)
+				{
+					check(UserCloudFile->bInProgress);
+
+					// Is this is the first chunk of data we have received for this file?
+					if (UserCloudFile->ContentSize == 0 && UserCloudFile->ContentIndex == 0)
+					{
+						// Store the actual size of the file being read
+						UserCloudFile->ContentSize = Data->TotalFileSizeBytes;
+
+						// Is the file being read empty?
+						if (UserCloudFile->ContentSize == 0)
+						{
+							// If the file is empty, we return this value as we would do in the case when we have read the last bytes of a file. The OnReadComplete delegate will trigger immediately after.
+							return EOS_PlayerDataStorage_EReadResult::EOS_RR_ContinueReading;
+						}
+
+						UserCloudFile->Contents.AddUninitialized(Data->TotalFileSizeBytes);
+					}
+
+					if (UserCloudFile->ContentIndex + Data->DataChunkLengthBytes <= UserCloudFile->ContentSize)
+					{
+						check(Data->DataChunkLengthBytes > 0);
+						FMemory::Memcpy(UserCloudFile->Contents.GetData() + UserCloudFile->ContentIndex, Data->DataChunk, Data->DataChunkLengthBytes);
+						UserCloudFile->ContentIndex += Data->DataChunkLengthBytes;
+						return EOS_PlayerDataStorage_EReadResult::EOS_RR_ContinueReading;
+					}
+					else
+					{
+						UE_LOG_ONLINE_CLOUD(Warning, TEXT("[FOnlineUserCloudEOS::ReadUserFile] Read size exceeded specified file size for file %s"), *FileName);
+						return EOS_PlayerDataStorage_EReadResult::EOS_RR_FailRequest;
+					}
+				}
+				else
+				{
+					UE_LOG_ONLINE_CLOUD(Warning, TEXT("[FOnlineUserCloudEOS::ReadUserFile] Unknown file %s. Cancelling transfer request"), *FileName);
+				}
+			}
+			else
+			{
+				UE_LOG_ONLINE_CLOUD(Warning, TEXT("[FOnlineUserCloudEOS::ReadUserFile] Unknown user %s. Cancelling transfer request for file %s"), *SharedUserId->ToString(), *FileName);
+			}
+
+			return EOS_PlayerDataStorage_EReadResult::EOS_RR_CancelRequest;
+		});
+
+	CallbackObj->SetNested2CallbackLambda([this, SharedUserId, FileName](const _tagEOS_PlayerDataStorage_FileTransferProgressCallbackInfo* Data)
+		{
+			UE_LOG_ONLINE_CLOUD(VeryVerbose, TEXT("[FOnlineUserCloudEOS::ReadUserFile] File transfer progress for file %s is %d bytes"), *FileName, Data->BytesTransferred);
+			//TriggerOnReadUserFileProgressDelegates(Data->BytesTransferred, *SharedUserId, FileName); It doesn't exist, maybe we should add it
+		});
+
+	CallbackObj->CallbackLambda = [this, SharedUserId, FileName](const EOS_PlayerDataStorage_ReadFileCallbackInfo* Data)
+	{
+		bool bWasSuccessful = Data->ResultCode == EOS_EResult::EOS_Success;
+
+		FUserCloudFileCollection* UserCloudFileCollection = FileSetsPerUser.Find(SharedUserId);
+		if (UserCloudFileCollection != nullptr)
+		{
+			FEOSUserCloudFile* UserCloudFile = UserCloudFileCollection->Find(FileName);
+			if (UserCloudFile != nullptr)
+			{
+				if (UserCloudFile->FileTransferRequest != nullptr)
+				{
+					EOS_PlayerDataStorageFileTransferRequest_Release(UserCloudFile->FileTransferRequest);
+					UserCloudFile->FileTransferRequest = nullptr;
+				}
+
+				if (bWasSuccessful)
+				{
+					UserCloudFile->bIsLoaded = true;
+					UserCloudFile->bInProgress = false;
+					UE_LOG_ONLINE_CLOUD(Verbose, TEXT("[FOnlineUserCloudEOS::ReadUserFile] Read file %s with size %d"), *UserCloudFile->Filename, UserCloudFile->ContentSize);
+				}
+				else
+				{
+					// If we fail to complete reading the file, discard it from the known files
+					FileSetsPerUser.Find(SharedUserId)->Remove(FileName);
+
+					UE_LOG_ONLINE_CLOUD(Warning, TEXT("[FOnlineUserCloudEOS::ReadUserFile] EOS_PlayerDataStorage_ReadFile was not successful for file %s. Finished with error %s"), *FileName, ANSI_TO_TCHAR(EOS_EResult_ToString(Data->ResultCode)));
+				}
+			}
+			else
+			{
+				bWasSuccessful = false;
+				UE_LOG_ONLINE_CLOUD(Warning, TEXT("[FOnlineUserCloudEOS::ReadUserFile] Unknown transfer request for file %s"), *FileName);
+			}
+		}
+		else
+		{
+			UE_LOG_ONLINE_CLOUD(Warning, TEXT("[FOnlineUserCloudEOS::ReadUserFile] Unknown user %s for file %s's transfer request"), *SharedUserId->ToString(), *FileName);
+		}
+
+		TriggerOnReadUserFileCompleteDelegates(bWasSuccessful, *SharedUserId, FileName);
+	};
+
+	EOS_PlayerDataStorage_ReadFileOptions ReadFileOptions = {};
+	ReadFileOptions.ApiVersion = EOS_PLAYERDATASTORAGE_READFILEOPTIONS_API_LATEST;
+	ReadFileOptions.LocalUserId = EOSSubsystem->UserManager->GetProductUserId(UserId);
+	ReadFileOptions.Filename = FileNameUtf8.Get();
+	ReadFileOptions.ReadChunkLengthBytes = (uint32_t)ReadChunkSize;
+	ReadFileOptions.ReadFileDataCallback = CallbackObj->GetNested1CallbackPtr();
+	ReadFileOptions.FileTransferProgressCallback = CallbackObj->GetNested2CallbackPtr();
+
+	EOS_HPlayerDataStorageFileTransferRequest FileTransferRequest = EOS_PlayerDataStorage_ReadFile(EOSSubsystem->PlayerDataStorageHandle, &ReadFileOptions, CallbackObj, CallbackObj->GetCallbackPtr());
+
+	if (FileTransferRequest != nullptr)
+	{
+		FEOSUserCloudFile UserCloudFile;
+		UserCloudFile.Filename = FileName;
+		UserCloudFile.FileTransferRequest = FileTransferRequest;
+		UserCloudFile.bInProgress = true;
+		FileSetsPerUser.FindOrAdd(SharedUserId).FindOrAdd(FileName) = MoveTemp(UserCloudFile); // Replace the last file, or create a new entry, same with the user
+	}
+	else
+	{
+		EOSSubsystem->ExecuteNextTick([this, UserIdRef = UserId.AsShared(), FileName]()
+			{
+				UE_LOG_ONLINE_CLOUD(Warning, TEXT("[FOnlineUserCloudEOS::ReadUserFile] Failed to create a transfer request for user's %s file with name %s"), *UserIdRef->ToString(), *FileName);
+				TriggerOnReadUserFileCompleteDelegates(false, *UserIdRef, FileName);
+			});
+	}
+
+	return true;
+}
+
+bool FOnlineUserCloudEOS::WriteUserFile(const FUniqueNetId& UserId, const FString& FileName, TArray<uint8>& FileContents, bool bCompressBeforeUpload)
+{
+	FUniqueNetIdPtr UniqueNetId = EOSSubsystem->UserManager->GetUniquePlayerId(EOSSubsystem->UserManager->GetLocalUserNumFromUniqueNetId(UserId));
+	if (!UniqueNetId.IsValid())
+	{
+		EOSSubsystem->ExecuteNextTick([this, UserIdRef = UserId.AsShared(), FileName]()
+			{
+				UE_LOG_ONLINE_CLOUD(Warning, TEXT("[FOnlineUserCloudEOS::WriteUserFile] Unable to write file. User %s is not a local user"), *UserIdRef->ToString());
+				TriggerOnWriteUserFileCompleteDelegates(false, *UserIdRef, FileName);
+			});
+
+		return true;
+	}
+
+	FUniqueNetIdRef SharedUserId = UniqueNetId.ToSharedRef();
+
+	// If this file is already being read or written, don't try to start it again.
+	FUserCloudFileCollection* UserCloudFileCollection = FileSetsPerUser.Find(SharedUserId);
+	if (UserCloudFileCollection != nullptr)
+	{
+		FEOSUserCloudFile* UserCloudFile = UserCloudFileCollection->Find(FileName);
+		if (UserCloudFile != nullptr && UserCloudFile->bInProgress)
+		{
+			EOSSubsystem->ExecuteNextTick([this, UserIdRef = UserId.AsShared(), FileName]()
+				{
+					UE_LOG_ONLINE_CLOUD(Warning, TEXT("[FOnlineUserCloudEOS::WriteUserFile] File %s for user %s is already in the process of being read or written."), *FileName, *UserIdRef->ToString());
+					TriggerOnWriteUserFileCompleteDelegates(false, *UserIdRef, FileName);
+				});
+
+			return true;
+		}
+	}
+
+	// We prepare all the components for the Options object
+
+	FTCHARToUTF8 FileNameUtf8(*FileName);
+
+	// We'll use the same buffer size to write as we use to read
+	int32 ReadChunkSize = UEOSSettings::GetSettings().TitleStorageReadChunkLength;
+	if (ReadChunkSize <= 0)
+	{
+		UE_LOG_ONLINE_CLOUD(Warning, TEXT("[FOnlineUserCloudEOS::WriteUserFile] invalid size TitleStorageReadChunkLength %d"), ReadChunkSize);
+		ReadChunkSize = 16 * 1024;
+	}
+
+	FWriteUserFileCompleteCallback* CallbackObj = new FWriteUserFileCompleteCallback();
+
+	CallbackObj->SetNested1CallbackLambda([this, SharedUserId, FileName](const EOS_PlayerDataStorage_WriteFileDataCallbackInfo* Data, void* OutDataBuffer, uint32_t* OutDataWritten)
+	{
+		UE_LOG_ONLINE_CLOUD(Verbose, TEXT("[FOnlineUserCloudEOS::WriteUserFile] Writing file data for %s"), *FileName);
+
+		FUserCloudFileCollection* UserCloudFileCollection = FileSetsPerUser.Find(SharedUserId);
+		if (UserCloudFileCollection != nullptr)
+		{
+			FEOSUserCloudFile* UserCloudFile = UserCloudFileCollection->Find(FileName);
+			if (UserCloudFile != nullptr)
+			{
+				check(UserCloudFile->bInProgress);
+
+				size_t BytesToWrite = FMath::Min(Data->DataBufferLengthBytes, (uint32_t)(UserCloudFile->ContentSize - UserCloudFile->ContentIndex));
+
+				if (BytesToWrite == 0)
+				{
+					return EOS_PlayerDataStorage_EWriteResult::EOS_WR_CompleteRequest;
+				}
+				if (UserCloudFile->ContentIndex + BytesToWrite <= UserCloudFile->ContentSize)
+				{
+					check(BytesToWrite > 0);
+					FMemory::Memcpy(OutDataBuffer, static_cast<const void*>(&UserCloudFile->Contents[UserCloudFile->ContentIndex]), BytesToWrite);
+					*OutDataWritten = static_cast<uint32_t>(BytesToWrite);
+
+					UserCloudFile->ContentIndex += (size_t)*OutDataWritten;
+
+					UE_LOG_ONLINE_CLOUD(Verbose, TEXT("[FOnlineUserCloudEOS::WriteUserFile] Wrote %d bytes for file %s"), BytesToWrite, *FileName);
+
+					return EOS_PlayerDataStorage_EWriteResult::EOS_WR_ContinueWriting;
+				}
+				else
+				{
+					UE_LOG_ONLINE_CLOUD(Warning, TEXT("[FOnlineUserCloudEOS::WriteUserFile] Read size exceeded specified file size for file %s"), *FileName);
+					return EOS_PlayerDataStorage_EWriteResult::EOS_WR_FailRequest;
+				}
+			}
+			else
+			{
+				UE_LOG_ONLINE_CLOUD(Warning, TEXT("[FOnlineUserCloudEOS::WriteUserFile] Unknown file %s. Cancelling transfer request"), *FileName);
+			}
+		}
+		else
+		{
+			UE_LOG_ONLINE_CLOUD(Warning, TEXT("[FOnlineUserCloudEOS::WriteUserFile] Unknown user %s. Cancelling transfer request for file %s"), *SharedUserId->ToString(), *FileName);
+		}
+
+		return EOS_PlayerDataStorage_EWriteResult::EOS_WR_CancelRequest;
+	});
+
+	CallbackObj->SetNested2CallbackLambda([this, SharedUserId, FileName](const EOS_PlayerDataStorage_FileTransferProgressCallbackInfo* Data)
+		{
+			UE_LOG_ONLINE_CLOUD(VeryVerbose, TEXT("[FOnlineUserCloudEOS::WriteUserFile] File transfer progress for file %s is %d bytes"), *FileName, Data->BytesTransferred);
+			TriggerOnWriteUserFileProgressDelegates(Data->BytesTransferred, *SharedUserId, FileName);
+		});
+
+	CallbackObj->CallbackLambda = [this, SharedUserId, FileName](const EOS_PlayerDataStorage_WriteFileCallbackInfo* Data)
+	{
+		bool bWasSuccessful = Data->ResultCode == EOS_EResult::EOS_Success;
+
+		FUserCloudFileCollection* UserCloudFileCollection = FileSetsPerUser.Find(SharedUserId);
+		if (UserCloudFileCollection != nullptr)
+		{
+			FEOSUserCloudFile* UserCloudFile = UserCloudFileCollection->Find(FileName);
+			if (UserCloudFile != nullptr)
+			{
+				if (UserCloudFile->FileTransferRequest != nullptr)
+				{
+					EOS_PlayerDataStorageFileTransferRequest_Release(UserCloudFile->FileTransferRequest);
+					UserCloudFile->FileTransferRequest = nullptr;
+				}
+
+				if (bWasSuccessful)
+				{
+					UserCloudFile->bIsLoaded = true;
+					UserCloudFile->bInProgress = false;
+					UE_LOG_ONLINE_CLOUD(Verbose, TEXT("[FOnlineUserCloudEOS::WriteUserFile] Wrote file %s with size %d"), *UserCloudFile->Filename, UserCloudFile->ContentSize);
+				}
+				else
+				{
+					// If we fail to complete writing the file, discard it from the known files
+					FileSetsPerUser.Find(SharedUserId)->Remove(FileName);
+
+					UE_LOG_ONLINE_CLOUD(Warning, TEXT("[FOnlineUserCloudEOS::WriteUserFile] EOS_PlayerDataStorage_WriteFile was not successful. Finished with error %s"), ANSI_TO_TCHAR(EOS_EResult_ToString(Data->ResultCode)));
+				}
+			}
+			else
+			{
+				bWasSuccessful = false;
+				UE_LOG_ONLINE_CLOUD(Warning, TEXT("[FOnlineUserCloudEOS::WriteUserFile] Unknown transfer request for file %s"), *FileName);
+			}
+		}
+		else
+		{
+			UE_LOG_ONLINE_CLOUD(Warning, TEXT("[FOnlineUserCloudEOS::WriteUserFile] Unknown user %s for file %s's transfer request"), *SharedUserId->ToString(), *FileName);
+		}
+
+		TriggerOnWriteUserFileCompleteDelegates(bWasSuccessful, *SharedUserId, FileName);
+	};
+
+	EOS_PlayerDataStorage_WriteFileOptions WriteFileOptions = {};
+	WriteFileOptions.ApiVersion = EOS_PLAYERDATASTORAGE_WRITEFILEOPTIONS_API_LATEST;
+	WriteFileOptions.LocalUserId = EOSSubsystem->UserManager->GetProductUserId(UserId);
+	WriteFileOptions.Filename = FileNameUtf8.Get();
+	WriteFileOptions.ChunkLengthBytes = (uint32_t)ReadChunkSize;
+	WriteFileOptions.WriteFileDataCallback = CallbackObj->GetNested1CallbackPtr();
+	WriteFileOptions.FileTransferProgressCallback = CallbackObj->GetNested2CallbackPtr();
+
+	EOS_HPlayerDataStorageFileTransferRequest FileTransferRequest = EOS_PlayerDataStorage_WriteFile(EOSSubsystem->PlayerDataStorageHandle, &WriteFileOptions, CallbackObj, CallbackObj->GetCallbackPtr());
+
+	if (FileTransferRequest != nullptr)
+	{
+		FEOSUserCloudFile UserCloudFile;
+		UserCloudFile.Filename = FileName;
+		UserCloudFile.FileTransferRequest = FileTransferRequest;
+		UserCloudFile.bInProgress = true;
+		UserCloudFile.ContentSize = FileContents.Num();
+		UserCloudFile.Contents = FileContents;
+		FileSetsPerUser.FindOrAdd(SharedUserId).FindOrAdd(FileName) = MoveTemp(UserCloudFile); // Replace the last title file, or create a new entry, same with the user
+	}
+	else
+	{
+		EOSSubsystem->ExecuteNextTick([this, UserIdRef = UserId.AsShared(), FileName]()
+			{
+				UE_LOG_ONLINE_CLOUD(Warning, TEXT("[FOnlineUserCloudEOS::WriteUserFile] Failed to create a transfer request for user's %s file with name %s"), *UserIdRef->ToString(), *FileName);
+				TriggerOnWriteUserFileCompleteDelegates(false, *UserIdRef, FileName);
+			});		
+	}
+
+	return true;
+}
+
+void FOnlineUserCloudEOS::CancelWriteUserFile(const FUniqueNetId& UserId, const FString& FileName)
+{
+	FUniqueNetIdPtr UniqueNetId = EOSSubsystem->UserManager->GetUniquePlayerId(EOSSubsystem->UserManager->GetLocalUserNumFromUniqueNetId(UserId));
+	if (!UniqueNetId.IsValid())
+	{
+		EOSSubsystem->ExecuteNextTick([this, UserIdRef = UserId.AsShared(), FileName]()
+			{
+				UE_LOG_ONLINE_CLOUD(Warning, TEXT("[FOnlineUserCloudEOS::CancelWriteUserFile] Unable to cancel file writing. User %s is not a local user"), *UserIdRef->ToString());
+				TriggerOnWriteUserFileCanceledDelegates(false, *UserIdRef, FileName);
+			});
+
+		return;
+	}
+
+	bool bWasSuccessful = false;
+
+	FUserCloudFileCollection* UserCloudFileCollection = FileSetsPerUser.Find(UniqueNetId.ToSharedRef());
+	if (UserCloudFileCollection != nullptr)
+	{
+		FEOSUserCloudFile* UserCloudFile = UserCloudFileCollection->Find(FileName);
+		if (UserCloudFile != nullptr)
+		{
+			if (UserCloudFile->bInProgress)
+			{
+				EOS_EResult Result = EOS_PlayerDataStorageFileTransferRequest_CancelRequest(UserCloudFile->FileTransferRequest);
+				bWasSuccessful = Result == EOS_EResult::EOS_Success;
+				if (bWasSuccessful)
+				{
+					UE_LOG_ONLINE_CLOUD(Verbose, TEXT("[FOnlineUserCloudEOS::CancelWriteUserFile] EOS_PlayerDataStorageFileTransferRequest_CancelRequest was successful. Cancelled write operation of file %s for user %s."), *FileName, *UserId.ToString());
+				}
+				else
+				{
+					// Result code will be EOS_NoChange if request had already completed (can't be canceled), and EOS_AlreadyPending if it's already been canceled before (this is a final state for a canceled request and won't change over time)
+					UE_LOG_ONLINE_CLOUD(Warning, TEXT("[FOnlineUserCloudEOS::CancelWriteUserFile] EOS_PlayerDataStorageFileTransferRequest_CancelRequest was not successful. Finished with error %s"), ANSI_TO_TCHAR(EOS_EResult_ToString(Result)));
+				}
+			}
+			else
+			{
+				UE_LOG_ONLINE_CLOUD(Warning, TEXT("[FOnlineUserCloudEOS::CancelWriteUserFile] File %s is not in progress of reading or writing. Unable to cancel."), *FileName);
+			}
+		}
+		else
+		{
+			UE_LOG_ONLINE_CLOUD(Warning, TEXT("[FOnlineUserCloudEOS::CancelWriteUserFile] Unknown file %s"), *FileName);
+		}
+	}
+	else
+	{
+		UE_LOG_ONLINE_CLOUD(Warning, TEXT("[FOnlineUserCloudEOS::CancelWriteUserFile] Unknown user %s"), *UserId.ToString());
+	}
+
+	EOSSubsystem->ExecuteNextTick([this, bWasSuccessful, UserIdRef = UserId.AsShared(), FileName]()
+		{
+			TriggerOnWriteUserFileCanceledDelegates(bWasSuccessful, *UserIdRef, FileName);
+		});
+}
+
+bool FOnlineUserCloudEOS::DeleteUserFile(const FUniqueNetId& UserId, const FString& FileName, bool bShouldCloudDelete, bool bShouldLocallyDelete)
+{
+	FUniqueNetIdPtr UniqueNetId = EOSSubsystem->UserManager->GetUniquePlayerId(EOSSubsystem->UserManager->GetLocalUserNumFromUniqueNetId(UserId));
+	if (!UniqueNetId.IsValid())
+	{
+		EOSSubsystem->ExecuteNextTick([this, UserIdRef = UserId.AsShared(), FileName]()
+			{
+				UE_LOG_ONLINE_CLOUD(Warning, TEXT("[FOnlineUserCloudEOS::DeleteUserFile] Unable to delete user file. User %s is not a local user"), *UserIdRef->ToString());
+				TriggerOnDeleteUserFileCompleteDelegates(false, *UserIdRef, FileName);
+			});
+
+		return true;
+	}
+
+	// Local deletion
+	if (bShouldLocallyDelete)
+	{
+		bool bWasLocalDeletionSuccessful = false;
+
+		FUserCloudFileCollection* UserCloudFileCollection = FileSetsPerUser.Find(UniqueNetId.ToSharedRef());
+		if (UserCloudFileCollection != nullptr)
+		{
+			FEOSUserCloudFile* UserCloudFile = UserCloudFileCollection->Find(FileName);
+			if (UserCloudFile != nullptr)
+			{
+				// If this file is being read or written, don't delete it.
+				if (!UserCloudFile->bInProgress)
+				{
+					UserCloudFile->Unload();
+
+					bWasLocalDeletionSuccessful = true;
+				}
+				else
+				{
+					UE_LOG_ONLINE_CLOUD(Warning, TEXT("[FOnlineUserCloudEOS::DeleteUserFile] Unable to delete. File %s for user %s is in the process of being read or written."), *FileName, *UserId.ToString());
+				}
+			}
+			else
+			{
+				UE_LOG_ONLINE_CLOUD(Warning, TEXT("[FOnlineUserCloudEOS::DeleteUserFile] Unknown file (%s)"), *FileName);
+			}
+		}
+		else
+		{
+			UE_LOG_ONLINE_CLOUD(Warning, TEXT("[FOnlineUserCloudEOS::DeleteUserFile] Unknown user (%s)"), *UserId.ToString());
+		}
+
+		if (!bShouldCloudDelete)
+		{
+			EOSSubsystem->ExecuteNextTick([this, bWasLocalDeletionSuccessful, UserIdRef = UserId.AsShared(), FileName]()
+				{
+					TriggerOnDeleteUserFileCompleteDelegates(bWasLocalDeletionSuccessful, *UserIdRef, FileName);
+				});
+
+			return true;
+		}
+	}
+
+	// Cloud deletion
+	if (bShouldCloudDelete)
+	{
+		FTCHARToUTF8 FileNameUtf8(*FileName);
+
+		EOS_PlayerDataStorage_DeleteFileOptions Options = {};
+		Options.ApiVersion = EOS_PLAYERDATASTORAGE_DELETEFILEOPTIONS_API_LATEST;
+		Options.LocalUserId = EOSSubsystem->UserManager->GetProductUserId(UserId);
+		Options.Filename = FileNameUtf8.Get();
+
+		FOnDeleteFileCallback* CallbackObj = new FOnDeleteFileCallback();
+		CallbackObj->CallbackLambda = [this, UserIdRef = UserId.AsShared(), FileName](const EOS_PlayerDataStorage_DeleteFileCallbackInfo* Data)
+		{
+			bool bWasSuccessful = Data->ResultCode == EOS_EResult::EOS_Success;
+			if (bWasSuccessful)
+			{
+				UE_LOG_ONLINE_CLOUD(Verbose, TEXT("[FOnlineUserCloudEOS::DeleteUserFile] EOS_PlayerDataStorage_DeleteFile was successful."));
+			}
+			else
+			{
+				// File deletion operations can fail if the user does not own the file
+				UE_LOG_ONLINE_CLOUD(Warning, TEXT("[FOnlineUserCloudEOS::DeleteUserFile] EOS_PlayerDataStorage_DeleteFile was not successful for file %s. Finished with error %s"), *FileName, ANSI_TO_TCHAR(EOS_EResult_ToString(Data->ResultCode)));
+			}
+
+			TriggerOnDeleteUserFileCompleteDelegates(bWasSuccessful, *UserIdRef, FileName);
+		};
+
+		EOS_PlayerDataStorage_DeleteFile(EOSSubsystem->PlayerDataStorageHandle, &Options, CallbackObj, CallbackObj->GetCallbackPtr());
+	}
+
+	return true;
+}
+
+bool FOnlineUserCloudEOS::RequestUsageInfo(const FUniqueNetId& UserId)
+{
+	UE_LOG_ONLINE_CLOUD(Warning, TEXT("[FOnlineUserCloudEOS::RequestUsageInfo] Not supported by API"));
+	return false;
+}
+
+void FOnlineUserCloudEOS::DumpCloudState(const FUniqueNetId& UserId)
+{
+	FUniqueNetIdPtr UniqueNetId = EOSSubsystem->UserManager->GetUniquePlayerId(EOSSubsystem->UserManager->GetLocalUserNumFromUniqueNetId(UserId));
+	if (!UniqueNetId.IsValid())
+	{
+		UE_LOG_ONLINE_CLOUD(Warning, TEXT("[FOnlineUserCloudEOS::DumpCloudState] Unable to dump cloud state. User %s is not a local user"), *UserId.ToString());
+		return;
+	}
+
+	// Local deletion
+	FUserCloudFileCollection* UserCloudFileCollection = FileSetsPerUser.Find(UniqueNetId.ToSharedRef());
+	if (UserCloudFileCollection != nullptr)
+	{
+		UE_LOG_ONLINE_CLOUD(Log, TEXT("[FOnlineUserCloudEOS::DumpCloudState] User %s has %d files cached."), *UserId.ToString(), UserCloudFileCollection->Num());
+	}
+	else
+	{
+		UE_LOG_ONLINE_CLOUD(Warning, TEXT("[FOnlineUserCloudEOS::DumpCloudState] Unknown user (%s)"), *UserId.ToString());
+	}
+}
+
+void FOnlineUserCloudEOS::DumpCloudFileState(const FUniqueNetId& UserId, const FString& FileName)
+{
+	FUniqueNetIdPtr UniqueNetId = EOSSubsystem->UserManager->GetUniquePlayerId(EOSSubsystem->UserManager->GetLocalUserNumFromUniqueNetId(UserId));
+	if (!UniqueNetId.IsValid())
+	{
+		UE_LOG_ONLINE_CLOUD(Warning, TEXT("[FOnlineUserCloudEOS::DumpCloudFileState] Unable to dump cloud file state. User %s is not a local user"), *UserId.ToString());
+		return;
+	}
+
+	FUserCloudFileCollection* UserCloudFileCollection = FileSetsPerUser.Find(UniqueNetId.ToSharedRef());
+	if (UserCloudFileCollection != nullptr)
+	{
+		FEOSUserCloudFile* UserCloudFile = UserCloudFileCollection->Find(FileName);
+		if (UserCloudFile != nullptr)
+		{
+			UE_LOG_ONLINE_CLOUD(Log, TEXT("[FOnlineUserCloudEOS::DumpCloudFileState] File %s state: ContentSize (%d), IsLoaded (%d), InProgress (%d)"), *UserCloudFile->Filename, UserCloudFile->ContentSize, UserCloudFile->bIsLoaded, UserCloudFile->bInProgress);
+		}
+		else
+		{
+			UE_LOG_ONLINE_CLOUD(Warning, TEXT("[FOnlineUserCloudEOS::DumpCloudFileState] Unknown file (%s)"), *FileName);
+		}
+	}
+	else
+	{
+		UE_LOG_ONLINE_CLOUD(Warning, TEXT("[FOnlineUserCloudEOS::DumpCloudFileState] Unknown user (%s)"), *UserId.ToString());
+	}
+}
+
+void WriteRandomFile(TArray<uint8>& Buffer, int32 Size)
+{
+	Buffer.Empty(Size);
+	Buffer.AddUninitialized(Size);
+	for (int32 i = 0; i < Size; i++)
+	{
+		Buffer[i] = i % 255;
+	}
+}
+
+bool FOnlineUserCloudEOS::HandleUserCloudExec(UWorld* InWorld, const TCHAR* Cmd, FOutputDevice& Ar)
+{
+	bool bWasHandled = false;
+
+	if (FParse::Command(&Cmd, TEXT("ENUMERATEUSERFILES")))
+	{
+		int UserIndex = FCString::Atoi(*FParse::Token(Cmd, false));
+
+		EnumerateUserFiles(*EOSSubsystem->UserManager->GetLocalUniqueNetIdEOS(UserIndex));
+
+		bWasHandled = true;
+	}
+	else if(FParse::Command(&Cmd, TEXT("GETUSERFILELIST")))
+	{
+		int UserIndex = FCString::Atoi(*FParse::Token(Cmd, false));
+
+		TArray<FCloudFileHeader> UserFileList;
+		GetUserFileList(*EOSSubsystem->UserManager->GetLocalUniqueNetIdEOS(UserIndex), UserFileList);
+
+		bWasHandled = true;
+	}
+	else if (FParse::Command(&Cmd, TEXT("WRITEUSERFILE")))
+	{
+		int UserIndex = FCString::Atoi(*FParse::Token(Cmd, false));
+		FString FileName = FParse::Token(Cmd, false);
+		int32 FileSize = FCString::Atoi(*FParse::Token(Cmd, false));
+		TArray<uint8> FileContents;
+		WriteRandomFile(FileContents, FileSize);
+
+		WriteUserFile(*EOSSubsystem->UserManager->GetLocalUniqueNetIdEOS(UserIndex), FileName, FileContents);
+
+		bWasHandled = true;
+	}
+	else if (FParse::Command(&Cmd, TEXT("READUSERFILE")))
+	{
+		int UserIndex = FCString::Atoi(*FParse::Token(Cmd, false));
+		FString FileName = FParse::Token(Cmd, false);
+
+		ReadUserFile(*EOSSubsystem->UserManager->GetLocalUniqueNetIdEOS(UserIndex), FileName);
+
+		bWasHandled = true;
+	}
+	else if (FParse::Command(&Cmd, TEXT("GETFILECONTENTS")))
+	{
+		int UserIndex = FCString::Atoi(*FParse::Token(Cmd, false));
+		FString FileName = FParse::Token(Cmd, false);
+
+		TArray<uint8> FileContents;
+		GetFileContents(*EOSSubsystem->UserManager->GetLocalUniqueNetIdEOS(UserIndex), FileName, FileContents);
+
+		bWasHandled = true;
+	}
+	else if (FParse::Command(&Cmd, TEXT("DELETEUSERFILE")))
+	{
+		int UserIndex = FCString::Atoi(*FParse::Token(Cmd, false));
+		FString FileName = FParse::Token(Cmd, false);
+		bool bShouldCloudDelete = (bool)FCString::Atoi(*FParse::Token(Cmd, false));
+		bool bShouldLocallyDelete = (bool)FCString::Atoi(*FParse::Token(Cmd, false));
+
+		DeleteUserFile(*EOSSubsystem->UserManager->GetLocalUniqueNetIdEOS(UserIndex), FileName, bShouldCloudDelete, bShouldLocallyDelete);
+
+		bWasHandled = true;
+	}
+	else if (FParse::Command(&Cmd, TEXT("CLEARFILES")))
+	{
+		int UserIndex = FCString::Atoi(*FParse::Token(Cmd, false));
+
+		ClearFiles(*EOSSubsystem->UserManager->GetLocalUniqueNetIdEOS(UserIndex));
+
+		bWasHandled = true;
+	}
+	else if (FParse::Command(&Cmd, TEXT("CLEARFILE")))
+	{
+		int UserIndex = FCString::Atoi(*FParse::Token(Cmd, false));
+		FString FileName = FParse::Token(Cmd, false);
+
+		ClearFile(*EOSSubsystem->UserManager->GetLocalUniqueNetIdEOS(UserIndex), FileName);
+
+		bWasHandled = true;
+	}
+	else if (FParse::Command(&Cmd, TEXT("CANCELWRITEUSERFILE")))
+	{
+		int UserIndex = FCString::Atoi(*FParse::Token(Cmd, false));
+		FString FileName = FParse::Token(Cmd, false);
+
+		CancelWriteUserFile(*EOSSubsystem->UserManager->GetLocalUniqueNetIdEOS(UserIndex), FileName);
+
+		bWasHandled = true;
+	}
+	else if (FParse::Command(&Cmd, TEXT("DUMPCLOUDSTATE")))
+	{
+		int UserIndex = FCString::Atoi(*FParse::Token(Cmd, false));
+
+		DumpCloudState(*EOSSubsystem->UserManager->GetLocalUniqueNetIdEOS(UserIndex));
+
+		bWasHandled = true;
+	}
+	else if (FParse::Command(&Cmd, TEXT("DUMPCLOUDFILESTATE")))
+	{
+		int UserIndex = FCString::Atoi(*FParse::Token(Cmd, false));
+		FString FileName = FParse::Token(Cmd, false);
+
+		DumpCloudFileState(*EOSSubsystem->UserManager->GetLocalUniqueNetIdEOS(UserIndex), FileName);
+
+		bWasHandled = true;
+	}
+
+	return bWasHandled;
+}
+
+#endif
Index: Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Private/OnlineUserCloudEOS.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Private/OnlineUserCloudEOS.h b/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Private/OnlineUserCloudEOS.h
new file mode 100644
--- /dev/null	(date 1641576012000)
+++ b/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Private/OnlineUserCloudEOS.h	(date 1641576012000)
@@ -0,0 +1,78 @@
+// Copyright Epic Games, Inc. All Rights Reserved.
+
+#pragma once
+
+#include "CoreMinimal.h"
+#include "Online/CoreOnline.h"
+#include "Interfaces/OnlineUserCloudInterface.h"
+#include "OnlineSubsystemEOSPackage.h"
+#include "OnlineSubsystemEOSTypes.h"
+
+class FOnlineSubsystemEOS;
+
+#if WITH_EOS_SDK
+	#include "eos_playerdatastorage_types.h"
+
+struct FEOSUserCloudFile
+{
+	TArray<uint8> Contents;
+	size_t ContentSize;
+	size_t ContentIndex;
+	bool bIsLoaded;
+	bool bInProgress;
+	FString Filename;
+	EOS_HPlayerDataStorageFileTransferRequest FileTransferRequest;
+
+	FEOSUserCloudFile() : ContentSize(0), ContentIndex(0), bIsLoaded(false), bInProgress(false)
+	{
+	}
+
+	void Unload();
+};
+
+typedef TMap<FString, FEOSUserCloudFile> FUserCloudFileCollection;
+
+class FOnlineUserCloudEOS
+	: public IOnlineUserCloud, public TSharedFromThis<FOnlineUserCloudEOS, ESPMode::ThreadSafe>
+{
+public:
+	FOnlineUserCloudEOS() = delete;
+	virtual ~FOnlineUserCloudEOS() = default;
+
+//~ IOnlineUserCloud
+	virtual bool GetFileContents(const FUniqueNetId& UserId, const FString& FileName, TArray<uint8>& FileContents) override;
+	virtual bool ClearFiles(const FUniqueNetId& UserId) override;
+	virtual bool ClearFile(const FUniqueNetId& UserId, const FString& FileName) override;
+	virtual void EnumerateUserFiles(const FUniqueNetId& UserId) override;
+	virtual void GetUserFileList(const FUniqueNetId& UserId, TArray<FCloudFileHeader>& UserFiles) override;
+	virtual bool ReadUserFile(const FUniqueNetId& UserId, const FString& FileName) override;
+	virtual bool WriteUserFile(const FUniqueNetId& UserId, const FString& FileName, TArray<uint8>& FileContents, bool bCompressBeforeUpload = false) override;
+	virtual void CancelWriteUserFile(const FUniqueNetId& UserId, const FString& FileName) override;
+	virtual bool DeleteUserFile(const FUniqueNetId& UserId, const FString& FileName, bool bShouldCloudDelete, bool bShouldLocallyDelete) override;
+	virtual bool RequestUsageInfo(const FUniqueNetId& UserId) override;
+	virtual void DumpCloudState(const FUniqueNetId& UserId) override;
+	virtual void DumpCloudFileState(const FUniqueNetId& UserId, const FString& FileName) override;
+//~ IOnlineUserCloud
+
+PACKAGE_SCOPE:
+	FOnlineUserCloudEOS(FOnlineSubsystemEOS* InSubsystem)
+		: EOSSubsystem(InSubsystem)
+	{
+	}
+
+	bool HandleUserCloudExec(UWorld* InWorld, const TCHAR* Cmd, FOutputDevice& Ar);
+
+protected:
+	FOnlineSubsystemEOS* EOSSubsystem;
+
+private:
+	/** Results of the last file enumeration per user */
+	TUniqueNetIdMap<TArray<FCloudFileHeader>> QueryFileSetsPerUser;
+
+	/** The lists of available files per user, indexed by filename that have been or are loaded */
+	TUniqueNetIdMap<FUserCloudFileCollection> FileSetsPerUser;
+};
+
+typedef TSharedPtr<FOnlineUserCloudEOS, ESPMode::ThreadSafe> FOnlineUserCloudEOSPtr;
+
+#endif
\ No newline at end of file
Index: Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Private/OnlineStatsEOS.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Private/OnlineStatsEOS.h b/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Private/OnlineStatsEOS.h
new file mode 100644
--- /dev/null	(date 1641575208000)
+++ b/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Private/OnlineStatsEOS.h	(date 1641575208000)
@@ -0,0 +1,51 @@
+// Copyright Epic Games, Inc. All Rights Reserved.
+
+#pragma once
+
+#include "Interfaces/OnlineStatsInterface.h"
+#include "OnlineSubsystemEOSPackage.h"
+#include "OnlineSubsystemEOSTypes.h"
+
+class FOnlineSubsystemEOS;
+
+#if WITH_EOS_SDK
+#include "eos_stats_types.h"
+
+/**
+ * Interface for interacting with EOS stats
+ */
+class FOnlineStatsEOS :
+	public IOnlineStats
+{
+public:
+	FOnlineStatsEOS() = delete;
+	virtual ~FOnlineStatsEOS() = default;
+
+// IOnlineStats Interface
+	virtual void QueryStats(const FUniqueNetIdRef LocalUserId, const FUniqueNetIdRef StatsUser, const FOnlineStatsQueryUserStatsComplete& Delegate) override;
+	virtual void QueryStats(const FUniqueNetIdRef LocalUserId, const TArray<FUniqueNetIdRef>& StatUsers, const TArray<FString>& StatNames, const FOnlineStatsQueryUsersStatsComplete& Delegate) override;
+	virtual TSharedPtr<const FOnlineStatsUserStats> GetStats(const FUniqueNetIdRef StatsUserId) const override;
+	virtual void UpdateStats(const FUniqueNetIdRef LocalUserId, const TArray<FOnlineStatsUserUpdatedStats>& UpdatedUserStats, const FOnlineStatsUpdateStatsComplete& Delegate) override;
+#if !UE_BUILD_SHIPPING
+	virtual void ResetStats(const FUniqueNetIdRef StatsUserId) override;
+#endif
+// ~IOnlineStats Interface
+
+PACKAGE_SCOPE:
+	FOnlineStatsEOS(FOnlineSubsystemEOS* InSubsystem)
+		: EOSSubsystem(InSubsystem)
+	{
+	}
+
+private:
+	void WriteStats(EOS_ProductUserId LocalUserId, EOS_ProductUserId UserId, const FOnlineStatsUserUpdatedStats& PlayerStats);
+
+	/** Reference to the main EOS subsystem */
+	FOnlineSubsystemEOS* EOSSubsystem;
+	/** Cached list of stats for users as they arrive */
+	TUniqueNetIdMap<TSharedRef<FOnlineStatsUserStats>> StatsCache;
+};
+
+typedef TSharedPtr<FOnlineStatsEOS, ESPMode::ThreadSafe> FOnlineStatsEOSPtr;
+
+#endif
Index: Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Private/OnlineAchievementsEOS.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Private/OnlineAchievementsEOS.h b/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Private/OnlineAchievementsEOS.h
new file mode 100644
--- /dev/null	(date 1641576012000)
+++ b/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Private/OnlineAchievementsEOS.h	(date 1641576012000)
@@ -0,0 +1,57 @@
+// Copyright Epic Games, Inc. All Rights Reserved.
+
+#pragma once
+
+#include "CoreMinimal.h"
+#include "Online/CoreOnline.h"
+#include "Interfaces/OnlineAchievementsInterface.h"
+#include "OnlineSubsystemEOSPackage.h"
+#include "OnlineSubsystemEOSTypes.h"
+
+class FOnlineSubsystemEOS;
+
+#if WITH_EOS_SDK
+#include "eos_achievements_types.h"
+
+/**
+ * Interface for interacting with EOS achievements
+ */
+class FOnlineAchievementsEOS :
+	public IOnlineAchievements
+{
+public:
+	FOnlineAchievementsEOS() = delete;
+	virtual ~FOnlineAchievementsEOS() = default;
+
+// IOnlineAchievements Interface
+	virtual void WriteAchievements(const FUniqueNetId& PlayerId, FOnlineAchievementsWriteRef& WriteObject, const FOnAchievementsWrittenDelegate& Delegate = FOnAchievementsWrittenDelegate())  override;
+	virtual void QueryAchievements(const FUniqueNetId& PlayerId, const FOnQueryAchievementsCompleteDelegate& Delegate = FOnQueryAchievementsCompleteDelegate())  override;
+	virtual void QueryAchievementDescriptions(const FUniqueNetId& PlayerId, const FOnQueryAchievementsCompleteDelegate& Delegate = FOnQueryAchievementsCompleteDelegate())  override;
+	virtual EOnlineCachedResult::Type GetCachedAchievement(const FUniqueNetId& PlayerId, const FString& AchievementId, FOnlineAchievement& OutAchievement)  override;
+	virtual EOnlineCachedResult::Type GetCachedAchievements(const FUniqueNetId& PlayerId, TArray<FOnlineAchievement>& OutAchievements)  override;
+	virtual EOnlineCachedResult::Type GetCachedAchievementDescription(const FString& AchievementId, FOnlineAchievementDesc& OutAchievementDesc)  override;
+#if !UE_BUILD_SHIPPING
+	virtual bool ResetAchievements(const FUniqueNetId& PlayerId) override;
+#endif
+// ~IOnlineAchievements Interface
+
+PACKAGE_SCOPE:
+	FOnlineAchievementsEOS(FOnlineSubsystemEOS* InSubsystem)
+		: EOSSubsystem(InSubsystem)
+	{
+	}
+
+private:
+	/** Reference to the main EOS subsystem */
+	FOnlineSubsystemEOS* EOSSubsystem;
+	/** Holds the cached info from the last time this was called */
+	TUniqueNetIdMap<TSharedRef<TArray<FOnlineAchievement>>> CachedAchievementsMap;
+	/** Holds the cached info from the last time this was called */
+	TArray<FOnlineAchievementDesc> CachedAchievementDefinitions;
+	/** Hack to work around the fact the description doesn't include the ID */
+	TMap<FString, FOnlineAchievementDesc*> CachedAchievementDefinitionsMap;
+};
+
+typedef TSharedPtr<FOnlineAchievementsEOS, ESPMode::ThreadSafe> FOnlineAchievementsEOSPtr;
+
+#endif
Index: Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Private/OnlineLeaderboardsEOS.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Private/OnlineLeaderboardsEOS.h b/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Private/OnlineLeaderboardsEOS.h
new file mode 100644
--- /dev/null	(date 1641575208000)
+++ b/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Private/OnlineLeaderboardsEOS.h	(date 1641575208000)
@@ -0,0 +1,51 @@
+// Copyright Epic Games, Inc. All Rights Reserved.
+
+#pragma once
+
+#include "Interfaces/OnlineLeaderboardInterface.h"
+#include "OnlineSubsystemEOSPackage.h"
+#include "OnlineSubsystemEOSTypes.h"
+
+class FOnlineSubsystemEOS;
+
+#if WITH_EOS_SDK
+#include "eos_leaderboards_types.h"
+
+#define EOS_MAX_NUM_RANKINGS 1000
+
+/**
+ * Interface for interacting with EOS stats
+ */
+class FOnlineLeaderboardsEOS :
+	public IOnlineLeaderboards
+{
+public:
+	FOnlineLeaderboardsEOS() = delete;
+	virtual ~FOnlineLeaderboardsEOS() = default;
+
+// IOnlineLeaderboards Interface
+	virtual bool ReadLeaderboards(const TArray< FUniqueNetIdRef >& Players, FOnlineLeaderboardReadRef& ReadObject) override;
+	virtual bool ReadLeaderboardsForFriends(int32 LocalUserNum, FOnlineLeaderboardReadRef& ReadObject) override;
+	virtual bool ReadLeaderboardsAroundRank(int32 Rank, uint32 Range, FOnlineLeaderboardReadRef& ReadObject) override;
+	virtual bool ReadLeaderboardsAroundUser(FUniqueNetIdRef Player, uint32 Range, FOnlineLeaderboardReadRef& ReadObject) override;
+	virtual void FreeStats(FOnlineLeaderboardRead& ReadObject) override;
+	virtual bool WriteLeaderboards(const FName& SessionName, const FUniqueNetId& Player, FOnlineLeaderboardWrite& WriteObject) override;
+	virtual bool FlushLeaderboards(const FName& SessionName) override;
+	virtual bool WriteOnlinePlayerRatings(const FName& SessionName, int32 LeaderboardId, const TArray<FOnlinePlayerScore>& PlayerScores) override;
+// ~IOnlineLeaderboards Interface
+
+PACKAGE_SCOPE:
+	FOnlineLeaderboardsEOS(FOnlineSubsystemEOS* InSubsystem)
+		: EOSSubsystem(InSubsystem)
+	{
+	}
+
+private:
+
+	/** Reference to the main EOS subsystem */
+	FOnlineSubsystemEOS* EOSSubsystem;
+};
+
+typedef TSharedPtr<FOnlineLeaderboardsEOS, ESPMode::ThreadSafe> FOnlineLeaderboardsEOSPtr;
+
+#endif
Index: Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Private/NboSerializerEOS.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Private/NboSerializerEOS.h b/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Private/NboSerializerEOS.h
new file mode 100644
--- /dev/null	(date 1641576012000)
+++ b/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Private/NboSerializerEOS.h	(date 1641576012000)
@@ -0,0 +1,110 @@
+// Copyright Epic Games, Inc. All Rights Reserved.
+
+#pragma once
+
+#include "CoreMinimal.h"
+#include "OnlineSubsystemEOSTypes.h"
+#include "NboSerializer.h"
+
+#if WITH_EOS_SDK
+
+/**
+ * Serializes data in network byte order form into a buffer
+ */
+class FNboSerializeToBufferEOS : public FNboSerializeToBuffer
+{
+public:
+	/** Default constructor zeros num bytes*/
+	FNboSerializeToBufferEOS() :
+		FNboSerializeToBuffer(512)
+	{
+	}
+
+	/** Constructor specifying the size to use */
+	FNboSerializeToBufferEOS(uint32 Size) :
+		FNboSerializeToBuffer(Size)
+	{
+	}
+
+	/**
+	 * Adds EOS session info to the buffer
+	 */
+ 	friend inline FNboSerializeToBufferEOS& operator<<(FNboSerializeToBufferEOS& Ar, const FOnlineSessionInfoEOS& SessionInfo)
+ 	{
+		check(SessionInfo.HostAddr.IsValid());
+		// Skip SessionType (assigned at creation)
+		Ar << *SessionInfo.SessionId;
+		Ar << *SessionInfo.HostAddr;
+		return Ar;
+ 	}
+
+	/**
+	 * Adds EOS Unique Id to the buffer
+	 */
+	friend inline FNboSerializeToBufferEOS& operator<<(FNboSerializeToBufferEOS& Ar, const FUniqueNetIdEOS& UniqueId)
+	{
+		Ar << UniqueId.UniqueNetIdStr;
+		Ar << UniqueId.EpicAccountIdStr;
+		Ar << UniqueId.ProductUserIdStr;
+		return Ar;
+	}
+
+	/**
+	 * Adds string Unique Id to the buffer
+	 */
+	friend inline FNboSerializeToBufferEOS& operator<<(FNboSerializeToBufferEOS& Ar, const FUniqueNetIdString& UniqueId)
+	{
+		Ar << UniqueId.UniqueNetIdStr;
+		return Ar;
+	}
+};
+
+/**
+ * Class used to write data into packets for sending via system link
+ */
+class FNboSerializeFromBufferEOS : public FNboSerializeFromBuffer
+{
+public:
+	/**
+	 * Initializes the buffer, size, and zeros the read offset
+	 */
+	FNboSerializeFromBufferEOS(uint8* Packet,int32 Length) :
+		FNboSerializeFromBuffer(Packet,Length)
+	{
+	}
+
+	/**
+	 * Reads EOS session info from the buffer
+	 */
+ 	friend inline FNboSerializeFromBufferEOS& operator>>(FNboSerializeFromBufferEOS& Ar, FOnlineSessionInfoEOS& SessionInfo)
+ 	{
+		check(SessionInfo.HostAddr.IsValid());
+		// Skip SessionType (assigned at creation)
+		SessionInfo.SessionId = FUniqueNetIdEOS::Create();
+		Ar >> *ConstCastSharedRef<FUniqueNetIdString>(SessionInfo.SessionId);
+		Ar >> *SessionInfo.HostAddr;
+		return Ar;
+ 	}
+
+	/**
+	 * Reads EOS Unique Id from the buffer
+	 */
+	friend inline FNboSerializeFromBufferEOS& operator>>(FNboSerializeFromBufferEOS& Ar, FUniqueNetIdEOS& UniqueId)
+	{
+		Ar >> UniqueId.UniqueNetIdStr;
+		Ar >> UniqueId.EpicAccountIdStr;
+		Ar >> UniqueId.ProductUserIdStr;
+		return Ar;
+	}
+
+	/**
+	 * Reads string Unique Id from the buffer
+	 */
+	friend inline FNboSerializeFromBufferEOS& operator>>(FNboSerializeFromBufferEOS& Ar, FUniqueNetIdString& UniqueId)
+	{
+		Ar >> UniqueId.UniqueNetIdStr;
+		return Ar;
+	}
+};
+
+#endif
Index: Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Private/SocketSubsystemEOS.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Private/SocketSubsystemEOS.cpp b/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Private/SocketSubsystemEOS.cpp
new file mode 100644
--- /dev/null	(date 1641575208000)
+++ b/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Private/SocketSubsystemEOS.cpp	(date 1641575208000)
@@ -0,0 +1,261 @@
+// Copyright Epic Games, Inc. All Rights Reserved.
+
+#include "SocketSubsystemEOS.h"
+#include "InternetAddrEOS.h"
+#include "SocketEOS.h"
+#include "SocketTypes.h"
+#include "Containers/Ticker.h"
+#include "OnlineSubsystem.h"
+#include "Interfaces/OnlineSessionInterface.h"
+#include "Interfaces/OnlineIdentityInterface.h"
+#include "OnlineSessionSettings.h"
+#include "Misc/ConfigCacheIni.h"
+#include "OnlineSubsystemUtils.h"
+#include "OnlineSubsystemEOS.h"
+#include "UserManagerEOS.h"
+#include "SocketSubsystemModule.h"
+
+FSocketSubsystemEOS::FSocketSubsystemEOS(FOnlineSubsystemEOS* InSubsystemEOS)
+	: SubsystemEOS(InSubsystemEOS)
+	, LastSocketError(ESocketErrors::SE_NO_ERROR)
+{
+}
+
+FSocketSubsystemEOS::~FSocketSubsystemEOS() = default;
+
+bool FSocketSubsystemEOS::Init(FString& Error)
+{
+	FSocketSubsystemModule& SocketSubsystem = FModuleManager::LoadModuleChecked<FSocketSubsystemModule>("Sockets");
+	SocketSubsystem.RegisterSocketSubsystem(EOS_SUBSYSTEM, this, false);
+
+	return true;
+}
+
+void FSocketSubsystemEOS::Shutdown()
+{
+	// Destruct our sockets before we finish destructing, as they maintain a reference to us
+	TrackedSockets.Reset();
+
+	if (FSocketSubsystemModule* SocketSubsystem = FModuleManager::GetModulePtr<FSocketSubsystemModule>("Sockets"))
+	{
+		SocketSubsystem->UnregisterSocketSubsystem(EOS_SUBSYSTEM);
+	}
+}
+
+FSocket* FSocketSubsystemEOS::CreateSocket(const FName& SocketTypeName, const FString& SocketDescription, const FName& /*unused*/)
+{
+	return TrackedSockets.Emplace_GetRef(MakeUnique<FSocketEOS>(*this, SocketDescription)).Get();
+}
+
+FResolveInfoCached* FSocketSubsystemEOS::CreateResolveInfoCached(TSharedPtr<FInternetAddr> Addr) const
+{
+	return nullptr;
+}
+
+void FSocketSubsystemEOS::DestroySocket(FSocket* Socket)
+{
+	for (auto It = TrackedSockets.CreateIterator(); It; ++It)
+	{
+		if (It->IsValid() && It->Get() == Socket)
+		{
+			It.RemoveCurrent();
+			return;
+		}
+	}
+}
+
+FAddressInfoResult FSocketSubsystemEOS::GetAddressInfo(const TCHAR* HostName, const TCHAR* ServiceName, EAddressInfoFlags /*unused*/, const FName /*unused*/, ESocketType /*unused*/)
+{
+	return FAddressInfoResult(HostName, ServiceName);
+}
+
+bool FSocketSubsystemEOS::RequiresChatDataBeSeparate()
+{
+	return false;
+}
+
+bool FSocketSubsystemEOS::RequiresEncryptedPackets()
+{
+	return false;
+}
+
+bool FSocketSubsystemEOS::GetHostName(FString& HostName)
+{
+	return false;
+}
+
+TSharedRef<FInternetAddr> FSocketSubsystemEOS::CreateInternetAddr()
+{
+	return MakeShared<FInternetAddrEOS>();
+}
+
+TSharedPtr<FInternetAddr> FSocketSubsystemEOS::GetAddressFromString(const FString& InString)
+{
+	bool bUnused;
+	TSharedPtr<FInternetAddrEOS> NewAddress = StaticCastSharedRef<FInternetAddrEOS>(CreateInternetAddr());
+	NewAddress->SetIp(*InString, bUnused);
+	return NewAddress;
+}
+
+bool FSocketSubsystemEOS::HasNetworkDevice()
+{
+	return true;
+}
+
+const TCHAR* FSocketSubsystemEOS::GetSocketAPIName() const
+{
+	return TEXT("p2pSocketsEOS");
+}
+
+ESocketErrors FSocketSubsystemEOS::GetLastErrorCode()
+{
+	return TranslateErrorCode(LastSocketError);
+}
+
+ESocketErrors FSocketSubsystemEOS::TranslateErrorCode(int32 Code)
+{
+	return static_cast<ESocketErrors>(Code);
+}
+
+bool FSocketSubsystemEOS::GetLocalAdapterAddresses(TArray<TSharedPtr<FInternetAddr>>& OutAddresses)
+{
+	TSharedRef<FInternetAddr> AdapterAddress = GetLocalBindAddr(nullptr, *GLog);
+	OutAddresses.Add(AdapterAddress);
+	return true;
+}
+
+TArray<TSharedRef<FInternetAddr>> FSocketSubsystemEOS::GetLocalBindAddresses()
+{
+	TArray<TSharedRef<FInternetAddr>> OutAddresses;
+	OutAddresses.Add(GetLocalBindAddr(nullptr, *GLog));
+	return OutAddresses;
+}
+
+TSharedRef<FInternetAddr> FSocketSubsystemEOS::GetLocalBindAddr(FOutputDevice& Out)
+{
+	return GetLocalBindAddr(nullptr, Out);
+}
+
+#if WITH_EOS_SDK
+EOS_HP2P FSocketSubsystemEOS::GetP2PHandle()
+{
+	check(SubsystemEOS != nullptr);
+	return SubsystemEOS->P2PHandle;
+}
+
+EOS_ProductUserId FSocketSubsystemEOS::GetLocalUserId()
+{
+	if (SubsystemEOS != nullptr)
+	{
+		return SubsystemEOS->UserManager->GetLocalProductUserId();
+	}
+	return nullptr;
+}
+#endif
+
+TSharedRef<FInternetAddr> FSocketSubsystemEOS::GetLocalBindAddr(const UWorld* const OwningWorld, FOutputDevice& Out)
+{
+	TSharedRef<FInternetAddrEOS> BoundAddr = MakeShared<FInternetAddrEOS>();
+
+#if WITH_EOS_SDK
+	EOS_ProductUserId LocalUserId = GetLocalUserId();
+	if (LocalUserId == nullptr)
+	{
+		UE_LOG(LogSocketSubsystemEOS, Error, TEXT("No local user to send p2p packets with"));
+		return BoundAddr;
+	}
+	BoundAddr->SetLocalUserId(LocalUserId);
+#else
+	return BoundAddr;
+#endif
+
+	FString SessionId;
+	// Find our current session id from the Default online subsystem
+	if (const IOnlineSubsystem* const DefaultSubsystem = Online::GetSubsystem(OwningWorld))
+	{
+		const IOnlineSessionPtr DefaultSessionInt = DefaultSubsystem->GetSessionInterface();
+		if (DefaultSessionInt.IsValid())
+		{
+			if (const FNamedOnlineSession* const NamedSession = DefaultSessionInt->GetNamedSession(NAME_GameSession))
+			{
+				SessionId = NamedSession->GetSessionIdStr();
+			}
+		}
+	}
+
+	if (SessionId.IsEmpty())
+	{
+		SessionId = FName(NAME_GameSession).ToString();
+	}
+
+	BoundAddr->SetSocketName(SessionId);
+
+	return BoundAddr;
+}
+
+bool FSocketSubsystemEOS::IsSocketWaitSupported() const
+{
+	return false;
+}
+
+void FSocketSubsystemEOS::SetLastSocketError(const ESocketErrors NewSocketError)
+{
+	LastSocketError = NewSocketError;
+}
+
+bool FSocketSubsystemEOS::BindChannel(const FInternetAddrEOS& Address)
+{
+	if (!Address.IsValid())
+	{
+		SetLastSocketError(ESocketErrors::SE_EINVAL);
+		return false;
+	}
+
+	const uint8 Channel = Address.GetChannel();
+
+	FChannelSet& ExistingBoundPorts = BoundAddresses.FindOrAdd(Address.GetSocketName());
+	if (ExistingBoundPorts.Contains(Channel))
+	{
+		SetLastSocketError(ESocketErrors::SE_EADDRINUSE);
+		return false;
+	}
+
+	ExistingBoundPorts.Add(Channel);
+	return true;
+}
+
+bool FSocketSubsystemEOS::UnbindChannel(const FInternetAddrEOS& Address)
+{
+	if (!Address.IsValid())
+	{
+		SetLastSocketError(ESocketErrors::SE_EINVAL);
+		return false;
+	}
+
+	const FString SocketName = Address.GetSocketName();
+	const uint8 Channel = Address.GetChannel();
+
+	// Find our sessions collection of ports
+	FChannelSet* ExistingBoundPorts = BoundAddresses.Find(SocketName);
+	if (!ExistingBoundPorts)
+	{
+		SetLastSocketError(ESocketErrors::SE_ENOTSOCK);
+		return false;
+	}
+
+	// Remove our port and check if we had it bound
+	if (ExistingBoundPorts->Remove(Channel) == 0)
+	{
+		SetLastSocketError(ESocketErrors::SE_ENOTSOCK);
+		return false;
+	}
+
+	// Remove any empty sets
+	if (ExistingBoundPorts->Num() == 0)
+	{
+		BoundAddresses.Remove(SocketName);
+		ExistingBoundPorts = nullptr;
+	}
+
+	return true;
+}
Index: Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Private/EOSHelpers.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Private/EOSHelpers.cpp b/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Private/EOSHelpers.cpp
new file mode 100644
--- /dev/null	(date 1641575208000)
+++ b/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Private/EOSHelpers.cpp	(date 1641575208000)
@@ -0,0 +1,46 @@
+// Copyright Epic Games, Inc. All Rights Reserved.
+
+#include "EOSHelpers.h"
+
+#if WITH_EOS_SDK
+
+#include "IEOSSDKManager.h"
+#include "OnlineError.h"
+#include "OnlineSubsystemEOS.h"
+#include "UserManagerEOS.h"
+
+FString FEOSHelpers::PlatformCreateCacheDir(const FString &ArtifactName, const FString &EOSSettingsCacheDir)
+{
+	FString CacheDir = FPlatformProcess::UserDir() / ArtifactName / EOSSettingsCacheDir;
+	return MoveTemp(CacheDir);
+}
+
+void FEOSHelpers::PlatformAuthCredentials(EOS_Auth_Credentials &Credentials)
+{
+}
+
+void FEOSHelpers::PlatformTriggerLoginUI(FOnlineSubsystemEOS* EOSSubsystem, const int ControllerIndex, bool bShowOnlineOnly, bool bShowSkipButton, const FOnLoginUIClosedDelegate& Delegate)
+{
+	check(EOSSubsystem);
+
+	UE_LOG_ONLINE_EXTERNALUI(Warning, TEXT("[FUserManagerEOS::ShowLoginUI] This method is not implemented."));
+
+	const FUniqueNetIdPtr PlayerId = EOSSubsystem->UserManager->GetUniquePlayerId(ControllerIndex);
+
+	EOSSubsystem->ExecuteNextTick([PlayerId, ControllerIndex, Delegate]()
+	{
+		Delegate.ExecuteIfBound(PlayerId, ControllerIndex, FOnlineError(EOnlineErrorResult::NotImplemented));
+	});
+}
+
+IEOSPlatformHandlePtr FEOSHelpers::CreatePlatform(EOS_Platform_Options& PlatformOptions)
+{
+	IEOSSDKManager* SDKManager = IEOSSDKManager::Get();
+	if (ensure(SDKManager))
+	{
+		return SDKManager->CreatePlatform(PlatformOptions);
+	}
+	return nullptr;
+}
+
+#endif // WITH_EOS_SDK
\ No newline at end of file
Index: Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Private/OnlineSessionEOS.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Private/OnlineSessionEOS.cpp b/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Private/OnlineSessionEOS.cpp
new file mode 100644
--- /dev/null	(date 1641576012000)
+++ b/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Private/OnlineSessionEOS.cpp	(date 1641576012000)
@@ -0,0 +1,4213 @@
+// Copyright Epic Games, Inc. All Rights Reserved.
+
+#include "OnlineSessionEOS.h"
+#include "Misc/Guid.h"
+#include "OnlineSubsystem.h"
+#include "OnlineSubsystemEOS.h"
+#include "OnlineSubsystemEOSTypes.h"
+#include "UserManagerEOS.h"
+#include "OnlineSubsystemUtils.h"
+#include "OnlineAsyncTaskManager.h"
+#include "SocketSubsystem.h"
+#include "NboSerializerEOS.h"
+#include "InternetAddrEOS.h"
+#include "IEOSSDKManager.h"
+#include "NetDriverEOS.h"
+#include "EOSVoiceChatUser.h"
+
+#if WITH_EOS_SDK
+	#include "eos_sessions.h"
+	#include "eos_metrics.h"
+	#include "eos_lobby.h"
+
+/** This is the game name plus version in ansi done once for optimization */
+char BucketIdAnsi[EOS_OSS_STRING_BUFFER_LENGTH];
+
+FString MakeStringFromAttributeValue(const EOS_Sessions_AttributeData* Attribute)
+{
+	switch (Attribute->ValueType)
+	{
+		case EOS_ESessionAttributeType::EOS_SAT_Int64:
+		{
+			int32 Value = Attribute->Value.AsInt64;
+			return FString::Printf(TEXT("%d"), Value);
+		}
+		case EOS_ESessionAttributeType::EOS_SAT_Double:
+		{
+			double Value = Attribute->Value.AsDouble;
+			return FString::Printf(TEXT("%f"), Value);
+		}
+		case EOS_ESessionAttributeType::EOS_SAT_String:
+		{
+			FString Value = Attribute->Value.AsUtf8;
+			return FString::Printf(TEXT("%s"), *Value);
+		}
+	}
+	return TEXT("");
+}
+
+bool IsSessionSettingTypeSupported(EOnlineKeyValuePairDataType::Type InType)
+{
+	switch (InType)
+	{
+		case EOnlineKeyValuePairDataType::Int32:
+		case EOnlineKeyValuePairDataType::UInt32:
+		case EOnlineKeyValuePairDataType::Int64:
+		case EOnlineKeyValuePairDataType::Double:
+		case EOnlineKeyValuePairDataType::String:
+		case EOnlineKeyValuePairDataType::Float:
+		case EOnlineKeyValuePairDataType::Bool:
+		{
+			return true;
+		}
+	}
+	return false;
+}
+
+EOS_EOnlineComparisonOp ToEOSSearchOp(EOnlineComparisonOp::Type Op)
+{
+	switch (Op)
+	{
+		case EOnlineComparisonOp::Equals:
+		{
+			return EOS_EOnlineComparisonOp::EOS_OCO_EQUAL;
+		}
+		case EOnlineComparisonOp::NotEquals:
+		{
+			return EOS_EOnlineComparisonOp::EOS_OCO_NOTEQUAL;
+		}
+		case EOnlineComparisonOp::GreaterThan:
+		{
+			return EOS_EOnlineComparisonOp::EOS_OCO_GREATERTHAN;
+		}
+		case EOnlineComparisonOp::GreaterThanEquals:
+		{
+			return EOS_EOnlineComparisonOp::EOS_OCO_GREATERTHANOREQUAL;
+		}
+		case EOnlineComparisonOp::LessThan:
+		{
+			return EOS_EOnlineComparisonOp::EOS_OCO_LESSTHAN;
+		}
+		case EOnlineComparisonOp::LessThanEquals:
+		{
+			return EOS_EOnlineComparisonOp::EOS_OCO_LESSTHANOREQUAL;
+		}
+		case EOnlineComparisonOp::Near:
+		{
+			return EOS_EOnlineComparisonOp::EOS_OCO_DISTANCE;
+		}
+		case EOnlineComparisonOp::In:
+		{
+			return EOS_EOnlineComparisonOp::EOS_OCO_ANYOF;
+		}
+		case EOnlineComparisonOp::NotIn:
+		{
+			return EOS_EOnlineComparisonOp::EOS_OCO_NOTANYOF;
+		}
+	}
+	return EOS_EOnlineComparisonOp::EOS_OCO_EQUAL;
+}
+
+struct FAttributeOptions :
+	public EOS_Sessions_AttributeData
+{
+	char KeyAnsi[EOS_OSS_STRING_BUFFER_LENGTH];
+	char ValueAnsi[EOS_OSS_STRING_BUFFER_LENGTH];
+
+	FAttributeOptions(const char* InKey, const char* InValue) :
+		EOS_Sessions_AttributeData()
+	{
+		ApiVersion = EOS_SESSIONS_SESSIONATTRIBUTEDATA_API_LATEST;
+		ValueType = EOS_ESessionAttributeType::EOS_SAT_String;
+		Value.AsUtf8 = ValueAnsi;
+		Key = KeyAnsi;
+		FCStringAnsi::Strncpy(KeyAnsi, InKey, EOS_OSS_STRING_BUFFER_LENGTH);
+		FCStringAnsi::Strncpy(ValueAnsi, InValue, EOS_OSS_STRING_BUFFER_LENGTH);
+	}
+
+	FAttributeOptions(const char* InKey, bool InValue) :
+		EOS_Sessions_AttributeData()
+	{
+		ApiVersion = EOS_SESSIONS_SESSIONATTRIBUTEDATA_API_LATEST;
+		ValueType = EOS_ESessionAttributeType::EOS_SAT_Boolean;
+		Value.AsBool = InValue ? EOS_TRUE : EOS_FALSE;
+		Key = KeyAnsi;
+		FCStringAnsi::Strncpy(KeyAnsi, InKey, EOS_OSS_STRING_BUFFER_LENGTH);
+	}
+
+	FAttributeOptions(const char* InKey, float InValue) :
+		EOS_Sessions_AttributeData()
+	{
+		ApiVersion = EOS_SESSIONS_SESSIONATTRIBUTEDATA_API_LATEST;
+		ValueType = EOS_ESessionAttributeType::EOS_SAT_Double;
+		Value.AsDouble = InValue;
+		Key = KeyAnsi;
+		FCStringAnsi::Strncpy(KeyAnsi, InKey, EOS_OSS_STRING_BUFFER_LENGTH);
+	}
+
+	FAttributeOptions(const char* InKey, int32 InValue) :
+		EOS_Sessions_AttributeData()
+	{
+		ApiVersion = EOS_SESSIONS_SESSIONATTRIBUTEDATA_API_LATEST;
+		ValueType = EOS_ESessionAttributeType::EOS_SAT_Int64;
+		Value.AsInt64 = InValue;
+		Key = KeyAnsi;
+		FCStringAnsi::Strncpy(KeyAnsi, InKey, EOS_OSS_STRING_BUFFER_LENGTH);
+	}
+
+	FAttributeOptions(const char* InKey, const FVariantData& InValue) :
+		EOS_Sessions_AttributeData()
+	{
+		ApiVersion = EOS_SESSIONS_SESSIONATTRIBUTEDATA_API_LATEST;
+
+		switch (InValue.GetType())
+		{
+			case EOnlineKeyValuePairDataType::Int32:
+			{
+				ValueType = EOS_ESessionAttributeType::EOS_SAT_Int64;
+				int32 RawValue = 0;
+				InValue.GetValue(RawValue);
+				Value.AsInt64 = RawValue;
+				break;
+			}
+			case EOnlineKeyValuePairDataType::UInt32:
+			{
+				ValueType = EOS_ESessionAttributeType::EOS_SAT_Int64;
+				uint32 RawValue = 0;
+				InValue.GetValue(RawValue);
+				Value.AsInt64 = RawValue;
+				break;
+			}
+			case EOnlineKeyValuePairDataType::Int64:
+			{
+				ValueType = EOS_ESessionAttributeType::EOS_SAT_Int64;
+				int64 RawValue = 0;
+				InValue.GetValue(RawValue);
+				Value.AsInt64 = RawValue;
+				break;
+			}
+			case EOnlineKeyValuePairDataType::Bool:
+			{
+				ValueType = EOS_ESessionAttributeType::EOS_SAT_Boolean;
+				bool RawValue = false;
+				InValue.GetValue(RawValue);
+				Value.AsBool = RawValue ? EOS_TRUE : EOS_FALSE;
+				break;
+			}
+			case EOnlineKeyValuePairDataType::Double:
+			{
+				ValueType = EOS_ESessionAttributeType::EOS_SAT_Double;
+				double RawValue = 0.0;
+				InValue.GetValue(RawValue);
+				Value.AsDouble = RawValue;
+				break;
+			}
+			case EOnlineKeyValuePairDataType::Float:
+			{
+				ValueType = EOS_ESessionAttributeType::EOS_SAT_Double;
+				float RawValue = 0.0;
+				InValue.GetValue(RawValue);
+				Value.AsDouble = RawValue;
+				break;
+			}
+			case EOnlineKeyValuePairDataType::String:
+			{
+				ValueType = EOS_ESessionAttributeType::EOS_SAT_String;
+				Value.AsUtf8 = ValueAnsi;
+				Key = KeyAnsi;
+				FString OutString;
+				InValue.GetValue(OutString);
+				FCStringAnsi::Strncpy(ValueAnsi, TCHAR_TO_UTF8(*OutString), EOS_OSS_STRING_BUFFER_LENGTH);
+				break;
+			}
+		}
+		Key = KeyAnsi;
+		FCStringAnsi::Strncpy(KeyAnsi, InKey, EOS_OSS_STRING_BUFFER_LENGTH);
+	}
+};
+
+struct FLobbyAttributeOptions :
+	public EOS_Lobby_AttributeData
+{
+	char KeyAnsi[EOS_OSS_STRING_BUFFER_LENGTH];
+	char ValueAnsi[EOS_OSS_STRING_BUFFER_LENGTH];
+
+	FLobbyAttributeOptions(const char* InKey, const char* InValue) :
+		EOS_Lobby_AttributeData()
+	{
+		ApiVersion = EOS_LOBBY_ATTRIBUTEDATA_API_LATEST;
+		ValueType = EOS_ELobbyAttributeType::EOS_SAT_String;
+		Value.AsUtf8 = ValueAnsi;
+		Key = KeyAnsi;
+		FCStringAnsi::Strncpy(KeyAnsi, InKey, EOS_OSS_STRING_BUFFER_LENGTH);
+		FCStringAnsi::Strncpy(ValueAnsi, InValue, EOS_OSS_STRING_BUFFER_LENGTH);
+	}
+
+	FLobbyAttributeOptions(const char* InKey, bool InValue) :
+		EOS_Lobby_AttributeData()
+	{
+		ApiVersion = EOS_LOBBY_ATTRIBUTEDATA_API_LATEST;
+		ValueType = EOS_ELobbyAttributeType::EOS_SAT_Boolean;
+		Value.AsBool = InValue ? EOS_TRUE : EOS_FALSE;
+		Key = KeyAnsi;
+		FCStringAnsi::Strncpy(KeyAnsi, InKey, EOS_OSS_STRING_BUFFER_LENGTH);
+	}
+
+	FLobbyAttributeOptions(const char* InKey, float InValue) :
+		EOS_Lobby_AttributeData()
+	{
+		ApiVersion = EOS_LOBBY_ATTRIBUTEDATA_API_LATEST;
+		ValueType = EOS_ELobbyAttributeType::EOS_SAT_Double;
+		Value.AsDouble = InValue;
+		Key = KeyAnsi;
+		FCStringAnsi::Strncpy(KeyAnsi, InKey, EOS_OSS_STRING_BUFFER_LENGTH);
+	}
+
+	FLobbyAttributeOptions(const char* InKey, int32 InValue) :
+		EOS_Lobby_AttributeData()
+	{
+		ApiVersion = EOS_LOBBY_ATTRIBUTEDATA_API_LATEST;
+		ValueType = EOS_ELobbyAttributeType::EOS_SAT_Int64;
+		Value.AsInt64 = InValue;
+		Key = KeyAnsi;
+		FCStringAnsi::Strncpy(KeyAnsi, InKey, EOS_OSS_STRING_BUFFER_LENGTH);
+	}
+
+	FLobbyAttributeOptions(const char* InKey, const FVariantData& InValue) :
+		EOS_Lobby_AttributeData()
+	{
+		ApiVersion = EOS_LOBBY_ATTRIBUTEDATA_API_LATEST;
+
+		switch (InValue.GetType())
+		{
+		case EOnlineKeyValuePairDataType::Int32:
+		{
+			ValueType = EOS_ELobbyAttributeType::EOS_SAT_Int64;
+			int32 RawValue = 0;
+			InValue.GetValue(RawValue);
+			Value.AsInt64 = RawValue;
+			break;
+		}
+		case EOnlineKeyValuePairDataType::UInt32:
+		{
+			ValueType = EOS_ELobbyAttributeType::EOS_SAT_Int64;
+			uint32 RawValue = 0;
+			InValue.GetValue(RawValue);
+			Value.AsInt64 = RawValue;
+			break;
+		}
+		case EOnlineKeyValuePairDataType::Int64:
+		{
+			ValueType = EOS_ELobbyAttributeType::EOS_SAT_Int64;
+			int64 RawValue = 0;
+			InValue.GetValue(RawValue);
+			Value.AsInt64 = RawValue;
+			break;
+		}
+		case EOnlineKeyValuePairDataType::Bool:
+		{
+			ValueType = EOS_ELobbyAttributeType::EOS_SAT_Boolean;
+			bool RawValue = false;
+			InValue.GetValue(RawValue);
+			Value.AsBool = RawValue ? EOS_TRUE : EOS_FALSE;
+			break;
+		}
+		case EOnlineKeyValuePairDataType::Double:
+		{
+			ValueType = EOS_ELobbyAttributeType::EOS_SAT_Double;
+			double RawValue = 0.0;
+			InValue.GetValue(RawValue);
+			Value.AsDouble = RawValue;
+			break;
+		}
+		case EOnlineKeyValuePairDataType::Float:
+		{
+			ValueType = EOS_ELobbyAttributeType::EOS_SAT_Double;
+			float RawValue = 0.0;
+			InValue.GetValue(RawValue);
+			Value.AsDouble = RawValue;
+			break;
+		}
+		case EOnlineKeyValuePairDataType::String:
+		{
+			ValueType = EOS_ELobbyAttributeType::EOS_SAT_String;
+			Value.AsUtf8 = ValueAnsi;
+			Key = KeyAnsi;
+			FString OutString;
+			InValue.GetValue(OutString);
+			FCStringAnsi::Strncpy(ValueAnsi, TCHAR_TO_UTF8(*OutString), EOS_OSS_STRING_BUFFER_LENGTH);
+			break;
+		}
+		}
+		Key = KeyAnsi;
+		FCStringAnsi::Strncpy(KeyAnsi, InKey, EOS_OSS_STRING_BUFFER_LENGTH);
+	}
+};
+
+FOnlineSessionInfoEOS::FOnlineSessionInfoEOS()
+	: HostAddr(nullptr)
+	, SessionId(FUniqueNetIdEOS::EmptyId())
+	, SessionHandle(nullptr)
+	, bIsFromClone(false)
+{
+}
+
+FOnlineSessionInfoEOS::FOnlineSessionInfoEOS(const FString& InHostIp, const FString& InSessionId, EOS_HSessionDetails InSessionHandle)
+	: FOnlineSessionInfoEOS(InHostIp, FUniqueNetIdEOS::Create(InSessionId), InSessionHandle)
+{
+
+}
+
+FOnlineSessionInfoEOS::FOnlineSessionInfoEOS(const FString& InHostIp, FUniqueNetIdEOSRef UniqueNetId, EOS_HSessionDetails InSessionHandle)
+	: FOnlineSessionInfo()
+	, SessionId(UniqueNetId)
+	, SessionHandle(InSessionHandle)
+	, bIsFromClone(false)
+{
+	if (InHostIp.StartsWith(EOS_CONNECTION_URL_PREFIX, ESearchCase::IgnoreCase))
+	{
+		HostAddr = ISocketSubsystem::Get(EOS_SUBSYSTEM)->GetAddressFromString(InHostIp);
+		EOSAddress = InHostIp;
+	}
+	else
+	{
+		HostAddr = ISocketSubsystem::Get(PLATFORM_SOCKETSUBSYSTEM)->GetAddressFromString(InHostIp);
+		HostAddr->SetPort(FURL::UrlConfig.DefaultPort);
+	}
+}
+
+FOnlineSessionInfoEOS::~FOnlineSessionInfoEOS()
+{
+	if (SessionHandle != nullptr && !bIsFromClone)
+	{
+		EOS_SessionDetails_Release(SessionHandle);
+	}
+}
+
+void FOnlineSessionInfoEOS::InitLAN(FOnlineSubsystemEOS* Subsystem)
+{
+	// Read the IP from the system
+	bool bCanBindAll;
+	HostAddr = ISocketSubsystem::Get(PLATFORM_SOCKETSUBSYSTEM)->GetLocalHostAddr(*GLog, bCanBindAll);
+
+	// The below is a workaround for systems that set hostname to a distinct address from 127.0.0.1 on a loopback interface.
+	// See e.g. https://www.debian.org/doc/manuals/debian-reference/ch05.en.html#_the_hostname_resolution
+	// and http://serverfault.com/questions/363095/why-does-my-hostname-appear-with-the-address-127-0-1-1-rather-than-127-0-0-1-in
+	// Since we bind to 0.0.0.0, we won't answer on 127.0.1.1, so we need to advertise ourselves as 127.0.0.1 for any other loopback address we may have.
+	uint32 HostIp = 0;
+	HostAddr->GetIp(HostIp); // will return in host order
+	// if this address is on loopback interface, advertise it as 127.0.0.1
+	if ((HostIp & 0xff000000) == 0x7f000000)
+	{
+		HostAddr->SetIp(0x7f000001);	// 127.0.0.1
+	}
+
+	// Now set the port that was configured
+	HostAddr->SetPort(GetPortFromNetDriver(Subsystem->GetInstanceName()));
+
+	FGuid OwnerGuid;
+	FPlatformMisc::CreateGuid(OwnerGuid);
+	SessionId = FUniqueNetIdEOS::Create(OwnerGuid.ToString());
+}
+
+typedef TEOSGlobalCallback<EOS_Sessions_OnSessionInviteReceivedCallback, EOS_Sessions_SessionInviteReceivedCallbackInfo> FSessionInviteReceivedCallback;
+typedef TEOSGlobalCallback<EOS_Sessions_OnSessionInviteAcceptedCallback, EOS_Sessions_SessionInviteAcceptedCallbackInfo> FSessionInviteAcceptedCallback;
+
+// Lobby session callbacks
+typedef TEOSCallback<EOS_Lobby_OnCreateLobbyCallback, EOS_Lobby_CreateLobbyCallbackInfo> FLobbyCreatedCallback;
+typedef TEOSCallback<EOS_Lobby_OnUpdateLobbyCallback, EOS_Lobby_UpdateLobbyCallbackInfo> FLobbyUpdatedCallback;
+typedef TEOSCallback<EOS_Lobby_OnJoinLobbyCallback, EOS_Lobby_JoinLobbyCallbackInfo> FLobbyJoinedCallback;
+typedef TEOSCallback<EOS_Lobby_OnLeaveLobbyCallback, EOS_Lobby_LeaveLobbyCallbackInfo> FLobbyLeftCallback;
+typedef TEOSCallback<EOS_Lobby_OnDestroyLobbyCallback, EOS_Lobby_DestroyLobbyCallbackInfo> FLobbyDestroyedCallback;
+typedef TEOSCallback<EOS_Lobby_OnSendInviteCallback, EOS_Lobby_SendInviteCallbackInfo> FLobbySendInviteCallback;
+typedef TEOSCallback<EOS_Lobby_OnKickMemberCallback, EOS_Lobby_KickMemberCallbackInfo> FLobbyRemovePlayerCallback;
+typedef TEOSCallback<EOS_LobbySearch_OnFindCallback, EOS_LobbySearch_FindCallbackInfo> FLobbySearchFindCallback;
+
+// Lobby notification callbacks
+typedef TEOSGlobalCallback<EOS_Lobby_OnLobbyUpdateReceivedCallback, EOS_Lobby_LobbyUpdateReceivedCallbackInfo> FLobbyUpdateReceivedCallback;
+typedef TEOSGlobalCallback<EOS_Lobby_OnLobbyMemberUpdateReceivedCallback, EOS_Lobby_LobbyMemberUpdateReceivedCallbackInfo> FLobbyMemberUpdateReceivedCallback;
+typedef TEOSGlobalCallback<EOS_Lobby_OnLobbyMemberStatusReceivedCallback, EOS_Lobby_LobbyMemberStatusReceivedCallbackInfo> FLobbyMemberStatusReceivedCallback;
+typedef TEOSGlobalCallback<EOS_Lobby_OnLobbyInviteAcceptedCallback, EOS_Lobby_LobbyInviteAcceptedCallbackInfo> FLobbyInviteAcceptedCallback;
+typedef TEOSGlobalCallback<EOS_Lobby_OnJoinLobbyAcceptedCallback, EOS_Lobby_JoinLobbyAcceptedCallbackInfo> FJoinLobbyAcceptedCallback;
+
+FOnlineSessionEOS::~FOnlineSessionEOS()
+{
+	EOS_Sessions_RemoveNotifySessionInviteAccepted(EOSSubsystem->SessionsHandle, SessionInviteAcceptedId);
+	delete SessionInviteAcceptedCallback;
+
+	EOS_Lobby_RemoveNotifyLobbyUpdateReceived(LobbyHandle, LobbyUpdateReceivedId);
+	EOS_Lobby_RemoveNotifyLobbyMemberUpdateReceived(LobbyHandle, LobbyMemberUpdateReceivedId);
+	EOS_Lobby_RemoveNotifyLobbyMemberStatusReceived(LobbyHandle, LobbyMemberStatusReceivedId);
+	EOS_Lobby_RemoveNotifyLobbyInviteAccepted(LobbyHandle, LobbyInviteAcceptedId);
+	EOS_Lobby_RemoveNotifyJoinLobbyAccepted(LobbyHandle, JoinLobbyAcceptedId);
+
+	delete LobbyUpdateReceivedCallback;
+	delete LobbyMemberUpdateReceivedCallback;
+	delete LobbyMemberStatusReceivedCallback;
+	delete LobbyInviteAcceptedCallback;
+	delete JoinLobbyAcceptedCallback;
+}
+
+void FOnlineSessionEOS::Init(const FString& InBucketId)
+{
+	FCStringAnsi::Strncpy(BucketIdAnsi, TCHAR_TO_UTF8(*InBucketId), EOS_OSS_STRING_BUFFER_LENGTH);
+
+	// Register for session invite notifications
+	FSessionInviteAcceptedCallback* SessionInviteAcceptedCallbackObj = new FSessionInviteAcceptedCallback();
+	SessionInviteAcceptedCallback = SessionInviteAcceptedCallbackObj;
+	SessionInviteAcceptedCallbackObj->CallbackLambda = [this](const EOS_Sessions_SessionInviteAcceptedCallbackInfo* Data)
+	{
+		FUniqueNetIdEOSPtr NetId = EOSSubsystem->UserManager->GetLocalUniqueNetIdEOS(Data->LocalUserId);
+		if (!NetId.IsValid())
+		{
+			UE_LOG_ONLINE_SESSION(Warning, TEXT("Cannot accept invite due to unknown user (%s)"), *LexToString(Data->LocalUserId));
+			TriggerOnSessionUserInviteAcceptedDelegates(false, 0, NetId, FOnlineSessionSearchResult());
+			return;
+		}
+		int32 LocalUserNum = EOSSubsystem->UserManager->GetLocalUserNumFromUniqueNetId(*NetId);
+
+		EOS_Sessions_CopySessionHandleByInviteIdOptions Options = { };
+		Options.ApiVersion = EOS_SESSIONS_COPYSESSIONHANDLEBYINVITEID_API_LATEST;
+		Options.InviteId = Data->InviteId;
+		EOS_HSessionDetails SessionDetails = nullptr;
+		EOS_EResult Result = EOS_Sessions_CopySessionHandleByInviteId(EOSSubsystem->SessionsHandle, &Options, &SessionDetails);
+		if (Result == EOS_EResult::EOS_Success)
+		{
+			LastInviteSearch = MakeShared<FOnlineSessionSearch>();
+			AddSearchResult(SessionDetails, LastInviteSearch.ToSharedRef());
+			TriggerOnSessionUserInviteAcceptedDelegates(true, LocalUserNum, NetId, LastInviteSearch->SearchResults[0]);
+		}
+		else
+		{
+			UE_LOG_ONLINE_SESSION(Warning, TEXT("EOS_Sessions_CopySessionHandleByInviteId not successful. Finished with EOS_EResult %s"), ANSI_TO_TCHAR(EOS_EResult_ToString(Result)));
+			TriggerOnSessionUserInviteAcceptedDelegates(false, LocalUserNum, NetId, FOnlineSessionSearchResult());
+		}
+	};
+	EOS_Sessions_AddNotifySessionInviteAcceptedOptions Options = { };
+	Options.ApiVersion = EOS_SESSIONS_ADDNOTIFYSESSIONINVITEACCEPTED_API_LATEST;
+	SessionInviteAcceptedId = EOS_Sessions_AddNotifySessionInviteAccepted(EOSSubsystem->SessionsHandle, &Options, SessionInviteAcceptedCallbackObj, SessionInviteAcceptedCallbackObj->GetCallbackPtr());
+
+	// Lobbies
+	LobbyHandle = EOS_Platform_GetLobbyInterface(*EOSSubsystem->EOSPlatformHandle);
+	RegisterLobbyNotifications();
+
+	bIsDedicatedServer = IsRunningDedicatedServer();
+	bIsUsingP2PSockets = false;
+	GConfig->GetBool(TEXT("/Script/OnlineSubsystemEOS.NetDriverEOS"), TEXT("bIsUsingP2PSockets"), bIsUsingP2PSockets, GEngineIni);
+}
+
+/**
+ * Searches the named session array for the specified session
+ *
+ * @param LobbyId the lobby id to search for
+ *
+ * @return pointer to the struct if found, NULL otherwise
+ */
+FNamedOnlineSession* FOnlineSessionEOS::GetNamedSessionFromLobbyId(const FUniqueNetIdEOS& LobbyId)
+{
+	FNamedOnlineSession* Result = nullptr;
+
+	FScopeLock ScopeLock(&SessionLock);
+	for (int32 SearchIndex = 0; SearchIndex < Sessions.Num(); SearchIndex++)
+	{
+		FNamedOnlineSession& Session = Sessions[SearchIndex];
+		if (Session.SessionInfo.IsValid())
+		{
+			FOnlineSessionInfoEOS* SessionInfo = (FOnlineSessionInfoEOS*)Session.SessionInfo.Get();
+			if (!Session.SessionSettings.bIsLANMatch && Session.SessionSettings.bUseLobbiesIfAvailable && *SessionInfo->SessionId == LobbyId)
+			{
+				Result = &Sessions[SearchIndex];
+				break;
+			}
+		}
+	}
+
+	return Result;
+}
+
+void FOnlineSessionEOS::RegisterLobbyNotifications()
+{
+	// Lobby data updates
+	EOS_Lobby_AddNotifyLobbyUpdateReceivedOptions AddNotifyLobbyUpdateReceivedOptions = { 0 };
+	AddNotifyLobbyUpdateReceivedOptions.ApiVersion = EOS_LOBBY_ADDNOTIFYLOBBYUPDATERECEIVED_API_LATEST;
+
+	FLobbyUpdateReceivedCallback* LobbyUpdateReceivedCallbackObj = new FLobbyUpdateReceivedCallback();
+	LobbyUpdateReceivedCallback = LobbyUpdateReceivedCallbackObj;
+	LobbyUpdateReceivedCallbackObj->CallbackLambda = [this](const EOS_Lobby_LobbyUpdateReceivedCallbackInfo* Data)
+	{
+		OnLobbyUpdateReceived(Data->LobbyId);
+	};
+
+	LobbyUpdateReceivedId = EOS_Lobby_AddNotifyLobbyUpdateReceived(LobbyHandle, &AddNotifyLobbyUpdateReceivedOptions, LobbyUpdateReceivedCallbackObj, LobbyUpdateReceivedCallbackObj->GetCallbackPtr());
+
+	// Lobby member data updates
+	EOS_Lobby_AddNotifyLobbyMemberUpdateReceivedOptions AddNotifyLobbyMemberUpdateReceivedOptions = { 0 };
+	AddNotifyLobbyMemberUpdateReceivedOptions.ApiVersion = EOS_LOBBY_ADDNOTIFYLOBBYMEMBERUPDATERECEIVED_API_LATEST;
+
+	FLobbyMemberUpdateReceivedCallback* LobbyMemberUpdateReceivedCallbackObj = new FLobbyMemberUpdateReceivedCallback();
+	LobbyMemberUpdateReceivedCallback = LobbyMemberUpdateReceivedCallbackObj;
+	LobbyMemberUpdateReceivedCallbackObj->CallbackLambda = [this](const EOS_Lobby_LobbyMemberUpdateReceivedCallbackInfo* Data)
+	{
+		OnLobbyMemberUpdateReceived(Data->LobbyId, Data->TargetUserId);
+	};
+
+	LobbyMemberUpdateReceivedId = EOS_Lobby_AddNotifyLobbyMemberUpdateReceived(LobbyHandle, &AddNotifyLobbyMemberUpdateReceivedOptions, LobbyMemberUpdateReceivedCallbackObj, LobbyMemberUpdateReceivedCallbackObj->GetCallbackPtr());
+
+	// Lobby member status updates (joined/left/disconnected/kicked/promoted)
+	EOS_Lobby_AddNotifyLobbyMemberStatusReceivedOptions AddNotifyLobbyMemberStatusReceivedOptions = { 0 };
+	AddNotifyLobbyMemberStatusReceivedOptions.ApiVersion = EOS_LOBBY_ADDNOTIFYLOBBYMEMBERSTATUSRECEIVED_API_LATEST;
+
+	FLobbyMemberStatusReceivedCallback* LobbyMemberStatusReceivedCallbackObj = new FLobbyMemberStatusReceivedCallback();
+	LobbyMemberStatusReceivedCallback = LobbyMemberStatusReceivedCallbackObj;
+	LobbyMemberStatusReceivedCallbackObj->CallbackLambda = [this](const EOS_Lobby_LobbyMemberStatusReceivedCallbackInfo* Data)
+	{
+		OnMemberStatusReceived(Data->LobbyId, Data->TargetUserId, Data->CurrentStatus);
+	};
+
+	LobbyMemberStatusReceivedId = EOS_Lobby_AddNotifyLobbyMemberStatusReceived(LobbyHandle, &AddNotifyLobbyMemberStatusReceivedOptions, LobbyMemberStatusReceivedCallbackObj, LobbyMemberStatusReceivedCallbackObj->GetCallbackPtr());
+
+	// LobbyInviteReceived we can skip, since it will pop up as system UI
+
+	// Accepted lobby invite notifications
+	EOS_Lobby_AddNotifyLobbyInviteAcceptedOptions AddNotifyLobbyInviteAcceptedOptions = { 0 };
+	AddNotifyLobbyInviteAcceptedOptions.ApiVersion = EOS_LOBBY_ADDNOTIFYLOBBYINVITEACCEPTED_API_LATEST;
+
+	FLobbyInviteAcceptedCallback* LobbyInviteAcceptedCallbackObj = new FLobbyInviteAcceptedCallback();
+	LobbyInviteAcceptedCallback = LobbyInviteAcceptedCallbackObj;
+	LobbyInviteAcceptedCallbackObj->CallbackLambda = [this](const EOS_Lobby_LobbyInviteAcceptedCallbackInfo* Data)
+	{
+		OnLobbyInviteAccepted(Data->InviteId, Data->LocalUserId, Data->TargetUserId);
+	};
+
+	LobbyInviteAcceptedId = EOS_Lobby_AddNotifyLobbyInviteAccepted(LobbyHandle, &AddNotifyLobbyInviteAcceptedOptions, LobbyInviteAcceptedCallbackObj, LobbyInviteAcceptedCallbackObj->GetCallbackPtr());
+
+	// Accepted lobby join notifications
+	EOS_Lobby_AddNotifyJoinLobbyAcceptedOptions AddNotifyJoinLobbyAcceptedOptions = { 0 };
+	AddNotifyJoinLobbyAcceptedOptions.ApiVersion = EOS_LOBBY_ADDNOTIFYJOINLOBBYACCEPTED_API_LATEST;
+
+	FJoinLobbyAcceptedCallback* JoinLobbyAcceptedCallbackObj = new FJoinLobbyAcceptedCallback();
+	JoinLobbyAcceptedCallback = JoinLobbyAcceptedCallbackObj;
+	JoinLobbyAcceptedCallbackObj->CallbackLambda = [this](const EOS_Lobby_JoinLobbyAcceptedCallbackInfo* Data)
+	{
+		OnJoinLobbyAccepted(Data->LocalUserId, Data->UiEventId);
+	};
+
+	JoinLobbyAcceptedId = EOS_Lobby_AddNotifyJoinLobbyAccepted(LobbyHandle, &AddNotifyJoinLobbyAcceptedOptions, JoinLobbyAcceptedCallbackObj, JoinLobbyAcceptedCallbackObj->GetCallbackPtr());
+}
+
+void FOnlineSessionEOS::OnLobbyUpdateReceived(const EOS_LobbyId& LobbyId)
+{
+	const FUniqueNetIdEOSRef LobbyNetId = FUniqueNetIdEOS::Create(LobbyId);
+	FNamedOnlineSession* Session = GetNamedSessionFromLobbyId(*LobbyNetId);
+	if (Session)
+	{
+		EOS_Lobby_CopyLobbyDetailsHandleOptions Options = {};
+		Options.ApiVersion = EOS_LOBBY_COPYLOBBYDETAILSHANDLE_API_LATEST;
+		Options.LobbyId = LobbyId;
+		Options.LocalUserId = EOSSubsystem->UserManager->GetLocalProductUserId();
+
+		EOS_HLobbyDetails LobbyDetailsHandle;
+
+		EOS_EResult CopyLobbyDetailsResult = EOS_Lobby_CopyLobbyDetailsHandle(LobbyHandle, &Options, &LobbyDetailsHandle);
+		if (CopyLobbyDetailsResult == EOS_EResult::EOS_Success)
+		{
+			EOS_LobbyDetails_Info* LobbyDetailsInfo = nullptr;
+			EOS_LobbyDetails_CopyInfoOptions CopyOptions = { };
+			CopyOptions.ApiVersion = EOS_LOBBYDETAILS_COPYINFO_API_LATEST;
+
+			EOS_EResult CopyInfoResult = EOS_LobbyDetails_CopyInfo(LobbyDetailsHandle, &CopyOptions, &LobbyDetailsInfo);
+			if (CopyInfoResult == EOS_EResult::EOS_Success)
+			{
+				CopyLobbyData(LobbyDetailsHandle, LobbyDetailsInfo, *Session);
+
+				TriggerOnSessionSettingsUpdatedDelegates(Session->SessionName, Session->SessionSettings);
+
+				EOS_LobbyDetails_Info_Release(LobbyDetailsInfo);
+			}
+			else
+			{
+				UE_LOG_ONLINE(Warning, TEXT("[FOnlineSessionEOS::OnLobbyUpdateReceived] EOS_LobbyDetails_CopyInfo not successful. Finished with EOS_EResult %s"), ANSI_TO_TCHAR(EOS_EResult_ToString(CopyInfoResult)));
+			}
+
+			EOS_LobbyDetails_Release(LobbyDetailsHandle);
+		}
+		else
+		{
+			UE_LOG_ONLINE(Warning, TEXT("[FOnlineSessionEOS::OnLobbyUpdateReceived] EOS_Lobby_CopyLobbyDetailsHandle not successful. Finished with EOS_EResult %s"), ANSI_TO_TCHAR(EOS_EResult_ToString(CopyLobbyDetailsResult)));
+		}
+	}
+	else
+	{
+		UE_LOG_ONLINE(Warning, TEXT("[FOnlineSessionEOS::OnLobbyUpdateReceived] Unable to retrieve session with LobbyId %s"), *LobbyNetId->ToString());
+	}
+}
+
+void FOnlineSessionEOS::OnLobbyMemberUpdateReceived(const EOS_LobbyId& LobbyId, const EOS_ProductUserId& TargetUserId)
+{
+	const FUniqueNetIdEOSRef LobbyNetId = FUniqueNetIdEOS::Create(UTF8_TO_TCHAR(LobbyId));
+
+	EOSSubsystem->UserManager->GetEpicAccountIdAsync(TargetUserId, [this, LobbyNetId](const EOS_ProductUserId& ProductUserId, EOS_EpicAccountId& EpicAccountId)
+		{
+			FNamedOnlineSession* Session = GetNamedSessionFromLobbyId(*LobbyNetId);
+			if (Session)
+			{
+				FUniqueNetIdPtr UniqueNetId = EOSSubsystem->UserManager->CreateUniquePlayerId(MakeNetIdStringFromIds(EpicAccountId, ProductUserId));
+
+				if (Session->SessionSettings.MemberSettings.Contains(UniqueNetId->AsShared()))
+				{
+					const FTCHARToUTF8 Utf8LobbyId(*LobbyNetId->ToString());
+
+					EOS_Lobby_CopyLobbyDetailsHandleOptions Options = {};
+					Options.ApiVersion = EOS_LOBBY_COPYLOBBYDETAILSHANDLE_API_LATEST;
+					Options.LobbyId = (EOS_LobbyId)Utf8LobbyId.Get();
+					Options.LocalUserId = EOSSubsystem->UserManager->GetLocalProductUserId();
+
+					EOS_HLobbyDetails LobbyDetailsHandle;
+
+					EOS_EResult Result = EOS_Lobby_CopyLobbyDetailsHandle(LobbyHandle, &Options, &LobbyDetailsHandle);
+					if (Result == EOS_EResult::EOS_Success)
+					{
+						CopyLobbyMemberAttributes(LobbyDetailsHandle, ProductUserId, Session->SessionSettings.MemberSettings[UniqueNetId->AsShared()]);
+
+						TriggerOnSessionParticipantSettingsUpdatedDelegates(Session->SessionName, *UniqueNetId, Session->SessionSettings);
+
+						EOS_LobbyDetails_Release(LobbyDetailsHandle);
+					}
+					else
+					{
+						UE_LOG_ONLINE(Warning, TEXT("[FOnlineSessionEOS::OnLobbyMemberUpdateReceived] EOS_LobbyDetails_CopyLobbyDetailsHandle not successful. Finished with EOS_EResult %s"), ANSI_TO_TCHAR(EOS_EResult_ToString(Result)));
+					}
+				}
+				else
+				{
+					UE_LOG_ONLINE(Warning, TEXT("[FOnlineSessionEOS::OnLobbyMemberUpdateReceived] UniqueNetId %s not registered in the session's member settings."), *UniqueNetId->ToString());
+				}
+			}
+			else
+			{
+				UE_LOG_ONLINE(Warning, TEXT("[FOnlineSessionEOS::OnLobbyMemberUpdateReceived] Unable to retrieve session with LobbyId %s"), *LobbyNetId->ToString());
+			}
+		});
+}
+
+void FOnlineSessionEOS::OnMemberStatusReceived(const EOS_LobbyId& LobbyId, const EOS_ProductUserId& TargetUserId, EOS_ELobbyMemberStatus CurrentStatus)
+{
+	const FUniqueNetIdEOSRef LobbyNetId = FUniqueNetIdEOS::Create(UTF8_TO_TCHAR(LobbyId));
+	FNamedOnlineSession* Session = GetNamedSessionFromLobbyId(*LobbyNetId);
+	if (Session)
+	{
+		switch (CurrentStatus)
+		{
+		case EOS_ELobbyMemberStatus::EOS_LMS_JOINED:
+			{
+				AddLobbyMember(LobbyNetId, TargetUserId);
+			}
+
+			break;
+		case EOS_ELobbyMemberStatus::EOS_LMS_LEFT:
+			{
+				EOSSubsystem->UserManager->GetEpicAccountIdAsync(TargetUserId, [this, LobbyNetId](const EOS_ProductUserId& ProductUserId, EOS_EpicAccountId& EpicAccountId)
+					{
+						FNamedOnlineSession* Session = GetNamedSessionFromLobbyId(*LobbyNetId);
+						if (Session)
+						{
+							FUniqueNetIdPtr UniqueNetId = EOSSubsystem->UserManager->CreateUniquePlayerId(MakeNetIdStringFromIds(EpicAccountId, ProductUserId));
+
+							UnregisterPlayer(Session->SessionName, *UniqueNetId);
+
+							// Maybe redundant with the unregister player signal?
+							TriggerOnSessionParticipantsChangeDelegates(Session->SessionName, *UniqueNetId, false);
+						}
+						else
+						{
+							UE_LOG_ONLINE(Warning, TEXT("[FOnlineSessionEOS::OnMemberStatusReceived] Unable to retrieve session with LobbyId %s"), *LobbyNetId->ToString());
+						}
+					});
+			}
+			break;
+		case EOS_ELobbyMemberStatus::EOS_LMS_DISCONNECTED:
+			// OSS Session will end
+			break;
+		case EOS_ELobbyMemberStatus::EOS_LMS_KICKED:
+			{
+				EOSSubsystem->UserManager->GetEpicAccountIdAsync(TargetUserId, [this, LobbyNetId](const EOS_ProductUserId& ProductUserId, EOS_EpicAccountId& EpicAccountId)
+					{
+						FNamedOnlineSession* Session = GetNamedSessionFromLobbyId(*LobbyNetId);
+						if (Session)
+						{
+							int32 DefaultLocalUser = EOSSubsystem->UserManager->GetDefaultLocalUser();
+
+							FUniqueNetIdPtr RemovedUserNetId = EOSSubsystem->UserManager->CreateUniquePlayerId(MakeNetIdStringFromIds(EpicAccountId, ProductUserId));
+							FUniqueNetIdPtr LocalPlayerNetId = EOSSubsystem->UserManager->GetUniquePlayerId(DefaultLocalUser);
+
+							if (*LocalPlayerNetId == *RemovedUserNetId)
+							{
+								TriggerOnSessionParticipantRemovedDelegates(Session->SessionName, *RemovedUserNetId);
+							}
+						}
+						else
+						{
+							UE_LOG_ONLINE(Warning, TEXT("[FOnlineSessionEOS::OnMemberStatusReceived] Unable to retrieve session with LobbyId %s"), *LobbyNetId->ToString());
+						}
+					});
+			}
+			break;
+		case EOS_ELobbyMemberStatus::EOS_LMS_PROMOTED:
+			{
+				EOSSubsystem->UserManager->GetEpicAccountIdAsync(TargetUserId, [this, LobbyNetId](const EOS_ProductUserId& ProductUserId, EOS_EpicAccountId& EpicAccountId)
+					{
+						FNamedOnlineSession* Session = GetNamedSessionFromLobbyId(*LobbyNetId);
+						if (Session)
+						{
+							int32 DefaultLocalUser = EOSSubsystem->UserManager->GetDefaultLocalUser();
+
+							FUniqueNetIdPtr NewOwnerUniqueNetId = EOSSubsystem->UserManager->CreateUniquePlayerId(MakeNetIdStringFromIds(EpicAccountId, ProductUserId));
+							FUniqueNetIdPtr LocalPlayerUniqueNetId = EOSSubsystem->UserManager->GetUniquePlayerId(DefaultLocalUser);
+
+							if (*LocalPlayerUniqueNetId == *NewOwnerUniqueNetId)
+							{
+								Session->OwningUserId = LocalPlayerUniqueNetId;
+								Session->OwningUserName = EOSSubsystem->UserManager->GetPlayerNickname(DefaultLocalUser);;
+								Session->bHosting = true;
+
+								UpdateLobbySession(Session);
+							}
+
+							// If we are not the new owner, the new owner will update the session and we'll receive the notification, updating ours as well
+						}
+						else
+						{
+							UE_LOG_ONLINE(Warning, TEXT("[FOnlineSessionEOS::OnMemberStatusReceived] Unable to retrieve session with LobbyId %s"), *LobbyNetId->ToString());
+						}
+					});
+			}
+			break;
+		case EOS_ELobbyMemberStatus::EOS_LMS_CLOSED:
+			// OSS Session will end
+			break;
+		}
+	}
+	else
+	{
+		UE_LOG_ONLINE(Warning, TEXT("[FOnlineSessionEOS::OnMemberStatusReceived] Unable to retrieve session with LobbyId %s"), *LobbyNetId->ToString());
+	}
+}
+
+void FOnlineSessionEOS::OnLobbyInviteAccepted(const char* InviteId, const EOS_ProductUserId& LocalUserId, const EOS_ProductUserId& TargetUserId)
+{
+	FUniqueNetIdEOSPtr NetId = EOSSubsystem->UserManager->GetLocalUniqueNetIdEOS(LocalUserId);
+	if (!NetId.IsValid())
+	{
+		UE_LOG_ONLINE_SESSION(Warning, TEXT("[FOnlineSessionEOS::OnLobbyInviteAccepted] Cannot accept lobby invite due to unknown user (%s)"), *LexToString(LocalUserId));
+		TriggerOnSessionUserInviteAcceptedDelegates(false, 0, NetId, FOnlineSessionSearchResult());
+		return;
+	}
+	int32 LocalUserNum = EOSSubsystem->UserManager->GetLocalUserNumFromUniqueNetId(*NetId);
+
+	EOS_Lobby_CopyLobbyDetailsHandleByInviteIdOptions Options = { };
+	Options.ApiVersion = EOS_LOBBY_COPYLOBBYDETAILSHANDLEBYINVITEID_API_LATEST;
+	Options.InviteId = InviteId;
+
+	EOS_HLobbyDetails LobbyDetailsHandle;
+
+	EOS_EResult Result = EOS_Lobby_CopyLobbyDetailsHandleByInviteId(LobbyHandle, &Options, &LobbyDetailsHandle);
+	if (Result == EOS_EResult::EOS_Success)
+	{
+		LastInviteSearch = MakeShared<FOnlineSessionSearch>();
+		AddLobbySearchResult(LobbyDetailsHandle, LastInviteSearch.ToSharedRef());
+		TriggerOnSessionUserInviteAcceptedDelegates(true, LocalUserNum, NetId, LastInviteSearch->SearchResults.Last());
+	}
+	else
+	{
+		UE_LOG_ONLINE_SESSION(Warning, TEXT("[FOnlineSessionEOS::OnLobbyInviteAccepted] EOS_Lobby_CopyLobbyDetailsHandleByInviteId failed with EOS result code (%s)"), ANSI_TO_TCHAR(EOS_EResult_ToString(Result)));
+		TriggerOnSessionUserInviteAcceptedDelegates(false, LocalUserNum, NetId, FOnlineSessionSearchResult());
+	}
+}
+
+void FOnlineSessionEOS::OnJoinLobbyAccepted(const EOS_ProductUserId& LocalUserId, const EOS_UI_EventId& UiEventId)
+{
+	FUniqueNetIdEOSPtr NetId = EOSSubsystem->UserManager->GetLocalUniqueNetIdEOS(LocalUserId);
+	if (!NetId.IsValid())
+	{
+		UE_LOG_ONLINE_SESSION(Warning, TEXT("[FOnlineSessionEOS::OnJoinLobbyAccepted] Cannot join lobby due to unknown user (%s)"), *LexToString(LocalUserId));
+		TriggerOnSessionUserInviteAcceptedDelegates(false, 0, NetId, FOnlineSessionSearchResult());
+		return;
+	}
+	int32 LocalUserNum = EOSSubsystem->UserManager->GetLocalUserNumFromUniqueNetId(*NetId);
+
+	EOS_Lobby_CopyLobbyDetailsHandleByUiEventIdOptions Options = { 0 };
+	Options.ApiVersion = EOS_LOBBY_COPYLOBBYDETAILSHANDLEBYUIEVENTID_API_LATEST;
+	Options.UiEventId = UiEventId;
+
+	EOS_HLobbyDetails LobbyDetailsHandle;
+	EOS_EResult Result = EOS_Lobby_CopyLobbyDetailsHandleByUiEventId(LobbyHandle, &Options, &LobbyDetailsHandle);
+	if (Result == EOS_EResult::EOS_Success)
+	{
+		LastInviteSearch = MakeShared<FOnlineSessionSearch>();
+		AddLobbySearchResult(LobbyDetailsHandle, LastInviteSearch.ToSharedRef());
+		TriggerOnSessionUserInviteAcceptedDelegates(true, LocalUserNum, NetId, LastInviteSearch->SearchResults.Last());
+	}
+	else
+	{
+		UE_LOG_ONLINE_SESSION(Warning, TEXT("[FOnlineSessionEOS::OnJoinLobbyAccepted] EOS_Lobby_CopyLobbyDetailsHandleByUiEventId failed with EOS result code (%s)"), ANSI_TO_TCHAR(EOS_EResult_ToString(Result)));
+		TriggerOnSessionUserInviteAcceptedDelegates(false, LocalUserNum, NetId, FOnlineSessionSearchResult());
+	}
+}
+
+bool FOnlineSessionEOS::CreateSession(int32 HostingPlayerNum, FName SessionName, const FOnlineSessionSettings& NewSessionSettings)
+{
+	uint32 Result = ONLINE_FAIL;
+
+	// Check for an existing session
+	FNamedOnlineSession* Session = GetNamedSession(SessionName);
+	if (Session == nullptr)
+	{
+		if (bIsDedicatedServer || EOSSubsystem->UserManager->GetLoginStatus(HostingPlayerNum) >= ELoginStatus::UsingLocalProfile)
+		{
+			// Create a new session and deep copy the game settings
+			Session = AddNamedSession(SessionName, NewSessionSettings);
+			check(Session);
+			Session->SessionState = EOnlineSessionState::Creating;
+
+			Session->OwningUserId = EOSSubsystem->UserManager->GetUniquePlayerId(HostingPlayerNum);
+			Session->OwningUserName = EOSSubsystem->UserManager->GetPlayerNickname(HostingPlayerNum);
+
+			if (bIsDedicatedServer || (Session->OwningUserId.IsValid() && Session->OwningUserId->IsValid()))
+			{
+				// RegisterPlayer will update these values for the local player
+				Session->NumOpenPrivateConnections = NewSessionSettings.NumPrivateConnections;
+				Session->NumOpenPublicConnections = NewSessionSettings.NumPublicConnections;
+
+				Session->HostingPlayerNum = HostingPlayerNum;
+
+				// Unique identifier of this build for compatibility
+				Session->SessionSettings.BuildUniqueId = GetBuildUniqueId();
+
+				// Create Internet or LAN match
+				if (!NewSessionSettings.bIsLANMatch)
+				{
+					if (Session->SessionSettings.bUseLobbiesIfAvailable)
+					{
+						Result = CreateLobbySession(HostingPlayerNum, Session);
+					}
+					else
+					{
+						Result = CreateEOSSession(HostingPlayerNum, Session);
+					}
+				}
+				else
+				{
+					Result = CreateLANSession(HostingPlayerNum, Session);
+				}
+			}
+			else
+			{
+				UE_LOG_ONLINE_SESSION(Warning, TEXT("Cannot create session '%s': invalid user (%d)."), *SessionName.ToString(), HostingPlayerNum);
+			}
+
+			if (Result != ONLINE_IO_PENDING)
+			{
+				// Set the game state as pending (not started)
+				Session->SessionState = EOnlineSessionState::Pending;
+
+				if (Result != ONLINE_SUCCESS)
+				{
+					// Clean up the session info so we don't get into a confused state
+					RemoveNamedSession(SessionName);
+				}
+				else
+				{
+					RegisterLocalPlayers(Session);
+				}
+			}
+		}
+		else
+		{
+			UE_LOG_ONLINE_SESSION(Warning, TEXT("Cannot create session '%s': user not logged in (%d)."), *SessionName.ToString(), HostingPlayerNum);
+		}
+	}
+	else
+	{
+		UE_LOG_ONLINE_SESSION(Warning, TEXT("Cannot create session '%s': session already exists."), *SessionName.ToString());
+	}
+
+	if (Result != ONLINE_IO_PENDING)
+	{
+		EOSSubsystem->ExecuteNextTick([this, SessionName, Result]()
+			{
+				TriggerOnCreateSessionCompleteDelegates(SessionName, Result == ONLINE_SUCCESS);
+			});
+	}
+
+	return true;
+}
+
+bool FOnlineSessionEOS::CreateSession(const FUniqueNetId& HostingPlayerId, FName SessionName, const FOnlineSessionSettings& NewSessionSettings)
+{
+	return CreateSession(EOSSubsystem->UserManager->GetLocalUserNumFromUniqueNetId(HostingPlayerId), SessionName, NewSessionSettings);
+}
+
+uint32 FOnlineSessionEOS::CreateLANSession(int32 HostingPlayerNum, FNamedOnlineSession* Session)
+{
+	check(Session);
+	uint32 Result = ONLINE_SUCCESS;
+
+	// Setup the host session info
+	FOnlineSessionInfoEOS* NewSessionInfo = new FOnlineSessionInfoEOS();
+	NewSessionInfo->InitLAN(EOSSubsystem);
+	Session->SessionInfo = MakeShareable(NewSessionInfo);
+
+	// Don't create a the beacon if advertising is off
+	if (Session->SessionSettings.bShouldAdvertise)
+	{
+		if (!LANSession.IsValid())
+		{
+			LANSession = MakeShareable(new FLANSession());
+		}
+
+		FOnValidQueryPacketDelegate QueryPacketDelegate = FOnValidQueryPacketDelegate::CreateRaw(this, &FOnlineSessionEOS::OnValidQueryPacketReceived);
+		if (!LANSession->Host(QueryPacketDelegate))
+		{
+			Result = ONLINE_FAIL;
+		}
+	}
+
+	return Result;
+}
+
+void FOnlineSessionEOS::SetPermissionLevel(EOS_HSessionModification SessionModHandle, FNamedOnlineSession* Session)
+{
+	EOS_SessionModification_SetPermissionLevelOptions Options = { };
+	Options.ApiVersion = EOS_SESSIONMODIFICATION_SETPERMISSIONLEVEL_API_LATEST;
+	if (Session->SessionSettings.NumPublicConnections > 0)
+	{
+		Options.PermissionLevel = EOS_EOnlineSessionPermissionLevel::EOS_OSPF_PublicAdvertised;
+	}
+	else if (Session->SessionSettings.bAllowJoinViaPresence)
+	{
+		Options.PermissionLevel = EOS_EOnlineSessionPermissionLevel::EOS_OSPF_JoinViaPresence;
+	}
+	else
+	{
+		Options.PermissionLevel = EOS_EOnlineSessionPermissionLevel::EOS_OSPF_InviteOnly;
+	}
+
+	UE_LOG_ONLINE_SESSION(Log, TEXT("EOS_SessionModification_SetPermissionLevel() set to (%d)"), (int32)Options.PermissionLevel);
+
+	EOS_EResult ResultCode = EOS_SessionModification_SetPermissionLevel(SessionModHandle, &Options);
+	if (ResultCode != EOS_EResult::EOS_Success)
+	{
+		UE_LOG_ONLINE_SESSION(Error, TEXT("EOS_SessionModification_SetPermissionLevel() failed with EOS result code (%s)"), ANSI_TO_TCHAR(EOS_EResult_ToString(ResultCode)));
+	}
+}
+
+void FOnlineSessionEOS::SetJoinInProgress(EOS_HSessionModification SessionModHandle, FNamedOnlineSession* Session)
+{
+	EOS_SessionModification_SetJoinInProgressAllowedOptions Options = { };
+	Options.ApiVersion = EOS_SESSIONMODIFICATION_SETJOININPROGRESSALLOWED_API_LATEST;
+	Options.bAllowJoinInProgress = Session->SessionSettings.bAllowJoinInProgress ? EOS_TRUE : EOS_FALSE;
+
+	UE_LOG_ONLINE_SESSION(Log, TEXT("EOS_SessionModification_SetJoinInProgressAllowed() set to (%d)"), Options.bAllowJoinInProgress);
+
+	EOS_EResult ResultCode = EOS_SessionModification_SetJoinInProgressAllowed(SessionModHandle, &Options);
+	if (ResultCode != EOS_EResult::EOS_Success)
+	{
+		UE_LOG_ONLINE_SESSION(Error, TEXT("EOS_SessionModification_SetJoinInProgressAllowed() failed with EOS result code (%s)"), ANSI_TO_TCHAR(EOS_EResult_ToString(ResultCode)));
+	}
+}
+
+void FOnlineSessionEOS::AddAttribute(EOS_HSessionModification SessionModHandle, const EOS_Sessions_AttributeData* Attribute)
+{
+	EOS_SessionModification_AddAttributeOptions Options = { };
+	Options.ApiVersion = EOS_SESSIONMODIFICATION_ADDATTRIBUTE_API_LATEST;
+	Options.AdvertisementType = EOS_ESessionAttributeAdvertisementType::EOS_SAAT_Advertise;
+	Options.SessionAttribute = Attribute;
+
+	UE_LOG_ONLINE_SESSION(Log, TEXT("EOS_SessionModification_AddAttribute() named (%s) with value (%s)"), *FString(Attribute->Key), *MakeStringFromAttributeValue(Attribute));
+
+	EOS_EResult ResultCode = EOS_SessionModification_AddAttribute(SessionModHandle, &Options);
+	if (ResultCode != EOS_EResult::EOS_Success)
+	{
+		UE_LOG_ONLINE_SESSION(Error, TEXT("EOS_SessionModification_AddAttribute() failed for attribute name (%s) with EOS result code (%s)"), *FString(Attribute->Key), ANSI_TO_TCHAR(EOS_EResult_ToString(ResultCode)));
+	}
+}
+
+void FOnlineSessionEOS::SetAttributes(EOS_HSessionModification SessionModHandle, FNamedOnlineSession* Session)
+{
+	// The first will let us find it on session searches
+	const FString SearchPresence(SEARCH_PRESENCE.ToString());
+	const FAttributeOptions SearchPresenceAttribute(TCHAR_TO_UTF8(*SearchPresence), true);
+	AddAttribute(SessionModHandle, &SearchPresenceAttribute);
+
+	FAttributeOptions Opt1("NumPrivateConnections", Session->SessionSettings.NumPrivateConnections);
+	AddAttribute(SessionModHandle, &Opt1);
+
+	FAttributeOptions Opt2("NumPublicConnections", Session->SessionSettings.NumPublicConnections);
+	AddAttribute(SessionModHandle, &Opt2);
+
+	// Handle auto generation of dedicated server names
+	if (Session->OwningUserName.IsEmpty())
+	{
+		FString OwningPlayerName(TEXT("DedicatedServer - "));
+
+		FString UserName = FPlatformProcess::UserName();
+		if (UserName.IsEmpty())
+		{
+			FString ComputerName = FPlatformProcess::ComputerName();
+			OwningPlayerName += ComputerName;
+		}
+		else
+		{
+			OwningPlayerName += UserName;
+		}
+		Session->OwningUserName = OwningPlayerName;
+	}
+
+	FAttributeOptions Opt5("bAntiCheatProtected", Session->SessionSettings.bAntiCheatProtected);
+	AddAttribute(SessionModHandle, &Opt5);
+
+	FAttributeOptions Opt6("bUsesStats", Session->SessionSettings.bUsesStats);
+	AddAttribute(SessionModHandle, &Opt6);
+
+	FAttributeOptions Opt7("bIsDedicated", Session->SessionSettings.bIsDedicated);
+	AddAttribute(SessionModHandle, &Opt7);
+
+	FAttributeOptions Opt8("BuildUniqueId", Session->SessionSettings.BuildUniqueId);
+	AddAttribute(SessionModHandle, &Opt8);
+
+	// Add all of the session settings
+	for (FSessionSettings::TConstIterator It(Session->SessionSettings.Settings); It; ++It)
+	{
+		const FName KeyName = It.Key();
+		const FOnlineSessionSetting& Setting = It.Value();
+
+		// Skip unsupported types or non session advertised settings
+		if (Setting.AdvertisementType < EOnlineDataAdvertisementType::ViaOnlineService || !IsSessionSettingTypeSupported(Setting.Data.GetType()))
+		{
+			continue;
+		}
+
+		FAttributeOptions Attribute(TCHAR_TO_UTF8(*KeyName.ToString()), Setting.Data);
+		AddAttribute(SessionModHandle, &Attribute);
+	}
+}
+
+struct FBeginMetricsOptions :
+	public EOS_Metrics_BeginPlayerSessionOptions
+{
+	char DisplayNameAnsi[EOS_OSS_STRING_BUFFER_LENGTH];
+	char ServerIpAnsi[EOS_OSS_STRING_BUFFER_LENGTH];
+	char SessionIdAnsi[EOS_OSS_STRING_BUFFER_LENGTH];
+	char ExternalIdAnsi[EOS_OSS_STRING_BUFFER_LENGTH];
+
+	FBeginMetricsOptions() :
+		EOS_Metrics_BeginPlayerSessionOptions()
+	{
+		ApiVersion = EOS_METRICS_BEGINPLAYERSESSION_API_LATEST;
+		GameSessionId = SessionIdAnsi;
+		DisplayName = DisplayNameAnsi;
+		ServerIp = ServerIpAnsi;
+		AccountId.External = ExternalIdAnsi;
+	}
+};
+
+void FOnlineSessionEOS::BeginSessionAnalytics(FNamedOnlineSession* Session)
+{
+	int32 LocalUserNum = EOSSubsystem->UserManager->GetDefaultLocalUser();
+	FOnlineUserPtr LocalUser = EOSSubsystem->UserManager->GetLocalOnlineUser(LocalUserNum);
+	if (LocalUser.IsValid())
+	{
+		TSharedPtr<const FOnlineSessionInfoEOS> SessionInfoEOS = StaticCastSharedPtr<const FOnlineSessionInfoEOS>(Session->SessionInfo);
+
+		FBeginMetricsOptions Options;
+		FCStringAnsi::Strncpy(Options.ServerIpAnsi, TCHAR_TO_UTF8(*SessionInfoEOS->HostAddr->ToString(false)), EOS_OSS_STRING_BUFFER_LENGTH);
+		FString DisplayName = LocalUser->GetDisplayName();
+		FCStringAnsi::Strncpy(Options.DisplayNameAnsi, TCHAR_TO_UTF8(*DisplayName), EOS_OSS_STRING_BUFFER_LENGTH);
+		Options.AccountIdType = EOS_EMetricsAccountIdType::EOS_MAIT_Epic;
+		Options.AccountId.Epic = EOSSubsystem->UserManager->GetLocalEpicAccountId(LocalUserNum);
+
+		EOS_EResult Result = EOS_Metrics_BeginPlayerSession(EOSSubsystem->MetricsHandle, &Options);
+		if (Result != EOS_EResult::EOS_Success)
+		{
+			UE_LOG_ONLINE_SESSION(Error, TEXT("EOS_Metrics_BeginPlayerSession() returned EOS result code (%s)"), ANSI_TO_TCHAR(EOS_EResult_ToString(Result)));
+		}
+	}
+}
+
+template<typename BaseStruct>
+struct TNamedSessionOptions :
+	public BaseStruct
+{
+	char SessionNameAnsi[EOS_OSS_STRING_BUFFER_LENGTH];
+
+	TNamedSessionOptions(const char* InSessionNameAnsi)
+		: BaseStruct()
+	{
+		FCStringAnsi::Strncpy(SessionNameAnsi, InSessionNameAnsi, EOS_OSS_STRING_BUFFER_LENGTH);
+		this->SessionName = SessionNameAnsi;
+	}
+};
+
+struct FSessionCreateOptions :
+	public TNamedSessionOptions<EOS_Sessions_CreateSessionModificationOptions>
+{
+	FSessionCreateOptions(const char* InSessionNameAnsi) :
+		TNamedSessionOptions<EOS_Sessions_CreateSessionModificationOptions>(InSessionNameAnsi)
+	{
+		ApiVersion = EOS_SESSIONS_CREATESESSIONMODIFICATION_API_LATEST;
+		BucketId = BucketIdAnsi;
+	}
+};
+
+uint32 FOnlineSessionEOS::CreateEOSSession(int32 HostingPlayerNum, FNamedOnlineSession* Session)
+{
+	check(Session != nullptr);
+
+	EOS_HSessionModification SessionModHandle = nullptr;
+
+	FSessionCreateOptions Options(TCHAR_TO_UTF8(*Session->SessionName.ToString()));
+	Options.MaxPlayers = Session->SessionSettings.NumPrivateConnections + Session->SessionSettings.NumPublicConnections;
+	Options.LocalUserId = EOSSubsystem->UserManager->GetLocalProductUserId(HostingPlayerNum);
+	Options.bPresenceEnabled = (Session->SessionSettings.bUsesPresence ||
+		Session->SessionSettings.bAllowJoinViaPresence ||
+		Session->SessionSettings.bAllowJoinViaPresenceFriendsOnly ||
+		Session->SessionSettings.bAllowInvites) ? EOS_TRUE : EOS_FALSE;
+
+	EOS_EResult ResultCode = EOS_Sessions_CreateSessionModification(EOSSubsystem->SessionsHandle, &Options, &SessionModHandle);
+	if (ResultCode != EOS_EResult::EOS_Success)
+	{
+		UE_LOG_ONLINE_SESSION(Error, TEXT("EOS_Sessions_CreateSessionModification() failed with EOS result code (%s)"), ANSI_TO_TCHAR(EOS_EResult_ToString(ResultCode)));
+		return ONLINE_FAIL;
+	}
+
+	Session->SessionState = EOnlineSessionState::Creating;
+	Session->bHosting = true;
+
+	FString HostAddr;
+	// If we are not a dedicated server and are using p2p sockets, then we need to add a custom URL for connecting
+	if (!bIsDedicatedServer && bIsUsingP2PSockets)
+	{
+		// Because some platforms remap ports, we will use the ID of the name of the net driver to be our port instead
+		FName NetDriverName = GetDefault<UNetDriverEOS>()->NetDriverName;
+		FInternetAddrEOS TempAddr(LexToString(Options.LocalUserId), NetDriverName.ToString(), GetTypeHash(NetDriverName.ToString()));
+		HostAddr = TempAddr.ToString(true);
+		char HostAddrAnsi[EOS_OSS_STRING_BUFFER_LENGTH];
+		FCStringAnsi::Strncpy(HostAddrAnsi, TCHAR_TO_UTF8(*HostAddr), EOS_OSS_STRING_BUFFER_LENGTH);
+
+		EOS_SessionModification_SetHostAddressOptions HostOptions = { };
+		HostOptions.ApiVersion = EOS_SESSIONMODIFICATION_SETHOSTADDRESS_API_LATEST;
+		// Expect URLs to look like "EOS:PUID:SocketName:Channel" and channel can be optional
+		HostOptions.HostAddress = HostAddrAnsi;
+		EOS_EResult HostResult = EOS_SessionModification_SetHostAddress(SessionModHandle, &HostOptions);
+		UE_LOG_ONLINE_SESSION(Log, TEXT("EOS_SessionModification_SetHostAddress(%s) returned (%s)"), *HostAddr, ANSI_TO_TCHAR(EOS_EResult_ToString(HostResult)));
+	}
+	else
+	{
+		// This is basically ignored
+		HostAddr = TEXT("127.0.0.1");
+	}
+	Session->SessionInfo = MakeShareable(new FOnlineSessionInfoEOS(HostAddr, FUniqueNetIdEOS::EmptyId(), nullptr));
+
+	FName SessionName = Session->SessionName;
+
+	FUpdateSessionCallback* CallbackObj = new FUpdateSessionCallback();
+	CallbackObj->CallbackLambda = [this, SessionName](const EOS_Sessions_UpdateSessionCallbackInfo* Data)
+	{
+		bool bWasSuccessful = false;
+
+		FNamedOnlineSession* Session = GetNamedSession(SessionName);
+		if (Session)
+		{
+			bWasSuccessful = Data->ResultCode == EOS_EResult::EOS_Success || Data->ResultCode == EOS_EResult::EOS_Sessions_OutOfSync;
+			if (bWasSuccessful)
+			{
+				TSharedPtr<FOnlineSessionInfoEOS> SessionInfo = StaticCastSharedPtr<FOnlineSessionInfoEOS>(Session->SessionInfo);
+				if (SessionInfo.IsValid())
+				{
+					SessionInfo->SessionId = FUniqueNetIdEOS::Create(Data->SessionId);
+				}
+
+				Session->SessionState = EOnlineSessionState::Pending;
+				BeginSessionAnalytics(Session);
+
+				RegisterLocalPlayers(Session);
+			}
+			else
+			{
+				UE_LOG_ONLINE_SESSION(Error, TEXT("EOS_Sessions_UpdateSession() failed with EOS result code (%s)"), ANSI_TO_TCHAR(EOS_EResult_ToString(Data->ResultCode)));
+
+				Session->SessionState = EOnlineSessionState::NoSession;
+
+				RemoveNamedSession(SessionName);
+			}
+		}
+
+		TriggerOnCreateSessionCompleteDelegates(SessionName, bWasSuccessful);
+	};
+
+	return SharedSessionUpdate(SessionModHandle, Session, CallbackObj);
+}
+
+uint32 FOnlineSessionEOS::SharedSessionUpdate(EOS_HSessionModification SessionModHandle, FNamedOnlineSession* Session, FUpdateSessionCallback* Callback)
+{
+	// Set invite flags
+	SetPermissionLevel(SessionModHandle, Session);
+	// Set JIP flag
+	SetJoinInProgress(SessionModHandle, Session);
+	// Add any attributes for filtering by searchers
+	SetAttributes(SessionModHandle, Session);
+
+	// Commit the session changes
+	EOS_Sessions_UpdateSessionOptions CreateOptions = { };
+	CreateOptions.ApiVersion = EOS_SESSIONS_UPDATESESSION_API_LATEST;
+	CreateOptions.SessionModificationHandle = SessionModHandle;
+	EOS_Sessions_UpdateSession(EOSSubsystem->SessionsHandle, &CreateOptions, Callback, Callback->GetCallbackPtr());
+
+	EOS_SessionModification_Release(SessionModHandle);
+
+	return ONLINE_IO_PENDING;
+}
+
+bool FOnlineSessionEOS::StartSession(FName SessionName)
+{
+	uint32 Result = ONLINE_FAIL;
+	// Grab the session information by name
+	FNamedOnlineSession* Session = GetNamedSession(SessionName);
+	if (Session)
+	{
+		// Can't start a match multiple times
+		if (Session->SessionState == EOnlineSessionState::Pending ||
+			Session->SessionState == EOnlineSessionState::Ended)
+		{
+			if (!Session->SessionSettings.bIsLANMatch)
+			{
+				if (Session->SessionSettings.bUseLobbiesIfAvailable)
+				{
+					Result = StartLobbySession(Session);
+				}
+				else
+				{
+					Result = StartEOSSession(Session);
+				}
+			}
+			else
+			{
+				// If this lan match has join in progress disabled, shut down the beacon
+				if (!Session->SessionSettings.bAllowJoinInProgress)
+				{
+					LANSession->StopLANSession();
+				}
+				Result = ONLINE_SUCCESS;
+				Session->SessionState = EOnlineSessionState::InProgress;
+			}
+		}
+		else
+		{
+			UE_LOG_ONLINE_SESSION(Warning, TEXT("Can't start an online session (%s) in state %s"),
+				*SessionName.ToString(),
+				EOnlineSessionState::ToString(Session->SessionState));
+		}
+	}
+	else
+	{
+		UE_LOG_ONLINE_SESSION(Warning, TEXT("Can't start an online game for session (%s) that hasn't been created"), *SessionName.ToString());
+	}
+
+	if (Result != ONLINE_IO_PENDING)
+	{
+		EOSSubsystem->ExecuteNextTick([this, SessionName, Result]()
+			{
+				TriggerOnStartSessionCompleteDelegates(SessionName, Result == ONLINE_SUCCESS);
+			});
+	}
+
+	return true;
+}
+
+struct FSessionStartOptions :
+	public TNamedSessionOptions<EOS_Sessions_StartSessionOptions>
+{
+	FSessionStartOptions(const char* InSessionNameAnsi) :
+		TNamedSessionOptions<EOS_Sessions_StartSessionOptions>(InSessionNameAnsi)
+	{
+		ApiVersion = EOS_SESSIONS_STARTSESSION_API_LATEST;
+	}
+};
+
+typedef TEOSCallback<EOS_Sessions_OnStartSessionCallback, EOS_Sessions_StartSessionCallbackInfo> FStartSessionCallback;
+
+uint32 FOnlineSessionEOS::StartEOSSession(FNamedOnlineSession* Session)
+{
+	Session->SessionState = EOnlineSessionState::Starting;
+
+	FSessionStartOptions Options(TCHAR_TO_UTF8(*Session->SessionName.ToString()));
+	FStartSessionCallback* CallbackObj = new FStartSessionCallback();
+	CallbackObj->CallbackLambda = [this, Session](const EOS_Sessions_StartSessionCallbackInfo* Data)
+	{
+		Session->SessionState = EOnlineSessionState::InProgress;
+
+		bool bWasSuccessful = Data->ResultCode == EOS_EResult::EOS_Success;
+		if (!bWasSuccessful)
+		{
+			UE_LOG_ONLINE_SESSION(Error, TEXT("EOS_Sessions_StartSession() failed with EOS result code (%s)"), ANSI_TO_TCHAR(EOS_EResult_ToString(Data->ResultCode)));
+		}
+		TriggerOnStartSessionCompleteDelegates(Session->SessionName, bWasSuccessful);
+	};
+
+	EOS_Sessions_StartSession(EOSSubsystem->SessionsHandle, &Options, CallbackObj, CallbackObj->GetCallbackPtr());
+
+	return ONLINE_IO_PENDING;
+}
+
+uint32 FOnlineSessionEOS::StartLobbySession(FNamedOnlineSession* Session)
+{
+	Session->SessionState = EOnlineSessionState::Starting;
+
+	EOSSubsystem->ExecuteNextTick([this, Session]()
+	{
+		Session->SessionState = EOnlineSessionState::InProgress;
+
+		TriggerOnStartSessionCompleteDelegates(Session->SessionName, true);
+	});
+
+	return ONLINE_IO_PENDING;
+}
+
+bool FOnlineSessionEOS::UpdateSession(FName SessionName, FOnlineSessionSettings& UpdatedSessionSettings, bool bShouldRefreshOnlineData)
+{
+	int32 Result = ONLINE_FAIL;
+
+	// Grab the session information by name
+	FNamedOnlineSession* Session = GetNamedSession(SessionName);
+	if (Session)
+	{
+		Session->SessionSettings = UpdatedSessionSettings;
+
+		if (!Session->SessionSettings.bIsLANMatch)
+		{
+			if (Session->SessionSettings.bUseLobbiesIfAvailable)
+			{
+				Result = UpdateLobbySession(Session);
+			}
+			else
+			{
+				Result = UpdateEOSSession(Session);
+			}
+		}
+		else
+		{
+			Result = ONLINE_SUCCESS;
+		}
+	}
+	else
+	{
+		UE_LOG_ONLINE_SESSION(Warning, TEXT("No session (%s) found for update!"), *SessionName.ToString());
+	}
+
+	if (Result != ONLINE_IO_PENDING)
+	{
+		EOSSubsystem->ExecuteNextTick([this, SessionName, Result]()
+			{
+				TriggerOnUpdateSessionCompleteDelegates(SessionName, Result == ONLINE_SUCCESS);
+			});
+	}
+
+	return true;
+}
+
+struct FSessionUpdateOptions :
+	public TNamedSessionOptions<EOS_Sessions_UpdateSessionModificationOptions>
+{
+	FSessionUpdateOptions(const char* InSessionNameAnsi) :
+		TNamedSessionOptions<EOS_Sessions_UpdateSessionModificationOptions>(InSessionNameAnsi)
+	{
+		ApiVersion = EOS_SESSIONS_UPDATESESSIONMODIFICATION_API_LATEST;
+	}
+};
+
+uint32 FOnlineSessionEOS::UpdateEOSSession(FNamedOnlineSession* Session)
+{
+	if (Session->SessionState == EOnlineSessionState::Creating)
+	{
+		return ONLINE_IO_PENDING;
+	}
+
+	EOS_HSessionModification SessionModHandle = NULL;
+	FSessionUpdateOptions Options(TCHAR_TO_UTF8(*Session->SessionName.ToString()));
+
+	EOS_EResult ResultCode = EOS_Sessions_UpdateSessionModification(EOSSubsystem->SessionsHandle, &Options, &SessionModHandle);
+	if (ResultCode != EOS_EResult::EOS_Success)
+	{
+		UE_LOG_ONLINE_SESSION(Error, TEXT("EOS_Sessions_UpdateSessionModification() failed with EOS result code (%s)"), ANSI_TO_TCHAR(EOS_EResult_ToString(ResultCode)));
+		return ONLINE_FAIL;
+	}
+
+	FUpdateSessionCallback* CallbackObj = new FUpdateSessionCallback();
+	CallbackObj->CallbackLambda = [this, Session](const EOS_Sessions_UpdateSessionCallbackInfo* Data)
+	{
+		bool bWasSuccessful = Data->ResultCode == EOS_EResult::EOS_Success || Data->ResultCode == EOS_EResult::EOS_Sessions_OutOfSync;
+		if (!bWasSuccessful)
+		{
+			Session->SessionState = EOnlineSessionState::NoSession;
+			UE_LOG_ONLINE_SESSION(Error, TEXT("EOS_Sessions_UpdateSession() failed with EOS result code (%s)"), ANSI_TO_TCHAR(EOS_EResult_ToString(Data->ResultCode)));
+		}
+		TriggerOnUpdateSessionCompleteDelegates(Session->SessionName, bWasSuccessful);
+	};
+
+	return SharedSessionUpdate(SessionModHandle, Session, CallbackObj);
+}
+
+bool FOnlineSessionEOS::EndSession(FName SessionName)
+{
+	uint32 Result = ONLINE_FAIL;
+
+	// Grab the session information by name
+	FNamedOnlineSession* Session = GetNamedSession(SessionName);
+	if (Session)
+	{
+		// Can't end a match that isn't in progress
+		if (Session->SessionState == EOnlineSessionState::InProgress)
+		{
+			if (!Session->SessionSettings.bIsLANMatch)
+			{
+				if (Session->SessionSettings.bUseLobbiesIfAvailable)
+				{
+					Result = EndLobbySession(Session);
+				}
+				else
+				{
+					Result = EndEOSSession(Session);
+				}
+			}
+			else
+			{
+				// If the session should be advertised and the lan beacon was destroyed, recreate
+				if (Session->SessionSettings.bShouldAdvertise &&
+					!LANSession.IsValid() &&
+					LANSession->LanBeacon == nullptr &&
+					EOSSubsystem->IsServer())
+				{
+					// Recreate the beacon
+					Result = CreateLANSession(Session->HostingPlayerNum, Session);
+				}
+				else
+				{
+					Result = ONLINE_SUCCESS;
+				}
+			}
+		}
+		else
+		{
+			UE_LOG_ONLINE_SESSION(Warning, TEXT("Can't end session (%s) in state %s"),
+				*SessionName.ToString(),
+				EOnlineSessionState::ToString(Session->SessionState));
+		}
+	}
+	else
+	{
+		UE_LOG_ONLINE_SESSION(Warning, TEXT("Can't end an online game for session (%s) that hasn't been created"),
+			*SessionName.ToString());
+	}
+
+	if (Result != ONLINE_IO_PENDING)
+	{
+		EOSSubsystem->ExecuteNextTick([this, Session, SessionName, Result]()
+			{
+				if (Session)
+				{
+					Session->SessionState = EOnlineSessionState::Ended;
+				}
+
+				TriggerOnEndSessionCompleteDelegates(SessionName, Result == ONLINE_SUCCESS);
+			});
+	}
+
+	return true;
+}
+
+struct FSessionEndOptions :
+	public TNamedSessionOptions<EOS_Sessions_EndSessionOptions>
+{
+	FSessionEndOptions(const char* InSessionNameAnsi) :
+		TNamedSessionOptions<EOS_Sessions_EndSessionOptions>(InSessionNameAnsi)
+	{
+		ApiVersion = EOS_SESSIONS_ENDSESSION_API_LATEST;
+	}
+};
+
+typedef TEOSCallback<EOS_Sessions_OnEndSessionCallback, EOS_Sessions_EndSessionCallbackInfo> FEndSessionCallback;
+
+uint32 FOnlineSessionEOS::EndEOSSession(FNamedOnlineSession* Session)
+{
+	// Only called from EndSession/DestroySession and presumes only in InProgress state
+	check(Session && Session->SessionState == EOnlineSessionState::InProgress);
+
+	Session->SessionState = EOnlineSessionState::Ending;
+
+	FSessionEndOptions Options(TCHAR_TO_UTF8(*Session->SessionName.ToString()));
+	FEndSessionCallback* CallbackObj = new FEndSessionCallback();
+	CallbackObj->CallbackLambda = [this, Session](const EOS_Sessions_EndSessionCallbackInfo* Data)
+	{
+		Session->SessionState = EOnlineSessionState::Ended;
+
+		bool bWasSuccessful = Data->ResultCode == EOS_EResult::EOS_Success;
+		if (!bWasSuccessful)
+		{
+			UE_LOG_ONLINE_SESSION(Error, TEXT("EOS_Sessions_EndSession() failed with EOS result code (%s)"), ANSI_TO_TCHAR(EOS_EResult_ToString(Data->ResultCode)));
+		}
+		TriggerOnEndSessionCompleteDelegates(Session->SessionName, bWasSuccessful);
+	};
+
+	EOS_Sessions_EndSession(EOSSubsystem->SessionsHandle, &Options, CallbackObj, CallbackObj->GetCallbackPtr());
+
+	return ONLINE_IO_PENDING;
+}
+
+bool FOnlineSessionEOS::DestroySession(FName SessionName, const FOnDestroySessionCompleteDelegate& CompletionDelegate)
+{
+	uint32 Result = ONLINE_FAIL;
+
+	// Find the session in question
+	FNamedOnlineSession* Session = GetNamedSession(SessionName);
+	if (Session)
+	{
+		if (Session->SessionState != EOnlineSessionState::Destroying)
+		{
+			if (!Session->SessionSettings.bIsLANMatch)
+			{
+				if (Session->SessionState == EOnlineSessionState::InProgress)
+				{
+					if (Session->SessionSettings.bUseLobbiesIfAvailable)
+					{
+						Result = EndLobbySession(Session);
+					}
+					else
+					{
+						Result = EndEOSSession(Session);
+					}
+				}
+
+				if (Session->SessionSettings.bUseLobbiesIfAvailable)
+				{
+					Result = DestroyLobbySession(Session, CompletionDelegate);
+				}
+				else
+				{
+					Result = DestroyEOSSession(Session, CompletionDelegate);
+				}
+			}
+			else
+			{
+				if (LANSession.IsValid())
+				{
+					// Tear down the LAN beacon
+					LANSession->StopLANSession();
+					LANSession = nullptr;
+				}
+
+				Result = ONLINE_SUCCESS;
+			}
+
+			if (Result != ONLINE_IO_PENDING)
+			{
+				EOSSubsystem->ExecuteNextTick([this, CompletionDelegate, SessionName, Result]()
+					{
+						// The session info is no longer needed
+						RemoveNamedSession(SessionName);
+						CompletionDelegate.ExecuteIfBound(SessionName, Result == ONLINE_SUCCESS);
+						TriggerOnDestroySessionCompleteDelegates(SessionName, Result == ONLINE_SUCCESS);
+					});
+			}
+		}
+		else
+		{
+			// Purposefully skip the delegate call as one should already be in flight
+			UE_LOG_ONLINE_SESSION(Warning, TEXT("Already in process of destroying session (%s)"), *SessionName.ToString());
+		}
+	}
+	else
+	{
+		EOSSubsystem->ExecuteNextTick([this, CompletionDelegate, SessionName, Result]()
+			{
+				UE_LOG_ONLINE_SESSION(Warning, TEXT("Can't destroy a null online session (%s)"), *SessionName.ToString());
+				CompletionDelegate.ExecuteIfBound(SessionName, false);
+				TriggerOnDestroySessionCompleteDelegates(SessionName, false);
+			});
+	}
+
+	return true;
+}
+
+struct FEndMetricsOptions :
+	public EOS_Metrics_EndPlayerSessionOptions
+{
+	char ExternalIdAnsi[EOS_OSS_STRING_BUFFER_LENGTH];
+
+	FEndMetricsOptions() :
+		EOS_Metrics_EndPlayerSessionOptions()
+	{
+		ApiVersion = EOS_METRICS_ENDPLAYERSESSION_API_LATEST;
+		AccountId.External = ExternalIdAnsi;
+	}
+};
+
+void FOnlineSessionEOS::EndSessionAnalytics()
+{
+	int32 LocalUserNum = EOSSubsystem->UserManager->GetDefaultLocalUser();
+	FOnlineUserPtr LocalUser = EOSSubsystem->UserManager->GetLocalOnlineUser(LocalUserNum);
+	if (LocalUser.IsValid())
+	{
+		FEndMetricsOptions Options;
+		Options.AccountIdType = EOS_EMetricsAccountIdType::EOS_MAIT_Epic;
+		Options.AccountId.Epic = EOSSubsystem->UserManager->GetLocalEpicAccountId(LocalUserNum);
+
+		EOS_EResult Result = EOS_Metrics_EndPlayerSession(EOSSubsystem->MetricsHandle, &Options);
+		if (Result != EOS_EResult::EOS_Success)
+		{
+			UE_LOG_ONLINE_SESSION(Error, TEXT("EOS_Metrics_EndPlayerSession() returned EOS result code (%s)"), ANSI_TO_TCHAR(EOS_EResult_ToString(Result)));
+		}
+	}
+}
+
+struct FSessionDestroyOptions :
+	public TNamedSessionOptions<EOS_Sessions_DestroySessionOptions>
+{
+	FSessionDestroyOptions(const char* InSessionNameAnsi) :
+		TNamedSessionOptions<EOS_Sessions_DestroySessionOptions>(InSessionNameAnsi)
+	{
+		ApiVersion = EOS_SESSIONS_DESTROYSESSION_API_LATEST;
+	}
+};
+
+typedef TEOSCallback<EOS_Sessions_OnDestroySessionCallback, EOS_Sessions_DestroySessionCallbackInfo> FDestroySessionCallback;
+
+uint32 FOnlineSessionEOS::DestroyEOSSession(FNamedOnlineSession* Session, const FOnDestroySessionCompleteDelegate& CompletionDelegate)
+{
+	Session->SessionState = EOnlineSessionState::Destroying;
+
+	FSessionDestroyOptions Options(TCHAR_TO_UTF8(*Session->SessionName.ToString()));
+	FDestroySessionCallback* CallbackObj = new FDestroySessionCallback();
+	CallbackObj->CallbackLambda = [this, Session](const EOS_Sessions_DestroySessionCallbackInfo* Data)
+	{
+		EndSessionAnalytics();
+
+		Session->SessionState = EOnlineSessionState::NoSession;
+		FName SessionName = Session->SessionName;
+
+		bool bWasSuccessful = Data->ResultCode == EOS_EResult::EOS_Success;
+		if (!bWasSuccessful)
+		{
+			UE_LOG_ONLINE_SESSION(Error, TEXT("EOS_Sessions_DestroySession() failed with EOS result code (%s)"), ANSI_TO_TCHAR(EOS_EResult_ToString(Data->ResultCode)));
+		}
+		RemoveNamedSession(SessionName);
+		TriggerOnDestroySessionCompleteDelegates(SessionName, bWasSuccessful);
+	};
+
+	EOS_Sessions_DestroySession(EOSSubsystem->SessionsHandle, &Options, CallbackObj, CallbackObj->GetCallbackPtr());
+
+	return ONLINE_IO_PENDING;
+}
+
+bool FOnlineSessionEOS::IsPlayerInSession(FName SessionName, const FUniqueNetId& UniqueId)
+{
+	return IsPlayerInSessionImpl(this, SessionName, UniqueId);
+}
+
+bool FOnlineSessionEOS::StartMatchmaking(const TArray< FUniqueNetIdRef >& LocalPlayers, FName SessionName, const FOnlineSessionSettings& NewSessionSettings, TSharedRef<FOnlineSessionSearch>& SearchSettings)
+{
+	EOSSubsystem->ExecuteNextTick([this, SessionName]()
+		{
+			UE_LOG_ONLINE_SESSION(Warning, TEXT("StartMatchmaking is not supported on this platform. Use FindSessions or FindSessionById."));
+			TriggerOnMatchmakingCompleteDelegates(SessionName, false);
+		});
+
+	return true;
+}
+
+bool FOnlineSessionEOS::CancelMatchmaking(int32 SearchingPlayerNum, FName SessionName)
+{
+	EOSSubsystem->ExecuteNextTick([this, SessionName]()
+		{
+			UE_LOG_ONLINE_SESSION(Warning, TEXT("CancelMatchmaking is not supported on this platform. Use CancelFindSessions."));
+			TriggerOnCancelMatchmakingCompleteDelegates(SessionName, false);
+		});
+
+	return true;
+}
+
+bool FOnlineSessionEOS::CancelMatchmaking(const FUniqueNetId& SearchingPlayerId, FName SessionName)
+{
+	EOSSubsystem->ExecuteNextTick([this, SessionName]()
+		{
+			UE_LOG_ONLINE_SESSION(Warning, TEXT("CancelMatchmaking is not supported on this platform. Use CancelFindSessions."));
+			TriggerOnCancelMatchmakingCompleteDelegates(SessionName, false);
+		});
+
+	return true;
+}
+
+bool FOnlineSessionEOS::FindSessions(int32 SearchingPlayerNum, const TSharedRef<FOnlineSessionSearch>& SearchSettings)
+{
+	uint32 Return = ONLINE_FAIL;
+
+	// Don't start another search while one is in progress
+	if (!CurrentSessionSearch.IsValid() || SearchSettings->SearchState != EOnlineAsyncTaskState::InProgress)
+	{
+		// LAN searching uses this as an approximation for ping so make sure to set it
+		SessionSearchStartInSeconds = FPlatformTime::Seconds();
+
+		// Free up previous results
+		SearchSettings->SearchResults.Empty();
+		// Copy the search pointer so we can keep it around
+		CurrentSessionSearch = SearchSettings;
+
+		// Check if its a LAN query
+		if (!SearchSettings->bIsLanQuery)
+		{
+			bool bUssLobbiesIfAvailable = false;
+			if (SearchSettings->QuerySettings.Get(SEARCH_LOBBIES, bUssLobbiesIfAvailable) && bUssLobbiesIfAvailable)
+			{
+				Return = FindLobbySession(SearchingPlayerNum, SearchSettings);
+			}
+			else
+			{
+				Return = FindEOSSession(SearchingPlayerNum, SearchSettings);
+			}
+		}
+		else
+		{
+			Return = FindLANSession();
+		}
+
+		if (Return == ONLINE_IO_PENDING)
+		{
+			SearchSettings->SearchState = EOnlineAsyncTaskState::InProgress;
+		}
+	}
+	else
+	{
+		UE_LOG_ONLINE_SESSION(Warning, TEXT("Ignoring game search request while another search is pending"));
+		Return = ONLINE_IO_PENDING;
+	}
+
+	return Return == ONLINE_SUCCESS || Return == ONLINE_IO_PENDING;
+}
+
+bool FOnlineSessionEOS::FindSessions(const FUniqueNetId& SearchingPlayerId, const TSharedRef<FOnlineSessionSearch>& SearchSettings)
+{
+	// This function doesn't use the SearchingPlayerNum parameter, so passing in anything is fine.
+	return FindSessions(EOSSubsystem->UserManager->GetLocalUserNumFromUniqueNetId(SearchingPlayerId), SearchSettings);
+}
+
+bool FOnlineSessionEOS::FindSessionById(const FUniqueNetId& SearchingUserId, const FUniqueNetId& SessionId, const FUniqueNetId& FriendId, const FOnSingleSessionResultCompleteDelegate& CompletionDelegate)
+{
+	bool bResult = false;
+
+	// We create the search handle
+	EOS_HLobbySearch LobbySearchHandle;
+	EOS_Lobby_CreateLobbySearchOptions CreateLobbySearchOptions = { 0 };
+	CreateLobbySearchOptions.ApiVersion = EOS_LOBBY_CREATELOBBYSEARCH_API_LATEST;
+	CreateLobbySearchOptions.MaxResults = EOS_SESSIONS_MAX_SEARCH_RESULTS;
+
+	EOS_EResult CreateLobbySearchResult = EOS_Lobby_CreateLobbySearch(LobbyHandle, &CreateLobbySearchOptions, &LobbySearchHandle);
+	if (CreateLobbySearchResult == EOS_EResult::EOS_Success)
+	{
+		const FTCHARToUTF8 Utf8LobbyId(*SessionId.ToString());
+		// Set the lobby id we want to use to find lobbies			
+		EOS_LobbySearch_SetLobbyIdOptions SetLobbyIdOptions = { 0 };
+		SetLobbyIdOptions.ApiVersion = EOS_LOBBYSEARCH_SETLOBBYID_API_LATEST;
+		SetLobbyIdOptions.LobbyId = (EOS_LobbyId)Utf8LobbyId.Get();
+
+		EOS_LobbySearch_SetLobbyId(LobbySearchHandle, &SetLobbyIdOptions);
+
+		// Then perform the search
+		CurrentSessionSearch = MakeShareable(new FOnlineSessionSearch());
+		CurrentSessionSearch->SearchState = EOnlineAsyncTaskState::InProgress;
+
+		StartLobbySearch(EOSSubsystem->UserManager->GetLocalUserNumFromUniqueNetId(SearchingUserId), LobbySearchHandle, CurrentSessionSearch.ToSharedRef(),
+			FOnSingleSessionResultCompleteDelegate::CreateLambda([this, OrigCallback = FOnSingleSessionResultCompleteDelegate(CompletionDelegate), SessId = CreateSessionIdFromString(SessionId.ToString())](int32 LocalUserNum, bool bWasSuccessful, const FOnlineSessionSearchResult& EOSResult)
+		{
+			if (bWasSuccessful)
+			{
+				OrigCallback.ExecuteIfBound(LocalUserNum, bWasSuccessful, EOSResult);
+				return;
+			}
+			// Didn't find a lobby so search sessions
+			FindEOSSessionById(LocalUserNum, *SessId, OrigCallback);
+		}));
+
+		bResult = true;
+	}
+	else
+	{
+		UE_LOG_ONLINE_SESSION(Warning, TEXT("[FOnlineSessionEOS::FindSessionById] CreateLobbySearch not successful. Finished with EOS_EResult %s"), ANSI_TO_TCHAR(EOS_EResult_ToString(CreateLobbySearchResult)));
+	}
+
+	return bResult;
+}
+
+void FOnlineSessionEOS::AddSearchAttribute(EOS_HSessionSearch SearchHandle, const EOS_Sessions_AttributeData* Attribute, EOS_EOnlineComparisonOp ComparisonOp)
+{
+	EOS_SessionSearch_SetParameterOptions Options = { };
+	Options.ApiVersion = EOS_SESSIONSEARCH_SETPARAMETER_API_LATEST;
+	Options.Parameter = Attribute;
+	Options.ComparisonOp = ComparisonOp;
+
+	EOS_EResult ResultCode = EOS_SessionSearch_SetParameter(SearchHandle, &Options);
+	if (ResultCode != EOS_EResult::EOS_Success)
+	{
+		UE_LOG_ONLINE_SESSION(Error, TEXT("EOS_SessionSearch_SetParameter() failed with EOS result code (%s)"), ANSI_TO_TCHAR(EOS_EResult_ToString(ResultCode)));
+	}
+}
+
+void FOnlineSessionEOS::AddLobbySearchAttribute(EOS_HLobbySearch LobbySearchHandle, const EOS_Lobby_AttributeData* Attribute, EOS_EOnlineComparisonOp ComparisonOp)
+{
+	EOS_LobbySearch_SetParameterOptions Options = { };
+	Options.ApiVersion = EOS_LOBBYSEARCH_SETPARAMETER_API_LATEST;
+	Options.Parameter = Attribute;
+	Options.ComparisonOp = ComparisonOp;
+
+	EOS_EResult ResultCode = EOS_LobbySearch_SetParameter(LobbySearchHandle, &Options);
+	if (ResultCode != EOS_EResult::EOS_Success)
+	{
+		UE_LOG_ONLINE_SESSION(Error, TEXT("EOS_LobbySearch_SetParameter() failed with EOS result code (%s)"), ANSI_TO_TCHAR(EOS_EResult_ToString(ResultCode)));
+	}
+}
+
+void FOnlineSessionEOS::CopySearchResult(EOS_HSessionDetails SessionHandle, EOS_SessionDetails_Info* SessionInfo, FOnlineSession& OutSession)
+{
+	OutSession.SessionSettings.bAllowJoinInProgress = SessionInfo->Settings->bAllowJoinInProgress == EOS_TRUE;
+	switch (SessionInfo->Settings->PermissionLevel)
+	{
+		case EOS_EOnlineSessionPermissionLevel::EOS_OSPF_InviteOnly:
+		{
+			OutSession.SessionSettings.bAllowInvites = true;
+			OutSession.SessionSettings.bUsesPresence = false;
+			OutSession.SessionSettings.bAllowJoinViaPresence = false;
+			break;
+		}
+		case EOS_EOnlineSessionPermissionLevel::EOS_OSPF_JoinViaPresence:
+		{
+			OutSession.SessionSettings.bAllowInvites = true;
+			OutSession.SessionSettings.bUsesPresence = true;
+			OutSession.SessionSettings.bAllowJoinViaPresence = true;
+			break;
+		}
+		case EOS_EOnlineSessionPermissionLevel::EOS_OSPF_PublicAdvertised:
+		{
+			OutSession.SessionSettings.bAllowInvites = true;
+			OutSession.SessionSettings.bUsesPresence = true;
+			OutSession.SessionSettings.bAllowJoinViaPresence = true;
+			break;
+		}
+	}
+	OutSession.SessionSettings.NumPrivateConnections = SessionInfo->Settings->NumPublicConnections;
+	OutSession.NumOpenPrivateConnections = SessionInfo->NumOpenPublicConnections;
+
+	CopyAttributes(SessionHandle, OutSession);
+}
+
+void FOnlineSessionEOS::CopyAttributes(EOS_HSessionDetails SessionHandle, FOnlineSession& OutSession)
+{
+	EOS_SessionDetails_GetSessionAttributeCountOptions CountOptions = { };
+	CountOptions.ApiVersion = EOS_SESSIONDETAILS_GETSESSIONATTRIBUTECOUNT_API_LATEST;
+	int32 Count = EOS_SessionDetails_GetSessionAttributeCount(SessionHandle, &CountOptions);
+
+	for (int32 Index = 0; Index < Count; Index++)
+	{
+		EOS_SessionDetails_CopySessionAttributeByIndexOptions AttrOptions = { };
+		AttrOptions.ApiVersion = EOS_SESSIONDETAILS_COPYSESSIONATTRIBUTEBYINDEX_API_LATEST;
+		AttrOptions.AttrIndex = Index;
+
+		EOS_SessionDetails_Attribute* Attribute = NULL;
+		EOS_EResult ResultCode = EOS_SessionDetails_CopySessionAttributeByIndex(SessionHandle, &AttrOptions, &Attribute);
+		if (ResultCode == EOS_EResult::EOS_Success)
+		{
+			FString Key = Attribute->Data->Key;
+			if (Key == TEXT("NumPublicConnections"))
+			{
+				// Adjust the public connections based upon this
+				OutSession.SessionSettings.NumPublicConnections = Attribute->Data->Value.AsInt64;
+			}
+			else if (Key == TEXT("NumPrivateConnections"))
+			{
+				// Adjust the private connections based upon this
+				OutSession.SessionSettings.NumPrivateConnections = Attribute->Data->Value.AsInt64;
+			}
+			else if (Key == TEXT("bAntiCheatProtected"))
+			{
+				OutSession.SessionSettings.bAntiCheatProtected = Attribute->Data->Value.AsBool == EOS_TRUE;
+			}
+			else if (Key == TEXT("bUsesStats"))
+			{
+				OutSession.SessionSettings.bUsesStats = Attribute->Data->Value.AsBool == EOS_TRUE;
+			}
+			else if (Key == TEXT("bIsDedicated"))
+			{
+				OutSession.SessionSettings.bIsDedicated = Attribute->Data->Value.AsBool == EOS_TRUE;
+			}
+			else if (Key == TEXT("BuildUniqueId"))
+			{
+				OutSession.SessionSettings.BuildUniqueId = Attribute->Data->Value.AsInt64;
+			}
+			// Handle FOnlineSessionSetting settings
+			else
+			{
+				FOnlineSessionSetting Setting;
+				switch (Attribute->Data->ValueType)
+				{
+					case EOS_ESessionAttributeType::EOS_SAT_Boolean:
+					{
+						Setting.Data.SetValue(Attribute->Data->Value.AsBool == EOS_TRUE);
+						break;
+					}
+					case EOS_ESessionAttributeType::EOS_SAT_Int64:
+					{
+						Setting.Data.SetValue(int64(Attribute->Data->Value.AsInt64));
+						break;
+					}
+					case EOS_ESessionAttributeType::EOS_SAT_Double:
+					{
+						Setting.Data.SetValue(Attribute->Data->Value.AsDouble);
+						break;
+					}
+					case EOS_ESessionAttributeType::EOS_SAT_String:
+					{
+						Setting.Data.SetValue(ANSI_TO_TCHAR(Attribute->Data->Value.AsUtf8));
+						break;
+					}
+				}
+				OutSession.SessionSettings.Settings.Add(FName(Key), Setting);
+			}
+		}
+
+		EOS_SessionDetails_Attribute_Release(Attribute);
+	}
+}
+
+void FOnlineSessionEOS::AddSearchResult(EOS_HSessionDetails SessionHandle, const TSharedRef<FOnlineSessionSearch>& SearchSettings)
+{
+	EOS_SessionDetails_Info* SessionInfo = nullptr;
+	EOS_SessionDetails_CopyInfoOptions CopyOptions = { };
+	CopyOptions.ApiVersion = EOS_SESSIONDETAILS_COPYINFO_API_LATEST;
+	EOS_EResult CopyResult = EOS_SessionDetails_CopyInfo(SessionHandle, &CopyOptions, &SessionInfo);
+	if (CopyResult == EOS_EResult::EOS_Success)
+	{
+		int32 Position = SearchSettings->SearchResults.AddZeroed();
+		FOnlineSessionSearchResult& SearchResult = SearchSettings->SearchResults[Position];
+		// This will set the host address and port
+		SearchResult.Session.SessionInfo = MakeShareable(new FOnlineSessionInfoEOS(SessionInfo->HostAddress, SessionInfo->SessionId, SessionHandle));
+
+		CopySearchResult(SessionHandle, SessionInfo, SearchResult.Session);
+
+		EOS_SessionDetails_Info_Release(SessionInfo);
+	}
+}
+
+typedef TEOSCallback<EOS_SessionSearch_OnFindCallback, EOS_SessionSearch_FindCallbackInfo> FFindSessionsCallback;
+
+uint32 FOnlineSessionEOS::FindEOSSession(int32 SearchingPlayerNum, const TSharedRef<FOnlineSessionSearch>& SearchSettings)
+{
+	EOS_HSessionSearch SearchHandle = nullptr;
+	EOS_Sessions_CreateSessionSearchOptions HandleOptions = { };
+	HandleOptions.ApiVersion = EOS_SESSIONS_CREATESESSIONSEARCH_API_LATEST;
+	HandleOptions.MaxSearchResults = FMath::Clamp(SearchSettings->MaxSearchResults, 0, EOS_SESSIONS_MAX_SEARCH_RESULTS);
+
+	EOS_EResult ResultCode = EOS_Sessions_CreateSessionSearch(EOSSubsystem->SessionsHandle, &HandleOptions, &SearchHandle);
+	if (ResultCode != EOS_EResult::EOS_Success)
+	{
+		UE_LOG_ONLINE_SESSION(Error, TEXT("EOS_Sessions_CreateSessionSearch() failed with EOS result code (%s)"), ANSI_TO_TCHAR(EOS_EResult_ToString(ResultCode)));
+		return ONLINE_FAIL;
+	}
+	// Store our search handle for use/cleanup later
+	CurrentSearchHandle = MakeShareable(new FSessionSearchEOS(SearchHandle));
+
+	FAttributeOptions Opt1("NumPublicConnections", 1);
+	AddSearchAttribute(SearchHandle, &Opt1, EOS_EOnlineComparisonOp::EOS_OCO_GREATERTHANOREQUAL);
+
+	FAttributeOptions Opt2(EOS_SESSIONS_SEARCH_BUCKET_ID, BucketIdAnsi);
+	AddSearchAttribute(SearchHandle, &Opt2, EOS_EOnlineComparisonOp::EOS_OCO_EQUAL);
+
+	// Add the search settings
+	for (FSearchParams::TConstIterator It(SearchSettings->QuerySettings.SearchParams); It; ++It)
+	{
+		const FName Key = It.Key();
+		const FOnlineSessionSearchParam& SearchParam = It.Value();
+
+		if (!IsSessionSettingTypeSupported(SearchParam.Data.GetType()))
+		{
+			continue;
+		}
+
+#if UE_BUILD_DEBUG
+		UE_LOG_ONLINE_SESSION(Log, TEXT("Adding search param named (%s), (%s)"), *Key.ToString(), *SearchParam.ToString());
+#endif
+		FString ParamName(Key.ToString());
+		FAttributeOptions Attribute(TCHAR_TO_UTF8(*ParamName), SearchParam.Data);
+		AddSearchAttribute(SearchHandle, &Attribute, ToEOSSearchOp(SearchParam.ComparisonOp));
+	}
+
+	FFindSessionsCallback* CallbackObj = new FFindSessionsCallback();
+	CallbackObj->CallbackLambda = [this, SearchSettings](const EOS_SessionSearch_FindCallbackInfo* Data)
+	{
+		bool bWasSuccessful = Data->ResultCode == EOS_EResult::EOS_Success;
+		if (bWasSuccessful)
+		{
+			EOS_SessionSearch_GetSearchResultCountOptions SearchResultOptions = { };
+			SearchResultOptions.ApiVersion = EOS_SESSIONSEARCH_GETSEARCHRESULTCOUNT_API_LATEST;
+			int32 NumSearchResults = EOS_SessionSearch_GetSearchResultCount(CurrentSearchHandle->SearchHandle, &SearchResultOptions);
+
+			EOS_SessionSearch_CopySearchResultByIndexOptions IndexOptions = { };
+			IndexOptions.ApiVersion = EOS_SESSIONSEARCH_COPYSEARCHRESULTBYINDEX_API_LATEST;
+			for (int32 Index = 0; Index < NumSearchResults; Index++)
+			{
+				EOS_HSessionDetails SessionHandle = nullptr;
+				IndexOptions.SessionIndex = Index;
+				EOS_EResult Result = EOS_SessionSearch_CopySearchResultByIndex(CurrentSearchHandle->SearchHandle, &IndexOptions, &SessionHandle);
+				if (Result == EOS_EResult::EOS_Success)
+				{
+					AddSearchResult(SessionHandle, SearchSettings);
+				}
+			}
+			SearchSettings->SearchState = EOnlineAsyncTaskState::Done;
+		}
+		else
+		{
+			SearchSettings->SearchState = EOnlineAsyncTaskState::Failed;
+			UE_LOG_ONLINE_SESSION(Error, TEXT("EOS_SessionSearch_Find() failed with EOS result code (%s)"), ANSI_TO_TCHAR(EOS_EResult_ToString(Data->ResultCode)));
+		}
+		TriggerOnFindSessionsCompleteDelegates(bWasSuccessful);
+	};
+
+	SearchSettings->SearchState = EOnlineAsyncTaskState::InProgress;
+
+	// Execute the search
+	EOS_SessionSearch_FindOptions Options = { };
+	Options.ApiVersion = EOS_SESSIONSEARCH_FIND_API_LATEST;
+	Options.LocalUserId = EOSSubsystem->UserManager->GetLocalProductUserId(SearchingPlayerNum);
+	EOS_SessionSearch_Find(SearchHandle, &Options, CallbackObj, CallbackObj->GetCallbackPtr());
+
+	return ONLINE_IO_PENDING;
+}
+
+void FOnlineSessionEOS::FindEOSSessionById(int32 LocalUserNum, const FUniqueNetId& SessionId, const FOnSingleSessionResultCompleteDelegate& CompletionDelegate)
+{
+	EOS_HSessionSearch SearchHandle = nullptr;
+	EOS_Sessions_CreateSessionSearchOptions HandleOptions = { };
+	HandleOptions.ApiVersion = EOS_SESSIONS_CREATESESSIONSEARCH_API_LATEST;
+	HandleOptions.MaxSearchResults = 1;
+
+	EOS_EResult ResultCode = EOS_Sessions_CreateSessionSearch(EOSSubsystem->SessionsHandle, &HandleOptions, &SearchHandle);
+	if (ResultCode != EOS_EResult::EOS_Success)
+	{
+		UE_LOG_ONLINE_SESSION(Warning, TEXT("EOS_Sessions_CreateSessionSearch() failed with EOS result code (%s)"), ANSI_TO_TCHAR(EOS_EResult_ToString(ResultCode)));
+		CompletionDelegate.ExecuteIfBound(LocalUserNum, false, FOnlineSessionSearchResult());
+		return;
+	}
+
+	const FTCHARToUTF8 Utf8SessionId(*SessionId.ToString());
+	EOS_SessionSearch_SetSessionIdOptions Options = { };
+	Options.ApiVersion = EOS_SESSIONSEARCH_SETSESSIONID_API_LATEST;
+	Options.SessionId = Utf8SessionId.Get();
+	ResultCode = EOS_SessionSearch_SetSessionId(SearchHandle, &Options);
+	if (ResultCode != EOS_EResult::EOS_Success)
+	{
+		UE_LOG_ONLINE_SESSION(Warning, TEXT("EOS_SessionSearch_SetSessionId() failed with EOS result code (%s)"), ANSI_TO_TCHAR(EOS_EResult_ToString(ResultCode)));
+		CompletionDelegate.ExecuteIfBound(LocalUserNum, false, FOnlineSessionSearchResult());
+		return;
+	}
+
+	// Store our search handle for use/cleanup later
+	CurrentSearchHandle = MakeShareable(new FSessionSearchEOS(SearchHandle));
+
+	FFindSessionsCallback* CallbackObj = new FFindSessionsCallback();
+	CallbackObj->CallbackLambda = [this, LocalUserNum, OnComplete = FOnSingleSessionResultCompleteDelegate(CompletionDelegate)](const EOS_SessionSearch_FindCallbackInfo* Data)
+	{
+		TSharedRef<FOnlineSessionSearch> LocalSessionSearch = MakeShareable(new FOnlineSessionSearch());
+		LocalSessionSearch->SearchState = EOnlineAsyncTaskState::InProgress;
+
+		bool bWasSuccessful = Data->ResultCode == EOS_EResult::EOS_Success;
+		if (bWasSuccessful)
+		{
+			EOS_SessionSearch_GetSearchResultCountOptions SearchResultOptions = { };
+			SearchResultOptions.ApiVersion = EOS_SESSIONSEARCH_GETSEARCHRESULTCOUNT_API_LATEST;
+			int32 NumSearchResults = EOS_SessionSearch_GetSearchResultCount(CurrentSearchHandle->SearchHandle, &SearchResultOptions);
+
+			EOS_SessionSearch_CopySearchResultByIndexOptions IndexOptions = { };
+			IndexOptions.ApiVersion = EOS_SESSIONSEARCH_COPYSEARCHRESULTBYINDEX_API_LATEST;
+			for (int32 Index = 0; Index < NumSearchResults; Index++)
+			{
+				EOS_HSessionDetails SessionHandle = nullptr;
+				IndexOptions.SessionIndex = Index;
+				EOS_EResult Result = EOS_SessionSearch_CopySearchResultByIndex(CurrentSearchHandle->SearchHandle, &IndexOptions, &SessionHandle);
+				if (Result == EOS_EResult::EOS_Success)
+				{
+					AddSearchResult(SessionHandle, LocalSessionSearch);
+				}
+			}
+			LocalSessionSearch->SearchState = EOnlineAsyncTaskState::Done;
+		}
+		else
+		{
+			LocalSessionSearch->SearchState = EOnlineAsyncTaskState::Failed;
+			UE_LOG_ONLINE_SESSION(Error, TEXT("EOS_SessionSearch_Find() failed with EOS result code (%s)"), ANSI_TO_TCHAR(EOS_EResult_ToString(Data->ResultCode)));
+		}
+		OnComplete.ExecuteIfBound(LocalUserNum, LocalSessionSearch->SearchState == EOnlineAsyncTaskState::Done, LocalSessionSearch->SearchResults.Last());
+	};
+
+	EOS_SessionSearch_FindOptions FindOptions = { };
+	FindOptions.ApiVersion = EOS_SESSIONSEARCH_FIND_API_LATEST;
+	FindOptions.LocalUserId = EOSSubsystem->UserManager->GetLocalProductUserId(LocalUserNum);
+
+	EOS_SessionSearch_Find(SearchHandle, &FindOptions, CallbackObj, CallbackObj->GetCallbackPtr());
+}
+
+uint32 FOnlineSessionEOS::FindLANSession()
+{
+	uint32 Return = ONLINE_FAIL;
+
+	if (!LANSession.IsValid())
+	{
+		LANSession = MakeShareable(new FLANSession());
+	}
+
+	// Recreate the unique identifier for this client
+	GenerateNonce((uint8*)&LANSession->LanNonce, 8);
+
+	FOnValidResponsePacketDelegate ResponseDelegate = FOnValidResponsePacketDelegate::CreateRaw(this, &FOnlineSessionEOS::OnValidResponsePacketReceived);
+	FOnSearchingTimeoutDelegate TimeoutDelegate = FOnSearchingTimeoutDelegate::CreateRaw(this, &FOnlineSessionEOS::OnLANSearchTimeout);
+
+	FNboSerializeToBufferEOS Packet(LAN_BEACON_MAX_PACKET_SIZE);
+	LANSession->CreateClientQueryPacket(Packet, LANSession->LanNonce);
+	if (LANSession->Search(Packet, ResponseDelegate, TimeoutDelegate))
+	{
+		Return = ONLINE_IO_PENDING;
+	}
+
+	if (Return == ONLINE_FAIL)
+	{
+		EOSSubsystem->ExecuteNextTick([this]()
+			{
+				CurrentSessionSearch->SearchState = EOnlineAsyncTaskState::Failed;
+
+				// Just trigger the delegate as having failed
+				TriggerOnFindSessionsCompleteDelegates(false);
+			});
+	}
+
+	return Return;
+}
+
+bool FOnlineSessionEOS::CancelFindSessions()
+{
+	uint32 Return = ONLINE_FAIL;
+	if (CurrentSessionSearch.IsValid() && CurrentSessionSearch->SearchState == EOnlineAsyncTaskState::InProgress)
+	{
+		// Make sure it's the right type
+		if (CurrentSessionSearch->bIsLanQuery)
+		{
+			check(LANSession);
+			Return = ONLINE_SUCCESS;
+			LANSession->StopLANSession();
+			CurrentSessionSearch->SearchState = EOnlineAsyncTaskState::Failed;
+			CurrentSessionSearch = nullptr;
+		}
+		else
+		{
+			Return = ONLINE_SUCCESS;
+			// NULLing out the object will prevent the async event from adding the results
+			CurrentSessionSearch->SearchState = EOnlineAsyncTaskState::Failed;
+			CurrentSessionSearch = nullptr;
+		}
+	}
+	else
+	{
+		UE_LOG_ONLINE_SESSION(Warning, TEXT("Can't cancel a search that isn't in progress"));
+	}
+
+	if (Return != ONLINE_IO_PENDING)
+	{
+		EOSSubsystem->ExecuteNextTick([this]()
+			{
+				TriggerOnCancelFindSessionsCompleteDelegates(true);
+			});
+	}
+
+	return true;
+}
+
+bool FOnlineSessionEOS::JoinSession(int32 PlayerNum, FName SessionName, const FOnlineSessionSearchResult& DesiredSession)
+{
+	uint32 Return = ONLINE_FAIL;
+	FNamedOnlineSession* Session = GetNamedSession(SessionName);
+	// Don't join a session if already in one or hosting one
+	if (Session == nullptr)
+	{
+		// Create a named session from the search result data
+		Session = AddNamedSession(SessionName, DesiredSession.Session);
+		Session->HostingPlayerNum = PlayerNum;
+
+		// Create Internet or LAN match
+		if (!Session->SessionSettings.bIsLANMatch)
+		{
+			if (DesiredSession.Session.SessionInfo.IsValid())
+			{
+				TSharedPtr<const FOnlineSessionInfoEOS> SearchSessionInfo = StaticCastSharedPtr<const FOnlineSessionInfoEOS>(DesiredSession.Session.SessionInfo);
+
+				FOnlineSessionInfoEOS* NewSessionInfo = new FOnlineSessionInfoEOS(*SearchSessionInfo);
+				Session->SessionInfo = MakeShareable(NewSessionInfo);
+
+				if (DesiredSession.Session.SessionSettings.bUseLobbiesIfAvailable)
+				{
+					Return = JoinLobbySession(PlayerNum, Session, &DesiredSession.Session);
+				}
+				else
+				{
+					Return = JoinEOSSession(PlayerNum, Session, &DesiredSession.Session);
+				}
+			}
+			else
+			{
+				UE_LOG_ONLINE_SESSION(Warning, TEXT("Invalid session info on search result"), *SessionName.ToString());
+			}
+		}
+		else
+		{
+			FOnlineSessionInfoEOS* NewSessionInfo = new FOnlineSessionInfoEOS();
+			Session->SessionInfo = MakeShareable(NewSessionInfo);
+
+			Return = JoinLANSession(PlayerNum, Session, &DesiredSession.Session);
+		}
+
+		if (Return != ONLINE_IO_PENDING)
+		{
+			if (Return != ONLINE_SUCCESS)
+			{
+				// Clean up the session info so we don't get into a confused state
+				RemoveNamedSession(SessionName);
+			}
+			else
+			{
+				RegisterLocalPlayers(Session);
+			}
+		}
+	}
+	else
+	{
+		UE_LOG_ONLINE_SESSION(Warning, TEXT("Session (%s) already exists, can't join twice"), *SessionName.ToString());
+	}
+
+	if (Return != ONLINE_IO_PENDING)
+	{
+		EOSSubsystem->ExecuteNextTick([this, SessionName, Return]()
+			{
+				// Just trigger the delegate as having failed
+				TriggerOnJoinSessionCompleteDelegates(SessionName, Return == ONLINE_SUCCESS ? EOnJoinSessionCompleteResult::Success : EOnJoinSessionCompleteResult::UnknownError);
+			});
+	}
+
+	return true;
+}
+
+bool FOnlineSessionEOS::JoinSession(const FUniqueNetId& SearchingUserId, FName SessionName, const FOnlineSessionSearchResult& DesiredSession)
+{
+	return JoinSession(EOSSubsystem->UserManager->GetLocalUserNumFromUniqueNetId(SearchingUserId), SessionName, DesiredSession);
+}
+
+struct FJoinSessionOptions :
+	public TNamedSessionOptions<EOS_Sessions_JoinSessionOptions>
+{
+	FJoinSessionOptions(const char* InSessionNameAnsi) :
+		TNamedSessionOptions<EOS_Sessions_JoinSessionOptions>(InSessionNameAnsi)
+	{
+		ApiVersion = EOS_SESSIONS_JOINSESSION_API_LATEST;
+	}
+};
+
+typedef TEOSCallback<EOS_Sessions_OnJoinSessionCallback, EOS_Sessions_JoinSessionCallbackInfo> FJoinSessionCallback;
+
+uint32 FOnlineSessionEOS::JoinEOSSession(int32 PlayerNum, FNamedOnlineSession* Session, const FOnlineSession* SearchSession)
+{
+	if (!Session->SessionInfo.IsValid())
+	{
+		UE_LOG_ONLINE_SESSION(Error, TEXT("Session (%s) has invalid session info"), *Session->SessionName.ToString());
+		return ONLINE_FAIL;
+	}
+	EOS_ProductUserId ProductUserId = EOSSubsystem->UserManager->GetLocalProductUserId(PlayerNum);
+	if (ProductUserId == nullptr)
+	{
+		UE_LOG_ONLINE_SESSION(Error, TEXT("Session (%s) invalid user id (%d)"), *Session->SessionName.ToString(), PlayerNum);
+		return ONLINE_FAIL;
+	}
+	TSharedPtr<FOnlineSessionInfoEOS> EOSSessionInfo = StaticCastSharedPtr<FOnlineSessionInfoEOS>(Session->SessionInfo);
+	if (!EOSSessionInfo->SessionId->IsValid())
+	{
+		UE_LOG_ONLINE_SESSION(Error, TEXT("Session (%s) has invalid session id"), *Session->SessionName.ToString());
+		return ONLINE_FAIL;
+	}
+
+	// Copy the session info over
+	TSharedPtr<const FOnlineSessionInfoEOS> SearchSessionInfo = StaticCastSharedPtr<const FOnlineSessionInfoEOS>(SearchSession->SessionInfo);
+	EOSSessionInfo->HostAddr = SearchSessionInfo->HostAddr->Clone();
+
+	Session->SessionState = EOnlineSessionState::Pending;
+
+	FName SessionName = Session->SessionName;
+
+	FJoinSessionCallback* CallbackObj = new FJoinSessionCallback();
+	CallbackObj->CallbackLambda = [this, SessionName](const EOS_Sessions_JoinSessionCallbackInfo* Data)
+	{
+		bool bWasSuccessful = false;
+
+		FNamedOnlineSession* Session = GetNamedSession(SessionName);
+		if (Session)
+		{
+			bWasSuccessful = Data->ResultCode == EOS_EResult::EOS_Success;
+			if (bWasSuccessful)
+			{
+				BeginSessionAnalytics(Session);
+			}
+			else
+			{
+				UE_LOG_ONLINE_SESSION(Error, TEXT("EOS_Sessions_JoinSession() failed for session (%s) with EOS result code (%s)"), *SessionName.ToString(), ANSI_TO_TCHAR(EOS_EResult_ToString(Data->ResultCode)));
+
+				Session->SessionState = EOnlineSessionState::NoSession;
+
+				RemoveNamedSession(SessionName);
+			}
+		}
+
+		TriggerOnJoinSessionCompleteDelegates(SessionName, bWasSuccessful ? EOnJoinSessionCompleteResult::Success : EOnJoinSessionCompleteResult::UnknownError);
+	};
+
+	FJoinSessionOptions Options(TCHAR_TO_UTF8(*Session->SessionName.ToString()));
+	Options.LocalUserId = ProductUserId;
+	Options.SessionHandle = EOSSessionInfo->SessionHandle;
+	EOS_Sessions_JoinSession(EOSSubsystem->SessionsHandle, &Options, CallbackObj, CallbackObj->GetCallbackPtr());
+
+	return ONLINE_IO_PENDING;
+}
+
+uint32 FOnlineSessionEOS::JoinLANSession(int32 PlayerNum, FNamedOnlineSession* Session, const FOnlineSession* SearchSession)
+{
+	uint32 Result = ONLINE_FAIL;
+	Session->SessionState = EOnlineSessionState::Pending;
+
+	if (Session->SessionInfo.IsValid())
+	{
+		// Copy the session info over
+		TSharedPtr<const FOnlineSessionInfoEOS> SearchSessionInfo = StaticCastSharedPtr<const FOnlineSessionInfoEOS>(SearchSession->SessionInfo);
+		TSharedPtr<FOnlineSessionInfoEOS> SessionInfo = StaticCastSharedPtr<FOnlineSessionInfoEOS>(Session->SessionInfo);
+		SessionInfo->HostAddr = SearchSessionInfo->HostAddr->Clone();
+		Result = ONLINE_SUCCESS;
+	}
+	else
+	{
+		UE_LOG_ONLINE_SESSION(Warning, TEXT("Session (%s) has invalid session info"), *Session->SessionName.ToString());
+	}
+
+	return Result;
+}
+
+bool FOnlineSessionEOS::FindFriendSession(int32 LocalUserNum, const FUniqueNetId& Friend)
+{
+	bool bResult = false;
+
+	// So far there is only a lobby implementation for this
+
+	// We create the search handle
+	EOS_HLobbySearch LobbySearchHandle;
+	EOS_Lobby_CreateLobbySearchOptions CreateLobbySearchOptions = { 0 };
+	CreateLobbySearchOptions.ApiVersion = EOS_LOBBY_CREATELOBBYSEARCH_API_LATEST;
+	CreateLobbySearchOptions.MaxResults = EOS_SESSIONS_MAX_SEARCH_RESULTS;
+
+	EOS_EResult CreateLobbySearchResult = EOS_Lobby_CreateLobbySearch(LobbyHandle, &CreateLobbySearchOptions, &LobbySearchHandle);
+	if (CreateLobbySearchResult == EOS_EResult::EOS_Success)
+	{
+		// Set the user we wan to use to find lobbies
+		EOS_LobbySearch_SetTargetUserIdOptions SetTargetUserIdOptions = { 0 };
+		SetTargetUserIdOptions.ApiVersion = EOS_LOBBYSEARCH_SETTARGETUSERID_API_LATEST;
+		SetTargetUserIdOptions.TargetUserId = EOSSubsystem->UserManager->GetProductUserId(Friend);
+
+		// TODO: Using this as a search parameter only works if we use the owner's id (search for lobbies we're already in). Pending API fix so it works with other users too.
+		EOS_LobbySearch_SetTargetUserId(LobbySearchHandle, &SetTargetUserIdOptions);
+
+		// Then perform the search
+		CurrentSessionSearch = MakeShareable(new FOnlineSessionSearch());
+		CurrentSessionSearch->SearchState = EOnlineAsyncTaskState::InProgress;
+
+		StartLobbySearch(LocalUserNum, LobbySearchHandle, CurrentSessionSearch.ToSharedRef(), FOnSingleSessionResultCompleteDelegate::CreateLambda([this](int32 LocalUserNum, bool bWasSuccessful, const FOnlineSessionSearchResult& EOSResult)
+		{
+			TriggerOnFindSessionsCompleteDelegates(bWasSuccessful);
+		}));
+
+		bResult = true;
+	}
+	else
+	{
+		UE_LOG_ONLINE_SESSION(Warning, TEXT("[FOnlineSessionEOS::FindFriendSession] CreateLobbySearch not successful. Finished with EOS_EResult %s"), ANSI_TO_TCHAR(EOS_EResult_ToString(CreateLobbySearchResult)));
+		EOSSubsystem->ExecuteNextTick([this]()
+		{
+			TriggerOnFindSessionsCompleteDelegates(false);
+		});
+	}
+
+	return bResult;
+};
+
+bool FOnlineSessionEOS::FindFriendSession(const FUniqueNetId& LocalUserId, const FUniqueNetId& Friend)
+{
+	return FindFriendSession(EOSSubsystem->UserManager->GetLocalUserNumFromUniqueNetId(LocalUserId), Friend);
+}
+
+bool FOnlineSessionEOS::FindFriendSession(const FUniqueNetId& LocalUserId, const TArray<FUniqueNetIdRef>& FriendList)
+{
+	EOSSubsystem->ExecuteNextTick([this, LocalUserIdRef = LocalUserId.AsShared()]()
+		{
+			// this function has to exist due to interface definition, but it does not have a meaningful implementation in EOS subsystem yet
+			TArray<FOnlineSessionSearchResult> EmptySearchResult;
+			TriggerOnFindFriendSessionCompleteDelegates(EOSSubsystem->UserManager->GetLocalUserNumFromUniqueNetId(*LocalUserIdRef), false, EmptySearchResult);
+		});
+
+	return true;
+}
+
+struct FSendSessionInviteOptions :
+	public TNamedSessionOptions<EOS_Sessions_SendInviteOptions>
+{
+	FSendSessionInviteOptions(const char* InSessionNameAnsi) :
+		TNamedSessionOptions<EOS_Sessions_SendInviteOptions>(InSessionNameAnsi)
+	{
+		ApiVersion = EOS_SESSIONS_SENDINVITE_API_LATEST;
+	}
+};
+
+typedef TEOSCallback<EOS_Sessions_OnSendInviteCallback, EOS_Sessions_SendInviteCallbackInfo> FSendSessionInviteCallback;
+
+bool FOnlineSessionEOS::SendSessionInvite(FName SessionName, EOS_ProductUserId SenderId, EOS_ProductUserId ReceiverId)
+{
+	bool bResult = false;
+
+	FNamedOnlineSession* Session = GetNamedSession(SessionName);
+	if (Session != nullptr)
+	{
+		if (Session->SessionSettings.bUseLobbiesIfAvailable)
+		{
+			bResult = SendLobbyInvite(SessionName, SenderId, ReceiverId);
+		}
+		else
+		{
+			bResult = SendEOSSessionInvite(SessionName, SenderId, ReceiverId);
+		}
+	}
+	else
+	{
+		UE_LOG_ONLINE_SESSION(Warning, TEXT("[FOnlineSessionEOS::SendSessionInvite] Session with name %s not valid"), *SessionName.ToString());
+	}
+
+	return bResult;
+}
+
+bool FOnlineSessionEOS::SendLobbyInvite(FName SessionName, EOS_ProductUserId SenderId, EOS_ProductUserId ReceiverId)
+{
+	EOS_Lobby_SendInviteOptions SendInviteOptions = { 0 };
+	SendInviteOptions.ApiVersion = EOS_LOBBY_SENDINVITE_API_LATEST;
+	const FTCHARToUTF8 Utf8LobbyId(*GetNamedSession(SessionName)->SessionInfo->GetSessionId().ToString());
+	SendInviteOptions.LobbyId = (EOS_LobbyId)Utf8LobbyId.Get();
+	SendInviteOptions.LocalUserId = SenderId;
+	SendInviteOptions.TargetUserId = ReceiverId;
+	
+	FLobbySendInviteCallback* CallbackObj = new FLobbySendInviteCallback();
+	LobbySendInviteCallback = CallbackObj;
+	CallbackObj->CallbackLambda = [this](const EOS_Lobby_SendInviteCallbackInfo* Data)
+	{
+		if (Data->ResultCode == EOS_EResult::EOS_Success)
+		{
+			UE_LOG_ONLINE_SESSION(Log, TEXT("[FOnlineSessionEOS::SendLobbyInvite] SendInvite was successful."));
+		}
+		else
+		{
+			UE_LOG_ONLINE_SESSION(Warning, TEXT("[FOnlineSessionEOS::SendLobbyInvite] SendInvite not successful. Finished with EOS_EResult %s"), ANSI_TO_TCHAR(EOS_EResult_ToString(Data->ResultCode)));
+		}
+	};
+
+	EOS_Lobby_SendInvite(LobbyHandle, &SendInviteOptions, CallbackObj, CallbackObj->GetCallbackPtr());
+
+	return true;
+}
+
+bool FOnlineSessionEOS::SendEOSSessionInvite(FName SessionName, EOS_ProductUserId SenderId, EOS_ProductUserId ReceiverId)
+{
+	FSendSessionInviteOptions Options(TCHAR_TO_UTF8(*SessionName.ToString()));
+	Options.LocalUserId = SenderId;
+	Options.TargetUserId = ReceiverId;
+
+	FSendSessionInviteCallback* CallbackObj = new FSendSessionInviteCallback();
+	CallbackObj->CallbackLambda = [this, SessionName](const EOS_Sessions_SendInviteCallbackInfo* Data)
+	{
+		bool bWasSuccessful = Data->ResultCode == EOS_EResult::EOS_Success;
+		if (!bWasSuccessful)
+		{
+			UE_LOG_ONLINE_SESSION(Error, TEXT("SendSessionInvite() failed for session (%s) with EOS result code (%s)"), *SessionName.ToString(), ANSI_TO_TCHAR(EOS_EResult_ToString(Data->ResultCode)));
+		}
+	};
+
+	EOS_Sessions_SendInvite(EOSSubsystem->SessionsHandle, &Options, CallbackObj, CallbackObj->GetCallbackPtr());
+	
+	return true;
+}
+
+bool FOnlineSessionEOS::SendSessionInviteToFriend(int32 LocalUserNum, FName SessionName, const FUniqueNetId& Friend)
+{
+	EOS_ProductUserId LocalUserId = EOSSubsystem->UserManager->GetLocalProductUserId(LocalUserNum);
+	if (LocalUserId == nullptr)
+	{
+		UE_LOG_ONLINE_SESSION(Error, TEXT("SendSessionInviteToFriend() failed due to user (%d) being not logged in"), (int32)LocalUserNum);
+		return false;
+	}
+	EOS_ProductUserId TargetUserId = EOSSubsystem->UserManager->GetProductUserId(Friend);
+	if (TargetUserId == nullptr)
+	{
+		UE_LOG_ONLINE_SESSION(Error, TEXT("SendSessionInviteToFriend() failed due to target user (%s) having not played this game"), *Friend.ToDebugString());
+		return false;
+	}
+
+	return SendSessionInvite(SessionName, LocalUserId, TargetUserId);
+};
+
+bool FOnlineSessionEOS::SendSessionInviteToFriend(const FUniqueNetId& LocalNetId, FName SessionName, const FUniqueNetId& Friend)
+{
+	EOS_ProductUserId LocalUserId = EOSSubsystem->UserManager->GetProductUserId(LocalNetId);
+	if (LocalUserId == nullptr)
+	{
+		UE_LOG_ONLINE_SESSION(Error, TEXT("SendSessionInviteToFriend() failed due to user (%s) being not logged in"), *LocalNetId.ToDebugString());
+		return false;
+	}
+	EOS_ProductUserId TargetUserId = EOSSubsystem->UserManager->GetProductUserId(Friend);
+	if (TargetUserId == nullptr)
+	{
+		UE_LOG_ONLINE_SESSION(Error, TEXT("SendSessionInviteToFriend() failed due to target user (%s) having not played this game"), *Friend.ToDebugString());
+		return false;
+	}
+
+	return SendSessionInvite(SessionName, LocalUserId, TargetUserId);
+}
+
+bool FOnlineSessionEOS::SendSessionInviteToFriends(int32 LocalUserNum, FName SessionName, const TArray< FUniqueNetIdRef >& Friends)
+{
+	for (const FUniqueNetIdRef& NetId : Friends)
+	{
+		if (SendSessionInviteToFriend(LocalUserNum, SessionName, *NetId) == false)
+		{
+			return false;
+		}
+	}
+	return true;
+};
+
+bool FOnlineSessionEOS::SendSessionInviteToFriends(const FUniqueNetId& LocalUserId, FName SessionName, const TArray< FUniqueNetIdRef >& Friends)
+{
+	for (const FUniqueNetIdRef& NetId : Friends)
+	{
+		if (SendSessionInviteToFriend(LocalUserId, SessionName, *NetId) == false)
+		{
+			return false;
+		}
+	}
+	return true;
+}
+
+bool FOnlineSessionEOS::PingSearchResults(const FOnlineSessionSearchResult& SearchResult)
+{
+	return false;
+}
+
+/** Get a resolved connection string from a session info */
+static bool GetConnectStringFromSessionInfo(TSharedPtr<FOnlineSessionInfoEOS>& SessionInfo, FString& ConnectInfo, int32 PortOverride=0)
+{
+	if (!SessionInfo.IsValid() || !SessionInfo->HostAddr.IsValid())
+	{
+		return false;
+	}
+
+	if (PortOverride != 0)
+	{
+		ConnectInfo = FString::Printf(TEXT("%s:%d"), *SessionInfo->HostAddr->ToString(false), PortOverride);
+	}
+	else if (SessionInfo->EOSAddress.Len() > 0)
+	{
+		ConnectInfo = SessionInfo->EOSAddress;
+	}
+	else
+	{
+		ConnectInfo = SessionInfo->HostAddr->ToString(true);
+	}
+
+	return true;
+}
+
+bool FOnlineSessionEOS::GetResolvedConnectString(FName SessionName, FString& ConnectInfo, FName PortType)
+{
+	bool bSuccess = false;
+	// Find the session
+	FNamedOnlineSession* Session = GetNamedSession(SessionName);
+	if (Session != nullptr)
+	{
+		TSharedPtr<FOnlineSessionInfoEOS> SessionInfo = StaticCastSharedPtr<FOnlineSessionInfoEOS>(Session->SessionInfo);
+		if (PortType == NAME_BeaconPort)
+		{
+			int32 BeaconListenPort = GetBeaconPortFromSessionSettings(Session->SessionSettings);
+			bSuccess = GetConnectStringFromSessionInfo(SessionInfo, ConnectInfo, BeaconListenPort);
+		}
+		else if (PortType == NAME_GamePort)
+		{
+			bSuccess = GetConnectStringFromSessionInfo(SessionInfo, ConnectInfo);
+		}
+
+		if (!bSuccess)
+		{
+			UE_LOG_ONLINE_SESSION(Warning, TEXT("Invalid session info for session %s in GetResolvedConnectString()"), *SessionName.ToString());
+		}
+	}
+	else
+	{
+		UE_LOG_ONLINE_SESSION(Warning,
+			TEXT("Unknown session name (%s) specified to GetResolvedConnectString()"),
+			*SessionName.ToString());
+	}
+
+	return bSuccess;
+}
+
+bool FOnlineSessionEOS::GetResolvedConnectString(const FOnlineSessionSearchResult& SearchResult, FName PortType, FString& ConnectInfo)
+{
+	bool bSuccess = false;
+	if (SearchResult.Session.SessionInfo.IsValid())
+	{
+		TSharedPtr<FOnlineSessionInfoEOS> SessionInfo = StaticCastSharedPtr<FOnlineSessionInfoEOS>(SearchResult.Session.SessionInfo);
+
+		if (PortType == NAME_BeaconPort)
+		{
+			int32 BeaconListenPort = GetBeaconPortFromSessionSettings(SearchResult.Session.SessionSettings);
+			bSuccess = GetConnectStringFromSessionInfo(SessionInfo, ConnectInfo, BeaconListenPort);
+
+		}
+		else if (PortType == NAME_GamePort)
+		{
+			bSuccess = GetConnectStringFromSessionInfo(SessionInfo, ConnectInfo);
+		}
+	}
+	
+	if (!bSuccess || ConnectInfo.IsEmpty())
+	{
+		UE_LOG_ONLINE_SESSION(Warning, TEXT("Invalid session info in search result to GetResolvedConnectString()"));
+	}
+
+	return bSuccess;
+}
+
+FOnlineSessionSettings* FOnlineSessionEOS::GetSessionSettings(FName SessionName) 
+{
+	FNamedOnlineSession* Session = GetNamedSession(SessionName);
+	if (Session)
+	{
+		return &Session->SessionSettings;
+	}
+	return nullptr;
+}
+
+void FOnlineSessionEOS::RegisterLocalPlayers(FNamedOnlineSession* Session)
+{
+
+}
+
+bool FOnlineSessionEOS::RegisterPlayer(FName SessionName, const FUniqueNetId& PlayerId, bool bWasInvited)
+{
+	TArray< FUniqueNetIdRef > Players;
+	Players.Add(PlayerId.AsShared());
+	return RegisterPlayers(SessionName, Players, bWasInvited);
+}
+
+typedef TEOSCallback<EOS_Sessions_OnRegisterPlayersCallback, EOS_Sessions_RegisterPlayersCallbackInfo> FRegisterPlayersCallback;
+
+bool FOnlineSessionEOS::RegisterPlayers(FName SessionName, const TArray< FUniqueNetIdRef >& Players, bool bWasInvited)
+{
+	bool bSuccess = false;
+	FNamedOnlineSession* Session = GetNamedSession(SessionName);
+	if (Session)
+	{
+		TArray<EOS_ProductUserId> EOSIds;
+		bSuccess = true;
+		bool bRegisterEOS = !Session->SessionSettings.bUseLobbiesIfAvailable;
+
+		for (int32 PlayerIdx=0; PlayerIdx<Players.Num(); PlayerIdx++)
+		{
+			const FUniqueNetIdRef& PlayerId = Players[PlayerIdx];
+
+			FUniqueNetIdMatcher PlayerMatch(*PlayerId);
+			if (Session->RegisteredPlayers.IndexOfByPredicate(PlayerMatch) == INDEX_NONE)
+			{
+				Session->RegisteredPlayers.Add(PlayerId);
+				if (bRegisterEOS)
+				{
+					EOSIds.Add(EOSSubsystem->UserManager->GetProductUserId(*PlayerId));
+				}
+
+				// update number of open connections
+				if (Session->NumOpenPublicConnections > 0)
+				{
+					Session->NumOpenPublicConnections--;
+				}
+				else if (Session->NumOpenPrivateConnections > 0)
+				{
+					Session->NumOpenPrivateConnections--;
+				}
+
+				if (!Session->SessionSettings.MemberSettings.Contains(PlayerId))
+				{
+					Session->SessionSettings.MemberSettings.Add(PlayerId, FSessionSettings());
+				}
+			}
+			else
+			{
+				UE_LOG_ONLINE_SESSION(Log, TEXT("Player %s already registered in session %s"), *PlayerId->ToDebugString(), *SessionName.ToString());
+			}
+		}
+		if (bRegisterEOS && EOSIds.Num() > 0)
+		{
+			EOS_Sessions_RegisterPlayersOptions Options = { };
+			Options.ApiVersion = EOS_SESSIONS_REGISTERPLAYERS_API_LATEST;
+			Options.PlayersToRegister = EOSIds.GetData();
+			Options.PlayersToRegisterCount = EOSIds.Num();
+			const FTCHARToUTF8 Utf8SessionName(*SessionName.ToString());
+			Options.SessionName = Utf8SessionName.Get();
+
+			FRegisterPlayersCallback* CallbackObj = new FRegisterPlayersCallback();
+			CallbackObj->CallbackLambda = [this, SessionName, RegisteredPlayers = TArray<FUniqueNetIdRef>(Players)](const EOS_Sessions_RegisterPlayersCallbackInfo* Data)
+			{
+				bool bWasSuccessful = Data->ResultCode == EOS_EResult::EOS_Success || Data->ResultCode == EOS_EResult::EOS_NoChange;
+				TriggerOnRegisterPlayersCompleteDelegates(SessionName, RegisteredPlayers, bWasSuccessful);
+			};
+			EOS_Sessions_RegisterPlayers(EOSSubsystem->SessionsHandle, &Options, CallbackObj, CallbackObj->GetCallbackPtr());
+			return true;
+		}
+	}
+	else
+	{
+		UE_LOG_ONLINE_SESSION(Warning, TEXT("No game present to join for session (%s)"), *SessionName.ToString());
+	}
+
+	EOSSubsystem->ExecuteNextTick([this, SessionName, RegisteredPlayers = TArray<FUniqueNetIdRef>(Players), bSuccess]()
+	{
+		TriggerOnRegisterPlayersCompleteDelegates(SessionName, RegisteredPlayers, bSuccess);
+	});
+
+	return true;
+}
+
+bool FOnlineSessionEOS::UnregisterPlayer(FName SessionName, const FUniqueNetId& PlayerId)
+{
+	TArray< FUniqueNetIdRef > Players;
+	Players.Add(PlayerId.AsShared());
+	return UnregisterPlayers(SessionName, Players);
+}
+
+typedef TEOSCallback<EOS_Sessions_OnUnregisterPlayersCallback, EOS_Sessions_UnregisterPlayersCallbackInfo> FUnregisterPlayersCallback;
+
+bool FOnlineSessionEOS::UnregisterPlayers(FName SessionName, const TArray< FUniqueNetIdRef >& Players)
+{
+	bool bSuccess = true;
+
+	FNamedOnlineSession* Session = GetNamedSession(SessionName);
+	if (Session)
+	{
+		TArray<EOS_ProductUserId> EOSIds;
+		bool bUnregisterEOS = !Session->SessionSettings.bUseLobbiesIfAvailable;
+		for (int32 PlayerIdx=0; PlayerIdx < Players.Num(); PlayerIdx++)
+		{
+			const FUniqueNetIdRef& PlayerId = Players[PlayerIdx];
+
+			FUniqueNetIdMatcher PlayerMatch(*PlayerId);
+			int32 RegistrantIndex = Session->RegisteredPlayers.IndexOfByPredicate(PlayerMatch);
+			if (RegistrantIndex != INDEX_NONE)
+			{
+				Session->RegisteredPlayers.RemoveAtSwap(RegistrantIndex);
+				if (bUnregisterEOS)
+				{
+					EOSIds.Add(EOSSubsystem->UserManager->GetProductUserId(*PlayerId));
+				}
+
+				// update number of open connections
+				if (Session->NumOpenPublicConnections < Session->SessionSettings.NumPublicConnections)
+				{
+					Session->NumOpenPublicConnections++;
+				}
+				else if (Session->NumOpenPrivateConnections < Session->SessionSettings.NumPrivateConnections)
+				{
+					Session->NumOpenPrivateConnections++;
+				}
+
+				if (Session->SessionSettings.MemberSettings.Contains(PlayerId))
+				{
+					Session->SessionSettings.MemberSettings.Remove(PlayerId);
+				}
+			}
+			else
+			{
+				UE_LOG_ONLINE_SESSION(Warning, TEXT("Player %s is not part of session (%s)"), *PlayerId->ToDebugString(), *SessionName.ToString());
+			}
+		}
+		if (bUnregisterEOS && EOSIds.Num() > 0)
+		{
+			EOS_Sessions_UnregisterPlayersOptions Options = { };
+			Options.ApiVersion = EOS_SESSIONS_UNREGISTERPLAYERS_API_LATEST;
+			Options.PlayersToUnregister = EOSIds.GetData();
+			Options.PlayersToUnregisterCount = EOSIds.Num();
+			const FTCHARToUTF8 Utf8SessionName(*SessionName.ToString());
+			Options.SessionName = Utf8SessionName.Get();
+
+			FUnregisterPlayersCallback* CallbackObj = new FUnregisterPlayersCallback();
+			CallbackObj->CallbackLambda = [this, SessionName, UnregisteredPlayers = TArray<FUniqueNetIdRef>(Players)](const EOS_Sessions_UnregisterPlayersCallbackInfo* Data)
+			{
+				bool bWasSuccessful = Data->ResultCode == EOS_EResult::EOS_Success || Data->ResultCode == EOS_EResult::EOS_NoChange;
+				TriggerOnUnregisterPlayersCompleteDelegates(SessionName, UnregisteredPlayers, bWasSuccessful);
+			};
+			EOS_Sessions_UnregisterPlayers(EOSSubsystem->SessionsHandle, &Options, CallbackObj, CallbackObj->GetCallbackPtr());
+			return true;
+		}
+	}
+	else
+	{
+		UE_LOG_ONLINE_SESSION(Warning, TEXT("No game present to leave for session (%s)"), *SessionName.ToString());
+		bSuccess = false;
+	}
+
+	EOSSubsystem->ExecuteNextTick([this, SessionName, Players, bSuccess]()
+		{
+			TriggerOnUnregisterPlayersCompleteDelegates(SessionName, Players, bSuccess);
+		});
+
+	return true;
+}
+
+void FOnlineSessionEOS::Tick(float DeltaTime)
+{
+	SCOPE_CYCLE_COUNTER(STAT_Session_Interface);
+	TickLanTasks(DeltaTime);
+}
+
+void FOnlineSessionEOS::TickLanTasks(float DeltaTime)
+{
+	if (LANSession.IsValid() &&
+		LANSession->GetBeaconState() > ELanBeaconState::NotUsingLanBeacon)
+	{
+		LANSession->Tick(DeltaTime);
+	}
+}
+
+void FOnlineSessionEOS::AppendSessionToPacket(FNboSerializeToBufferEOS& Packet, FOnlineSession* Session)
+{
+	/** Owner of the session */
+	Packet << *StaticCastSharedPtr<const FUniqueNetIdEOS>(Session->OwningUserId)
+		<< Session->OwningUserName
+		<< Session->NumOpenPrivateConnections
+		<< Session->NumOpenPublicConnections;
+
+	// Try to get the actual port the netdriver is using
+	SetPortFromNetDriver(*EOSSubsystem, Session->SessionInfo);
+
+	// Write host info (host addr, session id, and key)
+	Packet << *StaticCastSharedPtr<FOnlineSessionInfoEOS>(Session->SessionInfo);
+
+	// Now append per game settings
+	AppendSessionSettingsToPacket(Packet, &Session->SessionSettings);
+}
+
+void FOnlineSessionEOS::AppendSessionSettingsToPacket(FNboSerializeToBufferEOS& Packet, FOnlineSessionSettings* SessionSettings)
+{
+#if DEBUG_LAN_BEACON
+	UE_LOG_ONLINE_SESSION(Verbose, TEXT("Sending session settings to client"));
+#endif 
+
+	// Members of the session settings class
+	Packet << SessionSettings->NumPublicConnections
+		<< SessionSettings->NumPrivateConnections
+		<< (uint8)SessionSettings->bShouldAdvertise
+		<< (uint8)SessionSettings->bIsLANMatch
+		<< (uint8)SessionSettings->bIsDedicated
+		<< (uint8)SessionSettings->bUsesStats
+		<< (uint8)SessionSettings->bAllowJoinInProgress
+		<< (uint8)SessionSettings->bAllowInvites
+		<< (uint8)SessionSettings->bUsesPresence
+		<< (uint8)SessionSettings->bAllowJoinViaPresence
+		<< (uint8)SessionSettings->bAllowJoinViaPresenceFriendsOnly
+		<< (uint8)SessionSettings->bAntiCheatProtected
+	    << SessionSettings->BuildUniqueId;
+
+	// First count number of advertised keys
+	int32 NumAdvertisedProperties = 0;
+	for (FSessionSettings::TConstIterator It(SessionSettings->Settings); It; ++It)
+	{	
+		const FOnlineSessionSetting& Setting = It.Value();
+		if (Setting.AdvertisementType >= EOnlineDataAdvertisementType::ViaOnlineService)
+		{
+			NumAdvertisedProperties++;
+		}
+	}
+
+	// Add count of advertised keys and the data
+	Packet << (int32)NumAdvertisedProperties;
+	for (FSessionSettings::TConstIterator It(SessionSettings->Settings); It; ++It)
+	{
+		const FOnlineSessionSetting& Setting = It.Value();
+		if (Setting.AdvertisementType >= EOnlineDataAdvertisementType::ViaOnlineService)
+		{
+			Packet << It.Key();
+			Packet << Setting;
+#if DEBUG_LAN_BEACON
+			UE_LOG_ONLINE_SESSION(Verbose, TEXT("%s"), *Setting.ToString());
+#endif
+		}
+	}
+}
+
+void FOnlineSessionEOS::OnValidQueryPacketReceived(uint8* PacketData, int32 PacketLength, uint64 ClientNonce)
+{
+	// Iterate through all registered sessions and respond for each LAN match
+	FScopeLock ScopeLock(&SessionLock);
+	for (int32 SessionIndex = 0; SessionIndex < Sessions.Num(); SessionIndex++)
+	{
+		FNamedOnlineSession* Session = &Sessions[SessionIndex];
+
+		// Don't respond to query if the session is not a joinable LAN match.
+		if (Session != nullptr)
+		{
+			const FOnlineSessionSettings& Settings = Session->SessionSettings;
+
+			const bool bIsMatchInProgress = Session->SessionState == EOnlineSessionState::InProgress;
+
+			const bool bIsMatchJoinable = Settings.bIsLANMatch &&
+				(!bIsMatchInProgress || Settings.bAllowJoinInProgress) &&
+				Settings.NumPublicConnections > 0;
+
+			if (bIsMatchJoinable)
+			{
+				FNboSerializeToBufferEOS Packet(LAN_BEACON_MAX_PACKET_SIZE);
+				// Create the basic header before appending additional information
+				LANSession->CreateHostResponsePacket(Packet, ClientNonce);
+
+				// Add all the session details
+				AppendSessionToPacket(Packet, Session);
+
+				// Broadcast this response so the client can see us
+				LANSession->BroadcastPacket(Packet, Packet.GetByteCount());
+			}
+		}
+	}
+}
+
+void FOnlineSessionEOS::ReadSessionFromPacket(FNboSerializeFromBufferEOS& Packet, FOnlineSession* Session)
+{
+#if DEBUG_LAN_BEACON
+	UE_LOG_ONLINE_SESSION(Verbose, TEXT("Reading session information from server"));
+#endif
+
+	/** Owner of the session */
+	FUniqueNetIdEOSRef OwningUserId = FUniqueNetIdEOS::Create();
+	Packet >> *ConstCastSharedRef<FUniqueNetIdEOS>(OwningUserId)
+		>> Session->OwningUserName
+		>> Session->NumOpenPrivateConnections
+		>> Session->NumOpenPublicConnections;
+
+	Session->OwningUserId = OwningUserId;
+
+	// Allocate and read the connection data
+	FOnlineSessionInfoEOS* EOSSessionInfo = new FOnlineSessionInfoEOS();
+	EOSSessionInfo->HostAddr = ISocketSubsystem::Get(PLATFORM_SOCKETSUBSYSTEM)->CreateInternetAddr();
+	Packet >> *EOSSessionInfo;
+	Session->SessionInfo = MakeShareable(EOSSessionInfo); 
+
+	// Read any per object data using the server object
+	ReadSettingsFromPacket(Packet, Session->SessionSettings);
+}
+
+void FOnlineSessionEOS::ReadSettingsFromPacket(FNboSerializeFromBufferEOS& Packet, FOnlineSessionSettings& SessionSettings)
+{
+#if DEBUG_LAN_BEACON
+	UE_LOG_ONLINE_SESSION(Verbose, TEXT("Reading game settings from server"));
+#endif
+
+	// Clear out any old settings
+	SessionSettings.Settings.Empty();
+
+	// Members of the session settings class
+	Packet >> SessionSettings.NumPublicConnections
+		>> SessionSettings.NumPrivateConnections;
+	uint8 Read = 0;
+	// Read all the bools as bytes
+	Packet >> Read;
+	SessionSettings.bShouldAdvertise = !!Read;
+	Packet >> Read;
+	SessionSettings.bIsLANMatch = !!Read;
+	Packet >> Read;
+	SessionSettings.bIsDedicated = !!Read;
+	Packet >> Read;
+	SessionSettings.bUsesStats = !!Read;
+	Packet >> Read;
+	SessionSettings.bAllowJoinInProgress = !!Read;
+	Packet >> Read;
+	SessionSettings.bAllowInvites = !!Read;
+	Packet >> Read;
+	SessionSettings.bUsesPresence = !!Read;
+	Packet >> Read;
+	SessionSettings.bAllowJoinViaPresence = !!Read;
+	Packet >> Read;
+	SessionSettings.bAllowJoinViaPresenceFriendsOnly = !!Read;
+	Packet >> Read;
+	SessionSettings.bAntiCheatProtected = !!Read;
+
+	// BuildId
+	Packet >> SessionSettings.BuildUniqueId;
+
+	// Now read the contexts and properties from the settings class
+	int32 NumAdvertisedProperties = 0;
+	// First, read the number of advertised properties involved, so we can presize the array
+	Packet >> NumAdvertisedProperties;
+	if (Packet.HasOverflow() == false)
+	{
+		FName Key;
+		// Now read each context individually
+		for (int32 Index = 0;
+			Index < NumAdvertisedProperties && Packet.HasOverflow() == false;
+			Index++)
+		{
+			FOnlineSessionSetting Setting;
+			Packet >> Key;
+			Packet >> Setting;
+			SessionSettings.Set(Key, Setting);
+
+#if DEBUG_LAN_BEACON
+			UE_LOG_ONLINE_SESSION(Verbose, TEXT("%s"), *Setting->ToString());
+#endif
+		}
+	}
+	
+	// If there was an overflow, treat the string settings/properties as broken
+	if (Packet.HasOverflow())
+	{
+		SessionSettings.Settings.Empty();
+		UE_LOG_ONLINE_SESSION(Verbose, TEXT("Packet overflow detected in ReadGameSettingsFromPacket()"));
+	}
+}
+
+void FOnlineSessionEOS::OnValidResponsePacketReceived(uint8* PacketData, int32 PacketLength)
+{
+	// Create an object that we'll copy the data to
+	FOnlineSessionSettings NewServer;
+	if (CurrentSessionSearch.IsValid())
+	{
+		// Add space in the search results array
+		FOnlineSessionSearchResult* NewResult = new (CurrentSessionSearch->SearchResults) FOnlineSessionSearchResult();
+		// this is not a correct ping, but better than nothing
+		NewResult->PingInMs = static_cast<int32>((FPlatformTime::Seconds() - SessionSearchStartInSeconds) * 1000);
+
+		FOnlineSession* NewSession = &NewResult->Session;
+
+		// Prepare to read data from the packet
+		FNboSerializeFromBufferEOS Packet(PacketData, PacketLength);
+		
+		ReadSessionFromPacket(Packet, NewSession);
+
+		// NOTE: we don't notify until the timeout happens
+	}
+	else
+	{
+		UE_LOG_ONLINE_SESSION(Warning, TEXT("Failed to create new online game settings object"));
+	}
+}
+
+void FOnlineSessionEOS::OnLANSearchTimeout()
+{
+	// See if there were any sessions that were marked as hosting before the search started
+	bool bWasHosting = false;
+
+	{
+		FScopeLock ScopeLock(&SessionLock);
+		for (int32 SessionIdx = 0; SessionIdx < Sessions.Num(); SessionIdx++)
+		{
+			FNamedOnlineSession& Session = Sessions[SessionIdx];
+			if (Session.SessionSettings.bShouldAdvertise &&
+				Session.SessionSettings.bIsLANMatch &&
+				EOSSubsystem->IsServer())
+			{
+				bWasHosting = true;
+				break;
+			}
+		}
+	}
+
+	if (bWasHosting)
+	{
+		FOnValidQueryPacketDelegate QueryPacketDelegate = FOnValidQueryPacketDelegate::CreateRaw(this, &FOnlineSessionEOS::OnValidQueryPacketReceived);
+		// Maintain lan beacon if there was a session that was marked as hosting
+		if (LANSession->Host(QueryPacketDelegate))
+		{
+			UE_LOG_ONLINE_SESSION(Warning, TEXT("Failed to restart hosted LAN session after search completion"));
+		}
+	}
+	else
+	{
+		// Stop future timeouts since we aren't searching any more
+		LANSession->StopLANSession();
+	}
+
+	if (CurrentSessionSearch.IsValid())
+	{
+		if (CurrentSessionSearch->SearchResults.Num() > 0)
+		{
+			// Allow game code to sort the servers
+			CurrentSessionSearch->SortSearchResults();
+		}
+
+		CurrentSessionSearch->SearchState = EOnlineAsyncTaskState::Done;
+
+		CurrentSessionSearch = nullptr;
+	}
+
+	// Trigger the delegate as complete
+	EOSSubsystem->ExecuteNextTick([this]()
+		{
+			TriggerOnFindSessionsCompleteDelegates(true);
+		});
+}
+
+int32 FOnlineSessionEOS::GetNumSessions()
+{
+	FScopeLock ScopeLock(&SessionLock);
+	return Sessions.Num();
+}
+
+void FOnlineSessionEOS::DumpSessionState()
+{
+	FScopeLock ScopeLock(&SessionLock);
+
+	for (int32 SessionIdx=0; SessionIdx < Sessions.Num(); SessionIdx++)
+	{
+		DumpNamedSession(&Sessions[SessionIdx]);
+	}
+}
+
+void FOnlineSessionEOS::RegisterLocalPlayer(const FUniqueNetId& PlayerId, FName SessionName, const FOnRegisterLocalPlayerCompleteDelegate& Delegate)
+{
+	Delegate.ExecuteIfBound(PlayerId, EOnJoinSessionCompleteResult::Success);
+}
+
+void FOnlineSessionEOS::UnregisterLocalPlayer(const FUniqueNetId& PlayerId, FName SessionName, const FOnUnregisterLocalPlayerCompleteDelegate& Delegate)
+{
+	Delegate.ExecuteIfBound(PlayerId, true);
+}
+
+void FOnlineSessionEOS::RemovePlayerFromSession(int32 LocalUserNum, FName SessionName, const FUniqueNetId& TargetPlayerId)
+{
+	FNamedOnlineSession* Session = GetNamedSession(SessionName);
+	if (Session)
+	{
+		EOS_Lobby_KickMemberOptions KickMemberOptions = {};
+		KickMemberOptions.ApiVersion = EOS_LOBBY_KICKMEMBER_API_LATEST;
+		const FTCHARToUTF8 Utf8LobbyId(*Session->SessionInfo->GetSessionId().ToString());
+		KickMemberOptions.LobbyId = (EOS_LobbyId)Utf8LobbyId.Get();
+		KickMemberOptions.LocalUserId = EOSSubsystem->UserManager->GetLocalProductUserId(LocalUserNum);
+		KickMemberOptions.TargetUserId = EOSSubsystem->UserManager->GetProductUserId(TargetPlayerId);
+
+		FLobbyRemovePlayerCallback* CallbackObj = new FLobbyRemovePlayerCallback();
+		CallbackObj->CallbackLambda = [this](const EOS_Lobby_KickMemberCallbackInfo* Data)
+		{
+			if (Data->ResultCode == EOS_EResult::EOS_Success)
+			{
+				UE_LOG_ONLINE_SESSION(Verbose, TEXT("[FOnlineSessionEOS::RemovePlayerFromSession] KickMember finished successfully for lobby %d."), Data->LobbyId);
+			}
+			else
+			{
+				UE_LOG_ONLINE_SESSION(Warning, TEXT("[FOnlineSessionEOS::RemovePlayerFromSession] KickMember not successful. Finished with EOS_EResult %s"), ANSI_TO_TCHAR(EOS_EResult_ToString(Data->ResultCode)));
+			}
+		};
+
+		EOS_Lobby_KickMember(LobbyHandle, &KickMemberOptions, CallbackObj, CallbackObj->GetCallbackPtr());
+	}
+	else
+	{
+		UE_LOG_ONLINE(Warning, TEXT("[FOnlineSessionEOS::RemovePlayerFromSession] Unable to retrieve session named %s"), *SessionName.ToString());
+	}
+}
+
+void FOnlineSessionEOS::SetPortFromNetDriver(const FOnlineSubsystemEOS& Subsystem, const TSharedPtr<FOnlineSessionInfo>& SessionInfo)
+{
+	auto NetDriverPort = GetPortFromNetDriver(Subsystem.GetInstanceName());
+	auto SessionInfoEOS = StaticCastSharedPtr<FOnlineSessionInfoEOS>(SessionInfo);
+	if (SessionInfoEOS.IsValid() && SessionInfoEOS->HostAddr.IsValid())
+	{
+		SessionInfoEOS->HostAddr->SetPort(NetDriverPort);
+	}
+}
+
+bool FOnlineSessionEOS::IsHost(const FNamedOnlineSession& Session) const
+{
+	if (EOSSubsystem->IsDedicated())
+	{
+		return true;
+	}
+
+	FUniqueNetIdPtr UserId = EOSSubsystem->UserManager->GetUniquePlayerId(Session.HostingPlayerNum);
+	return (UserId.IsValid() && (*UserId == *Session.OwningUserId));
+}
+
+FUniqueNetIdPtr FOnlineSessionEOS::CreateSessionIdFromString(const FString& SessionIdStr)
+{
+	FUniqueNetIdPtr SessionId;
+	if (!SessionIdStr.IsEmpty())
+	{
+		SessionId = FUniqueNetIdEOS::Create(SessionIdStr);
+	}
+	return SessionId;
+}
+
+EOS_ELobbyPermissionLevel FOnlineSessionEOS::GetLobbyPermissionLevelFromSessionSettings(const FOnlineSessionSettings& SessionSettings)
+{
+	EOS_ELobbyPermissionLevel Result;
+
+	if (SessionSettings.NumPublicConnections > 0)
+	{
+		Result = EOS_ELobbyPermissionLevel::EOS_LPL_PUBLICADVERTISED;
+	}
+	else if (SessionSettings.bAllowJoinViaPresence)
+	{
+		Result = EOS_ELobbyPermissionLevel::EOS_LPL_JOINVIAPRESENCE;
+	}
+	else
+	{
+		Result = EOS_ELobbyPermissionLevel::EOS_LPL_INVITEONLY;
+	}
+
+	return Result;
+}
+
+uint32_t FOnlineSessionEOS::GetLobbyMaxMembersFromSessionSettings(const FOnlineSessionSettings& SessionSettings)
+{
+	return SessionSettings.NumPrivateConnections + SessionSettings.NumPublicConnections;
+}
+
+uint32 FOnlineSessionEOS::CreateLobbySession(int32 HostingPlayerNum, FNamedOnlineSession* Session)
+{
+	check(Session != nullptr);
+
+	Session->SessionState = EOnlineSessionState::Creating;
+	Session->bHosting = true;
+
+	const EOS_ProductUserId LocalProductUserId = EOSSubsystem->UserManager->GetLocalProductUserId(HostingPlayerNum);
+	const FUniqueNetIdPtr LocalUserNetId = EOSSubsystem->UserManager->GetLocalUniqueNetIdEOS(HostingPlayerNum);
+
+	EOS_Lobby_CreateLobbyOptions CreateLobbyOptions = { 0 };
+	CreateLobbyOptions.ApiVersion = EOS_LOBBY_CREATELOBBY_API_LATEST;
+	CreateLobbyOptions.LocalUserId = LocalProductUserId;
+	CreateLobbyOptions.MaxLobbyMembers = GetLobbyMaxMembersFromSessionSettings(Session->SessionSettings);
+	CreateLobbyOptions.PermissionLevel = GetLobbyPermissionLevelFromSessionSettings(Session->SessionSettings);
+	CreateLobbyOptions.bPresenceEnabled = Session->SessionSettings.bUsesPresence;
+	CreateLobbyOptions.bAllowInvites = Session->SessionSettings.bAllowInvites;
+	CreateLobbyOptions.BucketId = BucketIdAnsi;
+#if WITH_EOS_RTC
+	CreateLobbyOptions.bEnableRTCRoom = Session->SessionSettings.bUseLobbiesVoiceChatIfAvailable;
+#endif
+
+	/*When the operation finishes, the EOS_Lobby_OnCreateLobbyCallback will run with an EOS_Lobby_CreateLobbyCallbackInfo data structure.
+	If the data structure's ResultCode field indicates success, its LobbyId field contains the new lobby's ID value, which we will need to interact with the lobby further.*/
+
+	FName SessionName = Session->SessionName;
+	FLobbyCreatedCallback* CallbackObj = new FLobbyCreatedCallback();
+	LobbyCreatedCallback = CallbackObj;
+	CallbackObj->CallbackLambda = [this, SessionName, LocalProductUserId, LocalUserNetId](const EOS_Lobby_CreateLobbyCallbackInfo* Data)
+	{
+		FNamedOnlineSession* Session = GetNamedSession(SessionName);
+		if (Session)
+		{
+			bool bWasSuccessful = Data->ResultCode == EOS_EResult::EOS_Success;
+			if (bWasSuccessful)
+			{
+				UE_LOG_ONLINE_SESSION(Verbose, TEXT("[FOnlineSessionEOS::CreateLobbySession] CreateLobby was successful. LobbyId is %d."), Data->LobbyId);
+
+				Session->SessionState = EOnlineSessionState::Pending;
+
+				// Because some platforms remap ports, we will use the ID of the name of the net driver to be our port instead
+				FName NetDriverName = GetDefault<UNetDriverEOS>()->NetDriverName;
+				FInternetAddrEOS TempAddr(LexToString(LocalProductUserId), SessionName.ToString(), FURL::UrlConfig.DefaultPort);
+				FString HostAddr = TempAddr.ToString(true);
+
+				Session->SessionInfo = MakeShareable(new FOnlineSessionInfoEOS(HostAddr, Data->LobbyId, nullptr));
+
+#if WITH_EOS_RTC
+				if (FEOSVoiceChatUser* VoiceChatUser = static_cast<FEOSVoiceChatUser*>(EOSSubsystem->GetEOSVoiceChatUserInterface(*LocalUserNetId)))
+				{
+					VoiceChatUser->AddLobbyRoom(UTF8_TO_TCHAR(Data->LobbyId));
+				}
+#endif
+
+				BeginSessionAnalytics(Session);
+
+				UpdateLobbySession(Session);
+			}
+			else
+			{
+				UE_LOG_ONLINE_SESSION(Warning, TEXT("[FOnlineSessionEOS::CreateLobbySession] CreateLobby not successful. Finished with EOS_EResult %s"), ANSI_TO_TCHAR(EOS_EResult_ToString(Data->ResultCode)));
+
+				Session->SessionState = EOnlineSessionState::NoSession;
+
+				RemoveNamedSession(SessionName);
+			}
+
+			TriggerOnCreateSessionCompleteDelegates(SessionName, bWasSuccessful);
+		}
+	};
+
+	EOS_Lobby_CreateLobby(LobbyHandle, &CreateLobbyOptions, CallbackObj, CallbackObj->GetCallbackPtr());
+
+	return ONLINE_IO_PENDING;
+}
+
+uint32 FOnlineSessionEOS::JoinLobbySession(int32 PlayerNum, FNamedOnlineSession* Session, const FOnlineSession* SearchSession)
+{
+	check(Session != nullptr);
+
+	uint32 Result = ONLINE_FAIL;
+
+	if (Session->SessionInfo.IsValid())
+	{
+		FOnlineSessionInfoEOS* EOSSessionInfo = (FOnlineSessionInfoEOS*)(Session->SessionInfo.Get());
+		if (EOSSessionInfo->SessionId->IsValid())
+		{
+			const FOnlineSessionInfoEOS* SearchSessionInfo = (const FOnlineSessionInfoEOS*)(SearchSession->SessionInfo.Get());
+			EOSSessionInfo->HostAddr = SearchSessionInfo->HostAddr;
+			EOSSessionInfo->EOSAddress = SearchSessionInfo->EOSAddress;
+			EOSSessionInfo->SessionHandle = SearchSessionInfo->SessionHandle;
+			EOSSessionInfo->SessionId = SearchSessionInfo->SessionId;
+			EOSSessionInfo->bIsFromClone = SearchSessionInfo->bIsFromClone;
+
+			Session->SessionState = EOnlineSessionState::Pending;
+			
+			EOS_Lobby_JoinLobbyOptions JoinLobbyOptions = { 0 };
+			JoinLobbyOptions.ApiVersion = EOS_LOBBY_JOINLOBBY_API_LATEST;
+			JoinLobbyOptions.LocalUserId = EOSSubsystem->UserManager->GetLocalProductUserId(PlayerNum);
+			JoinLobbyOptions.bPresenceEnabled = Session->SessionSettings.bUsesPresence;
+
+ 			EOS_HLobbyDetails LobbyDetailsHandle = *LobbySearchResultsCache[Session->SessionInfo->GetSessionId().ToString()];
+ 			JoinLobbyOptions.LobbyDetailsHandle = LobbyDetailsHandle;
+
+			FName SessionName = Session->SessionName;
+			FUniqueNetIdPtr LocalUserNetId = EOSSubsystem->UserManager->GetLocalUniqueNetIdEOS(PlayerNum);
+
+			FLobbyJoinedCallback* CallbackObj = new FLobbyJoinedCallback();
+			LobbyJoinedCallback = CallbackObj;
+			CallbackObj->CallbackLambda = [this, SessionName, LocalUserNetId, LobbyDetailsHandle](const EOS_Lobby_JoinLobbyCallbackInfo* Data)
+			{
+				FNamedOnlineSession* Session = GetNamedSession(SessionName);
+				if (Session)
+				{
+					bool bWasSuccessful = Data->ResultCode == EOS_EResult::EOS_Success;
+					if (bWasSuccessful)
+					{
+						UE_LOG_ONLINE_SESSION(Verbose, TEXT("[FOnlineSessionEOS::JoinLobbySession] JoinLobby was successful. LobbyId is %d."), Data->LobbyId);
+
+						BeginSessionAnalytics(Session);
+						
+						// Initialize the OSS's member list with the current member list of the lobby.
+						const FUniqueNetIdEOSRef LobbyNetId = FUniqueNetIdEOS::Create(UTF8_TO_TCHAR(Data->LobbyId));
+						EOS_LobbyDetails_GetMemberCountOptions GetMemberCountOptions = { 0 };
+						GetMemberCountOptions.ApiVersion = EOS_LOBBYDETAILS_GETMEMBERCOUNT_API_LATEST;
+						const uint32 MemberCount = EOS_LobbyDetails_GetMemberCount(LobbyDetailsHandle, &GetMemberCountOptions);
+						
+						EOS_LobbyDetails_GetMemberByIndexOptions GetMemberOptions = { 0 };
+						GetMemberOptions.ApiVersion = EOS_LOBBYDETAILS_GETMEMBERBYINDEX_API_LATEST;
+						for(uint32 MemberIndex = 0; MemberIndex < MemberCount; ++MemberIndex)
+						{
+							GetMemberOptions.MemberIndex = MemberIndex;
+							const EOS_ProductUserId ProductUserId = EOS_LobbyDetails_GetMemberByIndex(LobbyDetailsHandle, &GetMemberOptions);
+							AddLobbyMember(LobbyNetId, ProductUserId);
+						}
+
+#if WITH_EOS_RTC
+						if (FEOSVoiceChatUser* VoiceChatUser = static_cast<FEOSVoiceChatUser*>(EOSSubsystem->GetEOSVoiceChatUserInterface(*LocalUserNetId)))
+						{
+							VoiceChatUser->AddLobbyRoom(UTF8_TO_TCHAR(Data->LobbyId));
+						}
+#endif
+					}
+					else
+					{
+						UE_LOG_ONLINE_SESSION(Warning, TEXT("[FOnlineSessionEOS::JoinLobbySession] JoinLobby not successful. Finished with EOS_EResult %s"), ANSI_TO_TCHAR(EOS_EResult_ToString(Data->ResultCode)));
+
+						Session->SessionState = EOnlineSessionState::NoSession;
+
+						RemoveNamedSession(SessionName);
+					}
+
+					TriggerOnJoinSessionCompleteDelegates(SessionName, bWasSuccessful ? EOnJoinSessionCompleteResult::Success : EOnJoinSessionCompleteResult::UnknownError);
+
+					// Now that we have joined one of the sessions we found on the search, we can clear the results
+					for (TPair<FString, TSharedRef<EOS_HLobbyDetails>> LobbySearchResult : LobbySearchResultsCache)
+					{
+						EOS_LobbyDetails_Release(*LobbySearchResult.Value);
+					}
+
+					LobbySearchResultsCache.Reset();
+				}
+				else
+				{
+					UE_LOG_ONLINE_SESSION(Warning, TEXT("[FOnlineSessionEOS::JoinLobbySession] Unable to find session %s"), *SessionName.ToString());
+					TriggerOnJoinSessionCompleteDelegates(SessionName, EOnJoinSessionCompleteResult::SessionDoesNotExist);
+				}
+			};
+
+			EOS_Lobby_JoinLobby(LobbyHandle, &JoinLobbyOptions, CallbackObj, CallbackObj->GetCallbackPtr());
+
+			Result = ONLINE_IO_PENDING;
+		}
+	}
+	else
+	{
+		UE_LOG_ONLINE_SESSION(Warning, TEXT("[FOnlineSessionEOS::JoinLobbySession] SessionInfo not valid."));
+	}
+
+	return Result;
+}
+
+void FOnlineSessionEOS::SetLobbyPermissionLevel(EOS_HLobbyModification LobbyModificationHandle, FNamedOnlineSession* Session)
+{
+	check(Session != nullptr);
+
+	EOS_LobbyModification_SetPermissionLevelOptions Options = { 0 };
+	Options.ApiVersion = EOS_SESSIONMODIFICATION_SETPERMISSIONLEVEL_API_LATEST;
+	Options.PermissionLevel = GetLobbyPermissionLevelFromSessionSettings(Session->SessionSettings);
+
+	EOS_EResult ResultCode = EOS_LobbyModification_SetPermissionLevel(LobbyModificationHandle, &Options);
+	if (ResultCode != EOS_EResult::EOS_Success)
+	{
+		UE_LOG_ONLINE_SESSION(Warning, TEXT("[FOnlineSessionEOS::SetLobbyPermissionLevel] LobbyModification_SetPermissionLevel not successful. Finished with EOS_EResult %s"), ANSI_TO_TCHAR(EOS_EResult_ToString(ResultCode)));
+	}
+}
+
+void FOnlineSessionEOS::SetLobbyMaxMembers(EOS_HLobbyModification LobbyModificationHandle, FNamedOnlineSession* Session)
+{
+	check(Session != nullptr);
+
+	EOS_LobbyModification_SetMaxMembersOptions Options = { };
+	Options.ApiVersion = EOS_LOBBYMODIFICATION_SETMAXMEMBERS_API_LATEST;
+	Options.MaxMembers = GetLobbyMaxMembersFromSessionSettings(Session->SessionSettings);
+
+	EOS_EResult ResultCode = EOS_LobbyModification_SetMaxMembers(LobbyModificationHandle, &Options);
+	if (ResultCode != EOS_EResult::EOS_Success)
+	{
+		UE_LOG_ONLINE_SESSION(Warning, TEXT("[FOnlineSessionEOS::SetLobbyMaxMembers] LobbyModification_SetJoinInProgressAllowed not successful. Finished with EOS_EResult %s"), ANSI_TO_TCHAR(EOS_EResult_ToString(ResultCode)));
+	}
+}
+
+void FOnlineSessionEOS::AddLobbyAttribute(EOS_HLobbyModification LobbyModificationHandle, const EOS_Lobby_AttributeData* Attribute)
+{
+	EOS_LobbyModification_AddAttributeOptions Options = { };
+	Options.ApiVersion = EOS_LOBBYMODIFICATION_ADDATTRIBUTE_API_LATEST;
+	Options.Visibility = EOS_ELobbyAttributeVisibility::EOS_LAT_PUBLIC;
+	Options.Attribute = Attribute;
+
+	EOS_EResult ResultCode = EOS_LobbyModification_AddAttribute(LobbyModificationHandle, &Options);
+	if (ResultCode != EOS_EResult::EOS_Success)
+	{
+		UE_LOG_ONLINE_SESSION(Error, TEXT("[FOnlineSessionEOS::AddLobbyAttribute] LobbyModification_AddAttribute for attribute name (%s) not successful. Finished with EOS_EResult %s"), *FString(Attribute->Key), ANSI_TO_TCHAR(EOS_EResult_ToString(ResultCode)));
+	}
+}
+
+void FOnlineSessionEOS::AddLobbyMemberAttribute(EOS_HLobbyModification LobbyModificationHandle, const EOS_Lobby_AttributeData* Attribute)
+{
+	EOS_LobbyModification_AddMemberAttributeOptions Options = { };
+	Options.ApiVersion = EOS_LOBBYMODIFICATION_ADDMEMBERATTRIBUTE_API_LATEST;
+	Options.Visibility = EOS_ELobbyAttributeVisibility::EOS_LAT_PUBLIC;
+	Options.Attribute = Attribute;
+
+	EOS_EResult ResultCode = EOS_LobbyModification_AddMemberAttribute(LobbyModificationHandle, &Options);
+	if (ResultCode != EOS_EResult::EOS_Success)
+	{
+		UE_LOG_ONLINE_SESSION(Error, TEXT("[FOnlineSessionEOS::AddLobbyMemberAttribute] LobbyModification_AddMemberAttribute for attribute name (%s) not successful. Finished with EOS_EResult %s"), *FString(Attribute->Key), ANSI_TO_TCHAR(EOS_EResult_ToString(ResultCode)));
+	}
+}
+
+void FOnlineSessionEOS::SetLobbyAttributes(EOS_HLobbyModification LobbyModificationHandle, FNamedOnlineSession* Session)
+{
+	check(Session != nullptr);
+
+	// The first will let us find it on session searches
+	const FString SearchPresence(SEARCH_PRESENCE.ToString());
+	const FLobbyAttributeOptions SearchPresenceAttribute(TCHAR_TO_UTF8(*SearchPresence), true);
+	AddLobbyAttribute(LobbyModificationHandle, &SearchPresenceAttribute);
+
+	// The second will let us find it on lobby searches
+	const FString SearchLobbies(SEARCH_LOBBIES.ToString());
+	const FLobbyAttributeOptions SearchLobbiesAttribute(TCHAR_TO_UTF8(*SearchLobbies), true);
+	AddLobbyAttribute(LobbyModificationHandle, &SearchLobbiesAttribute);
+
+	// We set the session's owner id and name
+	const FLobbyAttributeOptions OwnerId("OwningUserId", TCHAR_TO_UTF8(*Session->OwningUserId->ToString()));
+	AddLobbyAttribute(LobbyModificationHandle, &OwnerId);
+
+	const FLobbyAttributeOptions OwnerName("OwningUserName", TCHAR_TO_UTF8(*Session->OwningUserName));
+	AddLobbyAttribute(LobbyModificationHandle, &OwnerName);
+
+	// Now the session settings
+	const FLobbyAttributeOptions Opt1("NumPrivateConnections", Session->SessionSettings.NumPrivateConnections);
+	AddLobbyAttribute(LobbyModificationHandle, &Opt1);
+
+	const FLobbyAttributeOptions Opt2("NumPublicConnections", Session->SessionSettings.NumPublicConnections);
+	AddLobbyAttribute(LobbyModificationHandle, &Opt2);
+
+	const FLobbyAttributeOptions Opt5("bAntiCheatProtected", Session->SessionSettings.bAntiCheatProtected);
+	AddLobbyAttribute(LobbyModificationHandle, &Opt5);
+
+	const FLobbyAttributeOptions Opt6("bUsesStats", Session->SessionSettings.bUsesStats);
+	AddLobbyAttribute(LobbyModificationHandle, &Opt6);
+
+	// Likely unnecessary for lobbies
+	const FLobbyAttributeOptions Opt7("bIsDedicated", Session->SessionSettings.bIsDedicated);
+	AddLobbyAttribute(LobbyModificationHandle, &Opt7);
+
+	const FLobbyAttributeOptions Opt8("BuildUniqueId", Session->SessionSettings.BuildUniqueId);
+	AddLobbyAttribute(LobbyModificationHandle, &Opt8);
+
+	// Add all of the custom settings
+	for (FSessionSettings::TConstIterator It(Session->SessionSettings.Settings); It; ++It)
+	{
+		const FName KeyName = It.Key();
+		const FOnlineSessionSetting& Setting = It.Value();
+
+		// Skip unsupported types or non session advertised settings
+		if (Setting.AdvertisementType < EOnlineDataAdvertisementType::ViaOnlineService || !IsSessionSettingTypeSupported(Setting.Data.GetType()))
+		{
+			continue;
+		}
+
+		const FLobbyAttributeOptions Attribute(TCHAR_TO_UTF8(*KeyName.ToString()), Setting.Data);
+		AddLobbyAttribute(LobbyModificationHandle, &Attribute);
+	}
+
+	// Add all of the member settings
+	for (TPair<FUniqueNetIdRef, FSessionSettings> MemberSettings : Session->SessionSettings.MemberSettings)
+	{
+		// We'll only copy our local player's attributes
+		if (*EOSSubsystem->UserManager->GetUniquePlayerId(EOSSubsystem->UserManager->GetDefaultLocalUser()) == *MemberSettings.Key)
+		{
+			for (FSessionSettings::TConstIterator It(MemberSettings.Value); It; ++It)
+			{
+				const FName KeyName = It.Key();
+				const FOnlineSessionSetting& Setting = It.Value();
+
+				// Skip unsupported types or non session advertised settings
+				if (Setting.AdvertisementType < EOnlineDataAdvertisementType::ViaOnlineService || !IsSessionSettingTypeSupported(Setting.Data.GetType()))
+				{
+					continue;
+				}
+
+				const FLobbyAttributeOptions Attribute(TCHAR_TO_UTF8(*KeyName.ToString()), Setting.Data);
+				AddLobbyMemberAttribute(LobbyModificationHandle, &Attribute);
+			}
+		}
+	}
+}
+
+void FOnlineSessionEOS::AddLobbyMember(const FUniqueNetIdEOSRef LobbyNetId, const EOS_ProductUserId& TargetUserId)
+{
+	EOSSubsystem->UserManager->GetEpicAccountIdAsync(TargetUserId, [this, LobbyNetId](const EOS_ProductUserId& ProductUserId, EOS_EpicAccountId& EpicAccountId)
+		{
+			if (const FNamedOnlineSession* Session = GetNamedSessionFromLobbyId(*LobbyNetId))
+			{
+				const FUniqueNetIdPtr UniqueNetId = EOSSubsystem->UserManager->CreateUniquePlayerId(MakeNetIdStringFromIds(EpicAccountId, ProductUserId));
+
+				RegisterPlayer(Session->SessionName, *UniqueNetId, false);
+
+				// Right after registering the user, we query their member settings
+				const FTCHARToUTF8 Utf8LobbyId(*LobbyNetId->ToString());
+				OnLobbyMemberUpdateReceived(static_cast<EOS_LobbyId>(Utf8LobbyId.Get()), ProductUserId);
+
+				// Maybe redundant with the register player signal?
+				TriggerOnSessionParticipantsChangeDelegates(Session->SessionName, *UniqueNetId, true);
+			}
+			else
+			{
+				UE_LOG_ONLINE(Warning, TEXT("[FOnlineSessionEOS::AddLobbyMember] Unable to retrieve session with LobbyId %s"), *LobbyNetId->ToString());
+			}
+		});
+}
+
+
+uint32 FOnlineSessionEOS::UpdateLobbySession(FNamedOnlineSession* Session)
+{
+	check(Session != nullptr);
+
+	uint32 Result = ONLINE_FAIL;
+
+	if (Session->SessionState == EOnlineSessionState::Creating)
+	{
+		Result = ONLINE_IO_PENDING;
+	}
+	else
+	{
+		EOS_Lobby_UpdateLobbyModificationOptions UpdateLobbyModificationOptions = { 0 };
+		UpdateLobbyModificationOptions.ApiVersion = EOS_LOBBY_UPDATELOBBYMODIFICATION_API_LATEST;
+		const FTCHARToUTF8 Utf8LobbyId(*Session->SessionInfo->GetSessionId().ToString());
+		UpdateLobbyModificationOptions.LobbyId = (EOS_LobbyId)Utf8LobbyId.Get();
+		UpdateLobbyModificationOptions.LocalUserId = EOSSubsystem->UserManager->GetLocalProductUserId(EOSSubsystem->UserManager->GetDefaultLocalUser()); // Maybe not split screen friendly
+
+		EOS_HLobbyModification LobbyModificationHandle;
+
+		EOS_EResult LobbyModificationResult = EOS_Lobby_UpdateLobbyModification(LobbyHandle, &UpdateLobbyModificationOptions, &LobbyModificationHandle);
+		if (LobbyModificationResult == EOS_EResult::EOS_Success)
+		{
+			SetLobbyPermissionLevel(LobbyModificationHandle, Session);
+			SetLobbyMaxMembers(LobbyModificationHandle, Session);
+			SetLobbyAttributes(LobbyModificationHandle, Session);
+
+			EOS_Lobby_UpdateLobbyOptions UpdateLobbyOptions = { 0 };
+			UpdateLobbyOptions.ApiVersion = EOS_LOBBY_UPDATELOBBY_API_LATEST;
+			UpdateLobbyOptions.LobbyModificationHandle = LobbyModificationHandle;
+
+			FName SessionName = Session->SessionName;
+			FLobbyUpdatedCallback* CallbackObj = new FLobbyUpdatedCallback();
+			CallbackObj->CallbackLambda = [this, SessionName](const EOS_Lobby_UpdateLobbyCallbackInfo* Data)
+			{
+				FNamedOnlineSession* Session = GetNamedSession(SessionName);
+				if (Session)
+				{
+					bool bWasSuccessful = Data->ResultCode == EOS_EResult::EOS_Success || Data->ResultCode == EOS_EResult::EOS_Sessions_OutOfSync;
+					if (!bWasSuccessful)
+					{
+						Session->SessionState = EOnlineSessionState::NoSession;
+						UE_LOG_ONLINE_SESSION(Warning, TEXT("[FOnlineSessionEOS::UpdateLobbySession] UpdateLobby not successful. Finished with EOS_EResult %s"), ANSI_TO_TCHAR(EOS_EResult_ToString(Data->ResultCode)));
+					}
+
+					TriggerOnUpdateSessionCompleteDelegates(SessionName, bWasSuccessful);
+				}
+				else
+				{
+					UE_LOG_ONLINE_SESSION(Warning, TEXT("[FOnlineSessionEOS::UpdateLobbySession] Unable to find session %s"), *SessionName.ToString());
+					TriggerOnUpdateSessionCompleteDelegates(SessionName, false);
+				}
+			};
+
+			EOS_Lobby_UpdateLobby(LobbyHandle, &UpdateLobbyOptions, CallbackObj, CallbackObj->GetCallbackPtr());
+
+			EOS_LobbyModification_Release(LobbyModificationHandle);
+
+			Result = ONLINE_IO_PENDING;
+		}
+		else
+		{
+			UE_LOG_ONLINE_SESSION(Warning, TEXT("[FOnlineSessionEOS::UpdateLobbySession] UpdateLobbyModification not successful. Finished with EOS_EResult %s"), ANSI_TO_TCHAR(EOS_EResult_ToString(LobbyModificationResult)));
+		}
+	}
+
+	return Result;
+}
+
+uint32 FOnlineSessionEOS::EndLobbySession(FNamedOnlineSession* Session)
+{
+	// Only called from EndSession/DestroySession and presumes only in InProgress state
+	check(Session && Session->SessionState == EOnlineSessionState::InProgress);
+
+	EOSSubsystem->ExecuteNextTick([this, Session]()
+		{
+			Session->SessionState = EOnlineSessionState::Ended;
+
+			TriggerOnEndSessionCompleteDelegates(Session->SessionName, true);
+		});
+
+	return ONLINE_IO_PENDING;
+}
+
+uint32 FOnlineSessionEOS::DestroyLobbySession(FNamedOnlineSession* Session, const FOnDestroySessionCompleteDelegate& CompletionDelegate)
+{
+	check(Session != nullptr);
+
+	uint32 Result = ONLINE_FAIL;
+
+	if (Session->SessionInfo.IsValid())
+	{
+		Session->SessionState = EOnlineSessionState::Destroying;
+
+		FOnlineSessionInfoEOS* SessionInfo = (FOnlineSessionInfoEOS*)(Session->SessionInfo.Get());
+		check(Session->SessionSettings.bUseLobbiesIfAvailable); // We check if it's a lobby session
+
+		FName SessionName = Session->SessionName;
+		const FUniqueNetIdPtr OwningNetId = Session->OwningUserId;
+		const FUniqueNetIdPtr LocalNetId = EOSSubsystem->UserManager->GetUniquePlayerId(EOSSubsystem->UserManager->GetDefaultLocalUser());
+
+		// If we are the owner of the lobby we will destroy it, since we will trigger an OSS session destruction anyway, forcing everyone else to leave the lobby too
+		if (OwningNetId != nullptr && LocalNetId  != nullptr && *LocalNetId == *OwningNetId)
+		{
+			// Destroy Lobby
+			EOS_Lobby_DestroyLobbyOptions DestroyOptions = { 0 };
+			DestroyOptions.ApiVersion = EOS_LOBBY_DESTROYLOBBY_API_LATEST;
+			const FTCHARToUTF8 Utf8LobbyId(*SessionInfo->GetSessionId().ToString());
+			DestroyOptions.LobbyId = (EOS_LobbyId)Utf8LobbyId.Get();
+			DestroyOptions.LocalUserId = EOSSubsystem->UserManager->GetLocalProductUserId(EOSSubsystem->UserManager->GetDefaultLocalUser()); // Maybe not split screen friendly
+
+			FLobbyDestroyedCallback* DestroyCallbackObj = new FLobbyDestroyedCallback();
+			LobbyDestroyedCallback = DestroyCallbackObj;
+			DestroyCallbackObj->CallbackLambda = [this, SessionName, CompletionDelegate](const EOS_Lobby_DestroyLobbyCallbackInfo* Data)
+			{
+				FNamedOnlineSession* LobbySession = GetNamedSession(SessionName);
+				if (LobbySession)
+				{
+					bool bWasSuccessful = Data->ResultCode == EOS_EResult::EOS_Success;
+					if (!bWasSuccessful)
+					{
+						UE_LOG_ONLINE_SESSION(Warning, TEXT("[FOnlineSessionEOS::DestroyLobbySession] DestroyLobby not successful. Finished with EOS_EResult %s"), ANSI_TO_TCHAR(EOS_EResult_ToString(Data->ResultCode)));
+					}
+
+#if WITH_EOS_RTC
+					if (FEOSVoiceChatUser* VoiceChatUser = static_cast<FEOSVoiceChatUser*>(EOSSubsystem->GetEOSVoiceChatUserInterface(*EOSSubsystem->UserManager->GetLocalUniqueNetIdEOS())))
+					{
+						VoiceChatUser->RemoveLobbyRoom(UTF8_TO_TCHAR(Data->LobbyId));
+					}
+#endif
+
+					EndSessionAnalytics();
+
+					LobbySession->SessionState = EOnlineSessionState::NoSession;
+
+					RemoveNamedSession(SessionName);
+
+					CompletionDelegate.ExecuteIfBound(SessionName, bWasSuccessful);
+					TriggerOnDestroySessionCompleteDelegates(SessionName, bWasSuccessful);
+				}
+				else
+				{
+					UE_LOG_ONLINE_SESSION(Warning, TEXT("[FOnlineSessionEOS::DestroyLobbySession] Unable to find session %s"), *SessionName.ToString());
+					TriggerOnDestroySessionCompleteDelegates(SessionName, false);
+				}
+			};
+
+			EOS_Lobby_DestroyLobby(LobbyHandle, &DestroyOptions, DestroyCallbackObj, DestroyCallbackObj->GetCallbackPtr());
+		}
+		else
+		{
+			// Leave Lobby
+			EOS_Lobby_LeaveLobbyOptions LeaveOptions = { 0 };
+			LeaveOptions.ApiVersion = EOS_LOBBY_LEAVELOBBY_API_LATEST;
+			const FTCHARToUTF8 Utf8LobbyId(*SessionInfo->GetSessionId().ToString());
+			LeaveOptions.LobbyId = (EOS_LobbyId)Utf8LobbyId.Get();
+			LeaveOptions.LocalUserId = EOSSubsystem->UserManager->GetLocalProductUserId(EOSSubsystem->UserManager->GetDefaultLocalUser()); // Maybe not split screen friendly
+
+			FLobbyLeftCallback* LeaveCallbackObj = new FLobbyLeftCallback();
+			LobbyLeftCallback = LeaveCallbackObj;
+			LeaveCallbackObj->CallbackLambda = [this, SessionName, CompletionDelegate](const EOS_Lobby_LeaveLobbyCallbackInfo* Data)
+			{
+				FNamedOnlineSession* LobbySession = GetNamedSession(SessionName);
+				if (LobbySession)
+				{
+					bool bWasSuccessful = Data->ResultCode == EOS_EResult::EOS_Success;
+					if (bWasSuccessful)
+					{
+						UE_LOG_ONLINE_SESSION(Verbose, TEXT("[FOnlineSessionEOS::DestroyLobbySession] LeaveLobby was successful. LobbyId is %s."), Data->LobbyId);
+					}
+					else
+					{
+						UE_LOG_ONLINE_SESSION(Warning, TEXT("[FOnlineSessionEOS::DestroyLobbySession] LeaveLobby not successful. Finished with EOS_EResult %s"), ANSI_TO_TCHAR(EOS_EResult_ToString(Data->ResultCode)));
+					}
+
+#if WITH_EOS_RTC
+					if (FEOSVoiceChatUser* VoiceChatUser = static_cast<FEOSVoiceChatUser*>(EOSSubsystem->GetEOSVoiceChatUserInterface(*EOSSubsystem->UserManager->GetLocalUniqueNetIdEOS())))
+					{
+						VoiceChatUser->RemoveLobbyRoom(UTF8_TO_TCHAR(Data->LobbyId));
+					}
+#endif
+
+					EndSessionAnalytics();
+
+					LobbySession->SessionState = EOnlineSessionState::NoSession;
+
+					RemoveNamedSession(SessionName);
+
+					CompletionDelegate.ExecuteIfBound(SessionName, bWasSuccessful);
+					TriggerOnDestroySessionCompleteDelegates(SessionName, bWasSuccessful);
+				}
+				else
+				{
+					UE_LOG_ONLINE_SESSION(Warning, TEXT("[FOnlineSessionEOS::DestroyLobbySession] Unable to find session %s"), *SessionName.ToString());
+					TriggerOnDestroySessionCompleteDelegates(SessionName, false);
+				}
+			};
+
+			EOS_Lobby_LeaveLobby(LobbyHandle, &LeaveOptions, LeaveCallbackObj, LeaveCallbackObj->GetCallbackPtr());
+		}
+
+		Result = ONLINE_IO_PENDING;
+	}
+
+	return Result;
+}
+
+uint32 FOnlineSessionEOS::FindLobbySession(int32 SearchingPlayerNum, const TSharedRef<FOnlineSessionSearch>& SearchSettings)
+{
+	uint32 Result = ONLINE_FAIL;
+
+	EOS_Lobby_CreateLobbySearchOptions CreateLobbySearchOptions = { 0 };
+	CreateLobbySearchOptions.ApiVersion = EOS_LOBBY_CREATELOBBYSEARCH_API_LATEST;
+	CreateLobbySearchOptions.MaxResults = FMath::Clamp(SearchSettings->MaxSearchResults, 0, EOS_SESSIONS_MAX_SEARCH_RESULTS);
+
+	EOS_HLobbySearch LobbySearchHandle;
+
+	EOS_EResult SearchResult = EOS_Lobby_CreateLobbySearch(LobbyHandle, &CreateLobbySearchOptions, &LobbySearchHandle);
+	if (SearchResult == EOS_EResult::EOS_Success)
+	{
+		// We add the search parameters
+		for (FSearchParams::TConstIterator It(SearchSettings->QuerySettings.SearchParams); It; ++It)
+		{
+			const FName Key = It.Key();
+			const FOnlineSessionSearchParam& SearchParam = It.Value();
+
+			if (!IsSessionSettingTypeSupported(SearchParam.Data.GetType()))
+			{
+				continue;
+			}
+
+			UE_LOG_ONLINE_SESSION(VeryVerbose, TEXT("[FOnlineSessionEOS::FindLobbySession] Adding lobby search param named (%s), (%s)"), *Key.ToString(), *SearchParam.ToString());
+
+			FString ParamName(Key.ToString());
+			FLobbyAttributeOptions Attribute(TCHAR_TO_UTF8(*ParamName), SearchParam.Data);
+			AddLobbySearchAttribute(LobbySearchHandle, &Attribute, ToEOSSearchOp(SearchParam.ComparisonOp));
+		}
+
+		StartLobbySearch(SearchingPlayerNum, LobbySearchHandle, SearchSettings, FOnSingleSessionResultCompleteDelegate::CreateLambda([this](int32 LocalUserNum, bool bWasSuccessful, const FOnlineSessionSearchResult& EOSResult)
+		{
+			TriggerOnFindSessionsCompleteDelegates(bWasSuccessful);
+		}));
+
+		Result = ONLINE_IO_PENDING;
+	}
+	else
+	{
+		UE_LOG_ONLINE_SESSION(Warning, TEXT("[FOnlineSessionEOS::FindLobbySession] CreateLobbySearch not successful. Finished with EOS_EResult %s"), ANSI_TO_TCHAR(EOS_EResult_ToString(SearchResult)));
+	}
+
+	return Result;
+}
+
+void FOnlineSessionEOS::StartLobbySearch(int32 SearchingPlayerNum, EOS_HLobbySearch LobbySearchHandle, const TSharedRef<FOnlineSessionSearch>& SearchSettings, const FOnSingleSessionResultCompleteDelegate& CompletionDelegate)
+{
+	SessionSearchStartInSeconds = FPlatformTime::Seconds();
+
+	EOS_LobbySearch_FindOptions FindOptions = { 0 };
+	FindOptions.ApiVersion = EOS_LOBBYSEARCH_FIND_API_LATEST;
+	FindOptions.LocalUserId = EOSSubsystem->UserManager->GetLocalProductUserId(SearchingPlayerNum);
+
+	FLobbySearchFindCallback* CallbackObj = new FLobbySearchFindCallback();
+	LobbySearchFindCallback = CallbackObj;
+	CallbackObj->CallbackLambda = [this, SearchingPlayerNum, LobbySearchHandle, SearchSettings, CompletionDelegate](const EOS_LobbySearch_FindCallbackInfo* Data)
+	{
+		if (Data->ResultCode == EOS_EResult::EOS_Success)
+		{
+			UE_LOG_ONLINE_SESSION(Log, TEXT("[FOnlineSessionEOS::StartLobbySearch] LobbySearch_Find was successful."));
+
+			LobbySearchResultsCache.Reset();
+
+			CurrentSessionSearch->SearchState = EOnlineAsyncTaskState::Done;
+
+			EOS_LobbySearch_GetSearchResultCountOptions GetSearchResultCountOptions = { 0 };
+			GetSearchResultCountOptions.ApiVersion = EOS_LOBBYSEARCH_GETSEARCHRESULTCOUNT_API_LATEST;
+
+			uint32_t SearchResultsCount = EOS_LobbySearch_GetSearchResultCount(LobbySearchHandle, &GetSearchResultCountOptions);
+
+			if (SearchResultsCount > 0)
+			{
+				EOS_LobbySearch_CopySearchResultByIndexOptions CopySearchResultByIndexOptions = { 0 };
+				CopySearchResultByIndexOptions.ApiVersion = EOS_LOBBYSEARCH_COPYSEARCHRESULTBYINDEX_API_LATEST;
+
+				for (uint32_t LobbyIndex = 0; LobbyIndex < SearchResultsCount; LobbyIndex++)
+				{
+					EOS_HLobbyDetails LobbyDetailsHandle;
+
+					CopySearchResultByIndexOptions.LobbyIndex = LobbyIndex;
+
+					EOS_EResult Result = EOS_LobbySearch_CopySearchResultByIndex(LobbySearchHandle, &CopySearchResultByIndexOptions, &LobbyDetailsHandle);
+					if (Result == EOS_EResult::EOS_Success)
+					{
+						UE_LOG_ONLINE_SESSION(Verbose, TEXT("[FOnlineSessionEOS::StartLobbySearch::FLobbySearchFindCallback] LobbySearch_CopySearchResultByIndex was successful."));
+
+						AddLobbySearchResult(LobbyDetailsHandle, SearchSettings);
+					}
+					else
+					{
+						UE_LOG_ONLINE_SESSION(Warning, TEXT("[FOnlineSessionEOS::StartLobbySearch::FLobbySearchFindCallback] LobbySearch_CopySearchResultByIndex not successful. Finished with EOS_EResult %s"), ANSI_TO_TCHAR(EOS_EResult_ToString(Data->ResultCode)));
+					}
+				}
+
+				CompletionDelegate.ExecuteIfBound(SearchingPlayerNum, true, SearchSettings->SearchResults.Last());
+			}
+			else
+			{
+				UE_LOG_ONLINE_SESSION(Log, TEXT("[FOnlineSessionEOS::StartLobbySearch::FLobbySearchFindCallback] LobbySearch_GetSearchResultCount returned no results"));
+
+				CompletionDelegate.ExecuteIfBound(SearchingPlayerNum, true, FOnlineSessionSearchResult());
+			}
+		}
+		else
+		{
+			UE_LOG_ONLINE_SESSION(Warning, TEXT("[FOnlineSessionEOS::StartLobbySearch::FLobbySearchFindCallback] LobbySearch_Find not successful. Finished with EOS_EResult %s"), ANSI_TO_TCHAR(EOS_EResult_ToString(Data->ResultCode)));
+
+			CurrentSessionSearch->SearchState = EOnlineAsyncTaskState::Failed;
+
+			CompletionDelegate.ExecuteIfBound(SearchingPlayerNum, false, FOnlineSessionSearchResult());
+		}
+
+		EOS_LobbySearch_Release(LobbySearchHandle);
+	};
+
+	EOS_LobbySearch_Find(LobbySearchHandle, &FindOptions, CallbackObj, CallbackObj->GetCallbackPtr());
+}
+
+void FOnlineSessionEOS::AddLobbySearchResult(EOS_HLobbyDetails LobbyDetailsHandle, const TSharedRef<FOnlineSessionSearch>& SearchSettings)
+{
+	EOS_LobbyDetails_Info* LobbyDetailsInfo = nullptr;
+	EOS_LobbyDetails_CopyInfoOptions CopyOptions = { };
+	CopyOptions.ApiVersion = EOS_LOBBYDETAILS_COPYINFO_API_LATEST;
+	EOS_EResult CopyResult = EOS_LobbyDetails_CopyInfo(LobbyDetailsHandle, &CopyOptions, &LobbyDetailsInfo);
+	if (CopyResult == EOS_EResult::EOS_Success)
+	{
+		int32 Position = SearchSettings->SearchResults.AddZeroed();
+		FOnlineSessionSearchResult& SearchResult = SearchSettings->SearchResults[Position];
+		SearchResult.PingInMs = static_cast<int32>((FPlatformTime::Seconds() - SessionSearchStartInSeconds) * 1000);
+		
+		// This will set the host address and port
+		// Because some platforms remap ports, we will use the ID of the name of the net driver to be our port instead
+		FName NetDriverName = GetDefault<UNetDriverEOS>()->NetDriverName;
+		FInternetAddrEOS TempAddr(LexToString(LobbyDetailsInfo->LobbyOwnerUserId), NetDriverName.ToString(), GetTypeHash(NetDriverName.ToString()));
+		FString HostAddr = TempAddr.ToString(true);
+
+		SearchResult.Session.SessionInfo = MakeShareable(new FOnlineSessionInfoEOS(HostAddr, LobbyDetailsInfo->LobbyId, nullptr));
+
+		// We copy the lobby data and settings
+		CopyLobbyData(LobbyDetailsHandle, LobbyDetailsInfo, SearchResult.Session);
+
+		// Then we copy the settings for all lobby members
+		EOS_LobbyDetails_GetMemberCountOptions CountOptions = { };
+		CountOptions.ApiVersion = EOS_LOBBYDETAILS_GETMEMBERCOUNT_API_LATEST;
+		int32 Count = EOS_LobbyDetails_GetMemberCount(LobbyDetailsHandle, &CountOptions);
+
+		for (int32 Index = 0; Index < Count; Index++)
+		{
+			EOS_LobbyDetails_GetMemberByIndexOptions GetMemberByIndexOptions = { };
+			GetMemberByIndexOptions.ApiVersion = EOS_LOBBYDETAILS_GETMEMBERBYINDEX_API_LATEST;
+			GetMemberByIndexOptions.MemberIndex = Index;
+
+			EOS_ProductUserId TargetUserId = EOS_LobbyDetails_GetMemberByIndex(LobbyDetailsHandle, &GetMemberByIndexOptions);
+
+			EOSSubsystem->UserManager->GetEpicAccountIdAsync(TargetUserId, [this, LobbyDetailsHandle, &SearchResult](const EOS_ProductUserId& ProductUserId, EOS_EpicAccountId& EpicAccountId)
+				{
+					FUniqueNetIdPtr UniqueNetId = EOSSubsystem->UserManager->CreateUniquePlayerId(MakeNetIdStringFromIds(EpicAccountId, ProductUserId));
+
+					if (!SearchResult.Session.SessionSettings.MemberSettings.Contains(UniqueNetId->AsShared()))
+					{
+						SearchResult.Session.SessionSettings.MemberSettings.Add(UniqueNetId->AsShared(), FSessionSettings());
+					}
+
+					CopyLobbyMemberAttributes(LobbyDetailsHandle, ProductUserId, SearchResult.Session.SessionSettings.MemberSettings[UniqueNetId->AsShared()]);
+				});
+		}
+
+		LobbySearchResultsCache.Add(FString(LobbyDetailsInfo->LobbyId), MakeShared<EOS_HLobbyDetails>(LobbyDetailsHandle));
+
+		EOS_LobbyDetails_Info_Release(LobbyDetailsInfo);
+
+		// We don't release the details handle here, because we'll use it for the join operation
+	}
+	else
+	{
+		UE_LOG_ONLINE_SESSION(Warning, TEXT("[FOnlineSessionEOS::AddLobbySearchResult] LobbyDetails_CopyInfo not successful. Finished with EOS_EResult %s"), ANSI_TO_TCHAR(EOS_EResult_ToString(CopyResult)));
+
+		EOS_LobbyDetails_Release(LobbyDetailsHandle);
+	}
+}
+
+void FOnlineSessionEOS::CopyLobbyData(EOS_HLobbyDetails LobbyDetailsHandle, EOS_LobbyDetails_Info* LobbyDetailsInfo, FOnlineSession& OutSession)
+{
+	OutSession.SessionSettings.bUseLobbiesIfAvailable = true;
+	OutSession.SessionSettings.bIsLANMatch = false;
+#if WITH_EOS_RTC
+	OutSession.SessionSettings.bUseLobbiesVoiceChatIfAvailable = LobbyDetailsInfo->bRTCRoomEnabled == EOS_TRUE;
+#endif
+
+	switch (LobbyDetailsInfo->PermissionLevel)
+	{
+	case EOS_ELobbyPermissionLevel::EOS_LPL_PUBLICADVERTISED:
+	case EOS_ELobbyPermissionLevel::EOS_LPL_JOINVIAPRESENCE:
+		OutSession.SessionSettings.bUsesPresence = true;
+		OutSession.SessionSettings.bAllowJoinViaPresence = true;
+
+		OutSession.SessionSettings.NumPublicConnections = LobbyDetailsInfo->MaxMembers;
+		OutSession.NumOpenPublicConnections = LobbyDetailsInfo->AvailableSlots;
+
+		break;
+	case EOS_ELobbyPermissionLevel::EOS_LPL_INVITEONLY:
+		OutSession.SessionSettings.bUsesPresence = false;
+		OutSession.SessionSettings.bAllowJoinViaPresence = false;
+
+		OutSession.SessionSettings.NumPrivateConnections = LobbyDetailsInfo->MaxMembers;
+		OutSession.NumOpenPrivateConnections = LobbyDetailsInfo->AvailableSlots;
+
+		break;
+	}
+
+	OutSession.SessionSettings.bAllowInvites = (bool)LobbyDetailsInfo->bAllowInvites;
+
+	CopyLobbyAttributes(LobbyDetailsHandle, OutSession);
+}
+
+void FOnlineSessionEOS::CopyLobbyAttributes(EOS_HLobbyDetails LobbyDetailsHandle, FOnlineSession& OutSession)
+{
+	// In this method we are updating/adding attributes, but not removing
+
+	EOS_LobbyDetails_GetAttributeCountOptions CountOptions = { };
+	CountOptions.ApiVersion = EOS_LOBBYDETAILS_GETATTRIBUTECOUNT_API_LATEST;
+	int32 Count = EOS_LobbyDetails_GetAttributeCount(LobbyDetailsHandle, &CountOptions);
+
+	for (int32 Index = 0; Index < Count; Index++)
+	{
+		EOS_LobbyDetails_CopyAttributeByIndexOptions AttrOptions = { };
+		AttrOptions.ApiVersion = EOS_LOBBYDETAILS_COPYATTRIBUTEBYINDEX_API_LATEST;
+		AttrOptions.AttrIndex = Index;
+
+		EOS_Lobby_Attribute* Attribute = NULL;
+		EOS_EResult ResultCode = EOS_LobbyDetails_CopyAttributeByIndex(LobbyDetailsHandle, &AttrOptions, &Attribute);
+		if (ResultCode == EOS_EResult::EOS_Success)
+		{
+			FString Key = UTF8_TO_TCHAR(Attribute->Data->Key);
+			if (Key == TEXT("OwningUserId"))
+			{
+				OutSession.OwningUserId = FUniqueNetIdEOS::Create(UTF8_TO_TCHAR(Attribute->Data->Value.AsUtf8));
+			}
+			else if (Key == TEXT("OwningUserName"))
+			{
+				OutSession.OwningUserName = UTF8_TO_TCHAR(Attribute->Data->Value.AsUtf8);
+			}
+			else if (Key == TEXT("NumPublicConnections"))
+			{
+				OutSession.SessionSettings.NumPublicConnections = Attribute->Data->Value.AsInt64;
+			}
+			else if (Key == TEXT("NumPrivateConnections"))
+			{
+				OutSession.SessionSettings.NumPrivateConnections = Attribute->Data->Value.AsInt64;
+			}
+			else if (Key == TEXT("bAntiCheatProtected"))
+			{
+				OutSession.SessionSettings.bAntiCheatProtected = Attribute->Data->Value.AsBool == EOS_TRUE;
+			}
+			else if (Key == TEXT("bUsesStats"))
+			{
+				OutSession.SessionSettings.bUsesStats = Attribute->Data->Value.AsBool == EOS_TRUE;
+			}
+			else if (Key == TEXT("bIsDedicated"))
+			{
+				OutSession.SessionSettings.bIsDedicated = Attribute->Data->Value.AsBool == EOS_TRUE;
+			}
+			else if (Key == TEXT("BuildUniqueId"))
+			{
+				OutSession.SessionSettings.BuildUniqueId = Attribute->Data->Value.AsInt64;
+			}
+			// Handle FSessionSettings
+			else
+			{
+				FOnlineSessionSetting Setting;
+				switch (Attribute->Data->ValueType)
+				{
+				case EOS_ESessionAttributeType::EOS_SAT_Boolean:
+				{
+					Setting.Data.SetValue(Attribute->Data->Value.AsBool == EOS_TRUE);
+					break;
+				}
+				case EOS_ESessionAttributeType::EOS_SAT_Int64:
+				{
+					Setting.Data.SetValue(int64(Attribute->Data->Value.AsInt64));
+					break;
+				}
+				case EOS_ESessionAttributeType::EOS_SAT_Double:
+				{
+					Setting.Data.SetValue(Attribute->Data->Value.AsDouble);
+					break;
+				}
+				case EOS_ESessionAttributeType::EOS_SAT_String:
+				{
+					Setting.Data.SetValue(ANSI_TO_TCHAR(Attribute->Data->Value.AsUtf8));
+					break;
+				}
+				}
+
+				OutSession.SessionSettings.Settings.FindOrAdd(FName(Key), Setting);
+			}
+		}
+
+		EOS_Lobby_Attribute_Release(Attribute);
+	}
+}
+
+void FOnlineSessionEOS::CopyLobbyMemberAttributes(EOS_HLobbyDetails LobbyDetailsHandle, const EOS_ProductUserId& TargetUserId, FSessionSettings& OutSessionSettings)
+{
+	// In this method we are updating/adding attributes, but not removing
+
+	EOS_LobbyDetails_GetMemberAttributeCountOptions GetMemberAttributeCountOptions = {};
+	GetMemberAttributeCountOptions.ApiVersion = EOS_LOBBYDETAILS_GETMEMBERATTRIBUTECOUNT_API_LATEST;
+	GetMemberAttributeCountOptions.TargetUserId = TargetUserId;
+
+	uint32_t MemberAttributeCount = EOS_LobbyDetails_GetMemberAttributeCount(LobbyDetailsHandle, &GetMemberAttributeCountOptions);
+	for (uint32_t MemberAttributeIndex = 0; MemberAttributeIndex < MemberAttributeCount; MemberAttributeIndex++)
+	{
+		EOS_LobbyDetails_CopyMemberAttributeByIndexOptions AttrOptions = { };
+		AttrOptions.ApiVersion = EOS_LOBBYDETAILS_COPYMEMBERATTRIBUTEBYINDEX_API_LATEST;
+		AttrOptions.AttrIndex = MemberAttributeIndex;
+
+		EOS_Lobby_Attribute* Attribute = NULL;
+		EOS_EResult ResultCode = EOS_LobbyDetails_CopyMemberAttributeByIndex(LobbyDetailsHandle, &AttrOptions, &Attribute);
+		if (ResultCode == EOS_EResult::EOS_Success)
+		{
+			FString Key = Attribute->Data->Key;
+
+			FOnlineSessionSetting Setting;
+			switch (Attribute->Data->ValueType)
+			{
+			case EOS_ESessionAttributeType::EOS_SAT_Boolean:
+			{
+				Setting.Data.SetValue(Attribute->Data->Value.AsBool == EOS_TRUE);
+				break;
+			}
+			case EOS_ESessionAttributeType::EOS_SAT_Int64:
+			{
+				Setting.Data.SetValue(int64(Attribute->Data->Value.AsInt64));
+				break;
+			}
+			case EOS_ESessionAttributeType::EOS_SAT_Double:
+			{
+				Setting.Data.SetValue(Attribute->Data->Value.AsDouble);
+				break;
+			}
+			case EOS_ESessionAttributeType::EOS_SAT_String:
+			{
+				Setting.Data.SetValue(ANSI_TO_TCHAR(Attribute->Data->Value.AsUtf8));
+				break;
+			}
+			}
+
+			if (OutSessionSettings.Contains(FName(Key)))
+			{
+				OutSessionSettings[FName(Key)] = Setting;
+			}
+			else
+			{
+				OutSessionSettings.Add(FName(Key), Setting);
+			}
+		}
+	}
+}
+
+#endif
Index: Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Private/InternetAddrEOS.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Private/InternetAddrEOS.cpp b/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Private/InternetAddrEOS.cpp
new file mode 100644
--- /dev/null	(date 1641576012000)
+++ b/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Private/InternetAddrEOS.cpp	(date 1641576012000)
@@ -0,0 +1,184 @@
+// Copyright Epic Games, Inc. All Rights Reserved.
+
+#include "InternetAddrEOS.h"
+#include "Online/CoreOnline.h"
+#include "OnlineSubsystemEOSTypes.h"
+#include "Containers/StringView.h"
+
+DEFINE_LOG_CATEGORY(LogSocketSubsystemEOS);
+
+inline uint8 PortToChannel(int32 InPort)
+{
+	return InPort > 255 ? InPort % 256 : FMath::Clamp(InPort, 0, 255);
+}
+
+FInternetAddrEOS::FInternetAddrEOS()
+	: LocalUserId(nullptr)
+	, RemoteUserId(nullptr)
+	, Channel(0)
+{
+	SocketName[0] = '\0';
+}
+
+FInternetAddrEOS::FInternetAddrEOS(const FString& InRemoteUserId, const FString& InSocketName, const int32 InChannel)
+	: LocalUserId(nullptr)
+	, RemoteUserId(nullptr)
+{
+#if WITH_EOS_SDK
+	RemoteUserId = EOS_ProductUserId_FromString(TCHAR_TO_UTF8(*InRemoteUserId));
+#endif
+	FCStringAnsi::Strcpy(SocketName, TCHAR_TO_UTF8(*InSocketName));
+	Channel = PortToChannel(InChannel);
+}
+
+#if WITH_EOS_SDK
+FInternetAddrEOS::FInternetAddrEOS(const EOS_ProductUserId InRemoteUserId, const FString& InSocketName, const int32 InChannel)
+	: LocalUserId(nullptr)
+	, RemoteUserId(InRemoteUserId)
+	, Channel(InChannel)
+{
+	FCStringAnsi::Strcpy(SocketName, TCHAR_TO_UTF8(*InSocketName));
+	Channel = PortToChannel(InChannel);
+}
+#endif
+
+void FInternetAddrEOS::SetIp(uint32)
+{
+	UE_LOG(LogSocketSubsystemEOS, Warning, TEXT("Calls to FInternetAddrEOS::SetIp are not valid"));
+}
+
+void FInternetAddrEOS::SetIp(const TCHAR* InAddr, bool& bIsValid)
+{
+	bIsValid = false;
+
+	if (InAddr == nullptr)
+	{
+		return;
+	}
+
+	Channel = 0;
+
+	TArray<FString> UrlParts;
+	FString FullAddress = InAddr;
+	FullAddress.ParseIntoArray(UrlParts, EOS_URL_SEPARATOR, false);
+	// Expect URLs to look like "EOS:PUID:SocketName:Channel" and channel can be optional
+	if (UrlParts.Num() < 3 || UrlParts.Num() > 4)
+	{
+		return;
+	}
+	if (UrlParts[0] != EOS_CONNECTION_URL_PREFIX)
+	{
+		return;
+	}
+#if WITH_EOS_SDK
+	RemoteUserId = EOS_ProductUserId_FromString(TCHAR_TO_UTF8(*UrlParts[1]));
+	if (EOS_ProductUserId_IsValid(RemoteUserId) == EOS_FALSE)
+#endif
+	{
+		return;
+	}
+	if (UrlParts[2].Len() == 0)
+	{
+		return;
+	}
+	SetSocketName(UrlParts[2]);
+	if (UrlParts.Num() == 4)
+	{
+		Channel = FCString::Atoi(*UrlParts[3]);
+	}
+	bIsValid = true;
+}
+
+void FInternetAddrEOS::GetIp(uint32& OutAddr) const
+{
+	OutAddr = 0u;
+
+	UE_LOG(LogSocketSubsystemEOS, Warning, TEXT("Calls to FInternetAddrEOS::GetIp are not valid"));
+}
+
+void FInternetAddrEOS::SetPort(int32 InPort)
+{
+	Channel = PortToChannel(InPort);
+}
+
+int32 FInternetAddrEOS::GetPort() const
+{
+	return Channel;
+}
+
+void FInternetAddrEOS::SetRawIp(const TArray<uint8>& RawAddr)
+{
+	// Need auto here, as might give us different return type depending on size of TCHAR
+	auto ConvertedTCHARData = StringCast<TCHAR>(reinterpret_cast<const ANSICHAR*>(RawAddr.GetData()), RawAddr.Num());
+	const FString IpAsString(ConvertedTCHARData.Length(), ConvertedTCHARData.Get());
+
+	bool bUnused;
+	SetIp(*IpAsString, bUnused);
+}
+
+TArray<uint8> FInternetAddrEOS::GetRawIp() const
+{
+	// We could do this more efficiently, but this was much faster to write.
+	const FString StringVersion = ToString(true);
+
+	// Need auto here, as might give us different return type depending on size of TCHAR
+	auto ConvertedANSIData = StringCast<ANSICHAR>(*StringVersion, StringVersion.Len());
+
+	TArray<uint8> OutData;
+	for (int32 Index = 0; Index < ConvertedANSIData.Length(); ++Index)
+	{
+		OutData.Add(ConvertedANSIData.Get()[Index]);
+	}
+
+	return OutData;
+}
+
+void FInternetAddrEOS::SetAnyAddress()
+{
+}
+
+void FInternetAddrEOS::SetBroadcastAddress()
+{
+}
+
+void FInternetAddrEOS::SetLoopbackAddress()
+{
+}
+
+FString FInternetAddrEOS::ToString(bool bAppendPort) const
+{
+	char PuidBuffer[64];
+	int32 BufferLen = 64;
+#if WITH_EOS_SDK
+	if (EOS_ProductUserId_ToString(RemoteUserId, PuidBuffer, &BufferLen) != EOS_EResult::EOS_Success)
+#endif
+	{
+		PuidBuffer[0] = '\0';
+	}
+
+	if (bAppendPort)
+	{
+		return FString::Printf(TEXT("%s%s%s%s%s%s%u"), EOS_CONNECTION_URL_PREFIX, EOS_URL_SEPARATOR, UTF8_TO_TCHAR(PuidBuffer), EOS_URL_SEPARATOR, UTF8_TO_TCHAR(SocketName), EOS_URL_SEPARATOR, Channel);
+	}
+
+	return FString::Printf(TEXT("%s%s%s%s%s"), EOS_CONNECTION_URL_PREFIX, EOS_URL_SEPARATOR, UTF8_TO_TCHAR(PuidBuffer), EOS_URL_SEPARATOR, UTF8_TO_TCHAR(SocketName));
+}
+
+uint32 FInternetAddrEOS::GetTypeHash() const
+{
+	return HashCombine(HashCombine(HashCombine(::GetTypeHash((void*)LocalUserId), ::GetTypeHash((void*)RemoteUserId)), ::GetTypeHash(FAnsiStringView(SocketName, EOS_SOCKET_NAME_SIZE))), Channel);
+}
+
+bool FInternetAddrEOS::IsValid() const
+{
+#if WITH_EOS_SDK
+	return (EOS_ProductUserId_IsValid(LocalUserId) == EOS_TRUE || EOS_ProductUserId_IsValid(RemoteUserId) == EOS_TRUE) && FCStringAnsi::Strlen(SocketName) > 0;
+#else
+	return false;
+#endif
+}
+
+TSharedRef<FInternetAddr> FInternetAddrEOS::Clone() const
+{
+	return MakeShared<FInternetAddrEOS>(*this);
+}
Index: Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Private/EOSSettings.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Private/EOSSettings.cpp b/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Private/EOSSettings.cpp
new file mode 100644
--- /dev/null	(date 1641576012000)
+++ b/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Private/EOSSettings.cpp	(date 1641576012000)
@@ -0,0 +1,401 @@
+// Copyright Epic Games, Inc. All Rights Reserved.
+
+#include "EOSSettings.h"
+#include "OnlineSubsystemEOS.h"
+#include "OnlineSubsystemEOSModule.h"
+
+#include "Algo/Transform.h"
+#include "Misc/CommandLine.h"
+#include "Misc/ConfigCacheIni.h"
+
+#if WITH_EDITOR
+	#include "Misc/MessageDialog.h"
+#endif
+
+#define LOCTEXT_NAMESPACE "EOS"
+
+#define INI_SECTION TEXT("/Script/OnlineSubsystemEOS.EOSSettings")
+
+inline bool IsAnsi(const FString& Source)
+{
+	for (const TCHAR& IterChar : Source)
+	{
+		if (!FChar::IsPrint(IterChar))
+		{
+			return false;
+		}
+	}
+	return true;
+}
+
+inline bool IsHex(const FString& Source)
+{
+	for (const TCHAR& IterChar : Source)
+	{
+		if (!FChar::IsHexDigit(IterChar))
+		{
+			return false;
+		}
+	}
+	return true;
+}
+
+inline bool ContainsWhitespace(const FString& Source)
+{
+	for (const TCHAR& IterChar : Source)
+	{
+		if (FChar::IsWhitespace(IterChar))
+		{
+			return true;
+		}
+	}
+	return false;
+}
+
+FEOSArtifactSettings FArtifactSettings::ToNative() const
+{
+	FEOSArtifactSettings Native;
+
+	Native.ArtifactName = ArtifactName;
+	Native.ClientId = ClientId;
+	Native.ClientSecret = ClientSecret;
+	Native.DeploymentId = DeploymentId;
+	Native.EncryptionKey = EncryptionKey;
+	Native.ProductId = ProductId;
+	Native.SandboxId = SandboxId;
+
+	return Native;
+}
+
+inline FString StripQuotes(const FString& Source)
+{
+	if (Source.StartsWith(TEXT("\"")))
+	{
+		return Source.Mid(1, Source.Len() - 2);
+	}
+	return Source;
+}
+
+void FEOSArtifactSettings::ParseRawArrayEntry(const FString& RawLine)
+{
+	const TCHAR* Delims[4] = { TEXT("("), TEXT(")"), TEXT("="), TEXT(",") };
+	TArray<FString> Values;
+	RawLine.ParseIntoArray(Values, Delims, 4, false);
+	for (int32 ValueIndex = 0; ValueIndex < Values.Num(); ValueIndex++)
+	{
+		if (Values[ValueIndex].IsEmpty())
+		{
+			continue;
+		}
+
+		// Parse which struct field
+		if (Values[ValueIndex] == TEXT("ArtifactName"))
+		{
+			ArtifactName = StripQuotes(Values[ValueIndex + 1]);
+		}
+		else if (Values[ValueIndex] == TEXT("ClientId"))
+		{
+			ClientId = StripQuotes(Values[ValueIndex + 1]);
+		}
+		else if (Values[ValueIndex] == TEXT("ClientSecret"))
+		{
+			ClientSecret = StripQuotes(Values[ValueIndex + 1]);
+		}
+		else if (Values[ValueIndex] == TEXT("ProductId"))
+		{
+			ProductId = StripQuotes(Values[ValueIndex + 1]);
+		}
+		else if (Values[ValueIndex] == TEXT("SandboxId"))
+		{
+			SandboxId = StripQuotes(Values[ValueIndex + 1]);
+		}
+		else if (Values[ValueIndex] == TEXT("DeploymentId"))
+		{
+			DeploymentId = StripQuotes(Values[ValueIndex + 1]);
+		}
+		else if (Values[ValueIndex] == TEXT("EncryptionKey"))
+		{
+			EncryptionKey = StripQuotes(Values[ValueIndex + 1]);
+		}
+		ValueIndex++;
+	}
+}
+
+FEOSSettings UEOSSettings::GetSettings()
+{
+	if (UObjectInitialized())
+	{
+		return UEOSSettings::AutoGetSettings();
+	}
+
+	return UEOSSettings::ManualGetSettings();
+}
+
+FEOSSettings UEOSSettings::AutoGetSettings()
+{
+	return GetDefault<UEOSSettings>()->ToNative();
+}
+
+const FEOSSettings& UEOSSettings::ManualGetSettings()
+{
+	static TOptional<FEOSSettings> CachedSettings;
+
+	if (!CachedSettings.IsSet())
+	{
+		CachedSettings.Emplace();
+
+		GConfig->GetString(INI_SECTION, TEXT("CacheDir"), CachedSettings->CacheDir, GEngineIni);
+		GConfig->GetString(INI_SECTION, TEXT("DefaultArtifactName"), CachedSettings->DefaultArtifactName, GEngineIni);
+		GConfig->GetInt(INI_SECTION, TEXT("TickBudgetInMilliseconds"), CachedSettings->TickBudgetInMilliseconds, GEngineIni);
+		GConfig->GetInt(INI_SECTION, TEXT("TitleStorageReadChunkLength"), CachedSettings->TitleStorageReadChunkLength, GEngineIni);
+		GConfig->GetBool(INI_SECTION, TEXT("bEnableOverlay"), CachedSettings->bEnableOverlay, GEngineIni);
+		GConfig->GetBool(INI_SECTION, TEXT("bEnableSocialOverlay"), CachedSettings->bEnableSocialOverlay, GEngineIni);
+		GConfig->GetBool(INI_SECTION, TEXT("bShouldEnforceBeingLaunchedByEGS"), CachedSettings->bShouldEnforceBeingLaunchedByEGS, GEngineIni);
+		GConfig->GetBool(INI_SECTION, TEXT("bUseEAS"), CachedSettings->bUseEAS, GEngineIni);
+		GConfig->GetBool(INI_SECTION, TEXT("bUseEOSConnect"), CachedSettings->bUseEOSConnect, GEngineIni);
+		GConfig->GetBool(INI_SECTION, TEXT("bUseEOSSessions"), CachedSettings->bUseEOSSessions, GEngineIni);
+		GConfig->GetBool(INI_SECTION, TEXT("bMirrorStatsToEOS"), CachedSettings->bMirrorStatsToEOS, GEngineIni);
+		GConfig->GetBool(INI_SECTION, TEXT("bMirrorAchievementsToEOS"), CachedSettings->bMirrorAchievementsToEOS, GEngineIni);
+		GConfig->GetBool(INI_SECTION, TEXT("bMirrorPresenceToEAS"), CachedSettings->bMirrorPresenceToEAS, GEngineIni);
+		// Artifacts explicitly skipped
+		GConfig->GetArray(INI_SECTION, TEXT("TitleStorageTags"), CachedSettings->TitleStorageTags, GEngineIni);
+	}
+
+	return *CachedSettings;
+}
+
+FEOSSettings UEOSSettings::ToNative() const
+{
+	FEOSSettings Native;
+
+	Native.CacheDir = CacheDir;
+	Native.DefaultArtifactName = DefaultArtifactName;
+	Native.TickBudgetInMilliseconds = TickBudgetInMilliseconds;
+	Native.TitleStorageReadChunkLength = TitleStorageReadChunkLength;
+	Native.bEnableOverlay = bEnableOverlay;
+	Native.bEnableSocialOverlay = bEnableSocialOverlay;
+	Native.bShouldEnforceBeingLaunchedByEGS = bShouldEnforceBeingLaunchedByEGS;
+	Native.bUseEAS = bUseEAS;
+	Native.bUseEOSConnect = bUseEOSConnect;
+	Native.bUseEOSSessions = bUseEOSSessions;
+	Native.bMirrorStatsToEOS = bMirrorStatsToEOS;
+	Native.bMirrorAchievementsToEOS = bMirrorAchievementsToEOS;
+	Native.bMirrorPresenceToEAS = bMirrorPresenceToEAS;
+	Algo::Transform(Artifacts, Native.Artifacts, &FArtifactSettings::ToNative);
+	Native.TitleStorageTags = TitleStorageTags;
+
+	return Native;
+}
+
+bool UEOSSettings::GetSettingsForArtifact(const FString& ArtifactName, FEOSArtifactSettings& OutSettings)
+{
+	if (UObjectInitialized())
+	{
+		return UEOSSettings::AutoGetSettingsForArtifact(ArtifactName, OutSettings);
+	}
+	return UEOSSettings::ManualGetSettingsForArtifact(ArtifactName, OutSettings);
+}
+
+bool UEOSSettings::ManualGetSettingsForArtifact(const FString& ArtifactName, FEOSArtifactSettings& OutSettings)
+{
+	static TOptional<FString> CachedDefaultArtifactName;
+	static TOptional<TArray<FEOSArtifactSettings>> CachedArtifactSettings;
+
+	if (!CachedDefaultArtifactName.IsSet())
+	{
+		CachedDefaultArtifactName.Emplace();
+
+		GConfig->GetString(INI_SECTION, TEXT("DefaultArtifactName"), *CachedDefaultArtifactName, GEngineIni);
+	}
+
+	if (!CachedArtifactSettings.IsSet())
+	{
+		CachedArtifactSettings.Emplace();
+
+		TArray<FString> Artifacts;
+		GConfig->GetArray(INI_SECTION, TEXT("Artifacts"), Artifacts, GEngineIni);
+		for (const FString& Line : Artifacts)
+		{
+			FEOSArtifactSettings Artifact;
+			Artifact.ParseRawArrayEntry(Line);
+			CachedArtifactSettings->Add(Artifact);
+		}
+	}
+
+	FString ArtifactNameOverride;
+	// Figure out which config object we are loading
+	FParse::Value(FCommandLine::Get(), TEXT("EOSArtifactNameOverride="), ArtifactNameOverride);
+	if (ArtifactNameOverride.IsEmpty())
+	{
+		ArtifactNameOverride = ArtifactName;
+	}
+
+	// Search by name and then default if not found
+	for (const FEOSArtifactSettings& Artifact : *CachedArtifactSettings)
+	{
+		if (Artifact.ArtifactName == ArtifactNameOverride)
+		{
+			OutSettings = Artifact;
+			return true;
+		}
+	}
+
+	for (const FEOSArtifactSettings& Artifact : *CachedArtifactSettings)
+	{
+		if (Artifact.ArtifactName == *CachedDefaultArtifactName)
+		{
+			OutSettings = Artifact;
+			return true;
+		}
+	}
+
+	return false;
+}
+
+bool UEOSSettings::AutoGetSettingsForArtifact(const FString& ArtifactName, FEOSArtifactSettings& OutSettings)
+{
+	const UEOSSettings* This = GetDefault<UEOSSettings>();
+	FString ArtifactNameOverride;
+	// Figure out which config object we are loading
+	FParse::Value(FCommandLine::Get(), TEXT("EOSArtifactNameOverride="), ArtifactNameOverride);
+	if (ArtifactNameOverride.IsEmpty())
+	{
+		ArtifactNameOverride = ArtifactName;
+	}
+	for (const FArtifactSettings& Artifact : This->Artifacts)
+	{
+		if (Artifact.ArtifactName == ArtifactNameOverride)
+		{
+			OutSettings = Artifact.ToNative();
+			return true;
+		}
+	}
+	for (const FArtifactSettings& Artifact : This->Artifacts)
+	{
+		if (Artifact.ArtifactName == This->DefaultArtifactName)
+		{
+			OutSettings = Artifact.ToNative();
+			return true;
+		}
+	}
+	UE_LOG_ONLINE(Error, TEXT("UEOSSettings::AutoGetSettingsForArtifact() failed due to missing config object specified. Check your project settings"));
+	return false;
+}
+
+#if WITH_EDITOR
+void UEOSSettings::PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent)
+{
+	if (PropertyChangedEvent.Property == nullptr)
+	{
+		Super::PostEditChangeProperty(PropertyChangedEvent);
+		return;
+	}
+
+	// Turning off the overlay in general turns off the social overlay too
+	if (PropertyChangedEvent.Property->GetFName() == FName(TEXT("bEnableOverlay")))
+	{
+		if (!bEnableOverlay)
+		{
+			bEnableSocialOverlay = false;
+		}
+	}
+
+	// Turning on the social overlay requires the base overlay too
+	if (PropertyChangedEvent.Property->GetFName() == FName(TEXT("bEnableSocialOverlay")))
+	{
+		if (bEnableSocialOverlay)
+		{
+			bEnableOverlay = true;
+		}
+	}
+
+	if (PropertyChangedEvent.MemberProperty != nullptr &&
+		PropertyChangedEvent.MemberProperty->GetFName() == FName(TEXT("Artifacts")) &&
+		(PropertyChangedEvent.ChangeType & EPropertyChangeType::ValueSet))
+	{
+		// Loop through all entries validating them
+		for (FArtifactSettings& Artifact : Artifacts)
+		{
+			if (!Artifact.ClientId.IsEmpty())
+			{
+				if (!Artifact.ClientId.StartsWith(TEXT("xyz")))
+				{
+					FMessageDialog::Open(EAppMsgType::Ok,
+						LOCTEXT("ClientIdInvalidMsg", "Client ids created after SDK version 1.5 start with xyz. Double check that you did not use your BPT Client Id instead."));
+				}
+				if (!IsAnsi(Artifact.ClientId) || ContainsWhitespace(Artifact.ClientId))
+				{
+					FMessageDialog::Open(EAppMsgType::Ok,
+						LOCTEXT("ClientIdNotAnsiMsg", "Client ids must contain ANSI printable characters only with no whitespace"));
+					Artifact.ClientId.Empty();
+				}
+			}
+
+			if (!Artifact.ClientSecret.IsEmpty())
+			{
+				if (!IsAnsi(Artifact.ClientSecret) || ContainsWhitespace(Artifact.ClientSecret))
+				{
+					FMessageDialog::Open(EAppMsgType::Ok,
+						LOCTEXT("ClientSecretNotAnsiMsg", "ClientSecret must contain ANSI printable characters only with no whitespace"));
+					Artifact.ClientSecret.Empty();
+				}
+			}
+
+			if (!Artifact.EncryptionKey.IsEmpty())
+			{
+				if (!IsHex(Artifact.EncryptionKey) || Artifact.EncryptionKey.Len() != 64)
+				{
+					FMessageDialog::Open(EAppMsgType::Ok,
+						LOCTEXT("EncryptionKeyNotHexMsg", "EncryptionKey must contain 64 hex characters"));
+					Artifact.EncryptionKey.Empty();
+				}
+			}
+		}
+	}
+
+	// Turning off EAS disables presence mirroring too
+	if (PropertyChangedEvent.Property->GetFName() == FName(TEXT("bUseEAS")))
+	{
+		if (!bUseEAS)
+		{
+			bMirrorPresenceToEAS = false;
+		}
+	}
+
+	// Turning on presence requires EAS
+	if (PropertyChangedEvent.Property->GetFName() == FName(TEXT("bMirrorPresenceToEAS")))
+	{
+		if (bMirrorPresenceToEAS)
+		{
+			bUseEAS = true;
+		}
+	}
+
+	// Turning off EAS disables presence mirroring too
+	if (PropertyChangedEvent.Property->GetFName() == FName(TEXT("bUseEOSConnect")))
+	{
+		if (!bUseEOSConnect)
+		{
+			bMirrorAchievementsToEOS = false;
+			bMirrorStatsToEOS = false;
+			bUseEOSSessions = false;
+		}
+	}
+
+	// These all require EOS turned on if they are on
+	if (PropertyChangedEvent.Property->GetFName() == FName(TEXT("bMirrorAchievementsToEOS")) ||
+		PropertyChangedEvent.Property->GetFName() == FName(TEXT("bMirrorStatsToEOS")) ||
+		PropertyChangedEvent.Property->GetFName() == FName(TEXT("bUseEOSSessions")))
+	{
+		if (bMirrorAchievementsToEOS || bMirrorStatsToEOS || bUseEOSSessions)
+		{
+			bUseEOSConnect = true;
+		}
+	}
+
+	Super::PostEditChangeProperty(PropertyChangedEvent);
+}
+
+#endif
+
+#undef LOCTEXT_NAMESPACE
Index: Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Private/OnlineStoreEOS.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Private/OnlineStoreEOS.cpp b/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Private/OnlineStoreEOS.cpp
new file mode 100644
--- /dev/null	(date 1641575208000)
+++ b/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Private/OnlineStoreEOS.cpp	(date 1641575208000)
@@ -0,0 +1,397 @@
+// Copyright Epic Games, Inc. All Rights Reserved.
+
+#include "OnlineStoreEOS.h"
+
+#if WITH_EOS_SDK
+
+#include "OnlineSubsystemEOS.h"
+#include "UserManagerEOS.h"
+#include "eos_ecom.h"
+
+#define ONLINE_ERROR_NAMESPACE "com.epicgames.oss.eos.error"
+
+
+FOnlineStoreEOS::FOnlineStoreEOS(FOnlineSubsystemEOS* InSubsystem)
+	: EOSSubsystem(InSubsystem)
+{
+	check(EOSSubsystem != nullptr);
+}
+
+void FOnlineStoreEOS::QueryCategories(const FUniqueNetId& UserId, const FOnQueryOnlineStoreCategoriesComplete& Delegate)
+{
+	Delegate.ExecuteIfBound(false, TEXT("QueryCategories Not Implemented"));
+}
+
+void FOnlineStoreEOS::GetCategories(TArray<FOnlineStoreCategory>& OutCategories) const
+{
+	OutCategories.Reset();
+}
+
+void FOnlineStoreEOS::QueryOffersByFilter(const FUniqueNetId& UserId, const FOnlineStoreFilter& Filter, const FOnQueryOnlineStoreOffersComplete& Delegate)
+{
+	QueryOffers(UserId, Delegate);
+}
+
+void FOnlineStoreEOS::QueryOffersById(const FUniqueNetId& UserId, const TArray<FUniqueOfferId>& OfferIds, const FOnQueryOnlineStoreOffersComplete& Delegate)
+{
+	QueryOffers(UserId, Delegate);
+}
+
+typedef TEOSCallback<EOS_Ecom_OnQueryOffersCallback, EOS_Ecom_QueryOffersCallbackInfo> FQueryOffersCallback;
+
+void FOnlineStoreEOS::QueryOffers(const FUniqueNetId& UserId, const FOnQueryOnlineStoreOffersComplete& Delegate)
+{
+	if (CachedOfferIds.Num() && CachedOffers.Num())
+	{
+		Delegate.ExecuteIfBound(true, CachedOfferIds, TEXT("Returning cached offers"));
+		return;
+	}
+	EOS_EpicAccountId AccountId = EOSSubsystem->UserManager->GetEpicAccountId(UserId);
+	if (AccountId == nullptr)
+	{
+		Delegate.ExecuteIfBound(false, TArray<FUniqueOfferId>(), TEXT("Can't query offers for a null user"));
+		return;
+	}
+
+	CachedOfferIds.Reset();
+	CachedOffers.Reset();
+
+	EOS_Ecom_QueryOffersOptions Options = { };
+	Options.ApiVersion = EOS_ECOM_QUERYOFFERS_API_LATEST;
+	Options.LocalUserId = AccountId;
+
+	FQueryOffersCallback* CallbackObj = new FQueryOffersCallback();
+	CallbackObj->CallbackLambda = [this, OnComplete = FOnQueryOnlineStoreOffersComplete(Delegate)](const EOS_Ecom_QueryOffersCallbackInfo* Data)
+	{
+		EOS_EResult Result = Data->ResultCode;
+		if (Result != EOS_EResult::EOS_Success)
+		{
+			OnComplete.ExecuteIfBound(false, CachedOfferIds, EOS_EResult_ToString(Data->ResultCode));
+			return;
+		}
+
+		EOS_Ecom_GetOfferCountOptions CountOptions = { };
+		CountOptions.ApiVersion = EOS_ECOM_GETOFFERCOUNT_API_LATEST;
+		CountOptions.LocalUserId = Data->LocalUserId;
+		uint32 OfferCount = EOS_Ecom_GetOfferCount(EOSSubsystem->EcomHandle, &CountOptions);
+
+		EOS_Ecom_CopyOfferByIndexOptions OfferOptions = { };
+		OfferOptions.ApiVersion = EOS_ECOM_COPYOFFERBYINDEX_API_LATEST;
+		OfferOptions.LocalUserId = Data->LocalUserId;
+		// Iterate and parse the offer list
+		for (uint32 OfferIndex = 0; OfferIndex < OfferCount; OfferIndex++)
+		{
+			EOS_Ecom_CatalogOffer* Offer = nullptr;
+			OfferOptions.OfferIndex = OfferIndex;
+			EOS_EResult OfferResult = EOS_Ecom_CopyOfferByIndex(EOSSubsystem->EcomHandle, &OfferOptions, &Offer);
+			if (OfferResult != EOS_EResult::EOS_Success)
+			{
+				continue;
+			}
+			FOnlineStoreOfferRef OfferRef(new FOnlineStoreOffer());
+			OfferRef->OfferId = Offer->Id;
+
+			OfferRef->Title = FText::FromString(Offer->TitleText);
+			OfferRef->Description = FText::FromString(Offer->DescriptionText);
+			OfferRef->LongDescription = FText::FromString(Offer->LongDescriptionText);
+
+			OfferRef->ExpirationDate = FDateTime(Offer->ExpirationTimestamp);
+
+			OfferRef->CurrencyCode = Offer->CurrencyCode;
+			if (Offer->PriceResult == EOS_EResult::EOS_Success)
+			{
+#if EOS_ECOM_CATALOGOFFER_API_LATEST >= 3
+				OfferRef->RegularPrice = Offer->OriginalPrice64;
+				OfferRef->NumericPrice = Offer->CurrentPrice64;
+#else
+				OfferRef->RegularPrice = Offer->OriginalPrice;
+				OfferRef->NumericPrice = Offer->CurrentPrice;
+#endif
+				OfferRef->DiscountType = Offer->DiscountPercentage == 0 ? EOnlineStoreOfferDiscountType::NotOnSale : EOnlineStoreOfferDiscountType::DiscountAmount;
+			}
+
+			CachedOffers.Add(OfferRef);
+			CachedOfferIds.Add(OfferRef->OfferId);
+
+			EOS_Ecom_CatalogOffer_Release(Offer);
+		}
+
+		OnComplete.ExecuteIfBound(true, CachedOfferIds, TEXT(""));
+	};
+	EOS_Ecom_QueryOffers(EOSSubsystem->EcomHandle, &Options, CallbackObj, CallbackObj->GetCallbackPtr());
+}
+
+void FOnlineStoreEOS::GetOffers(TArray<FOnlineStoreOfferRef>& OutOffers) const
+{
+	OutOffers = CachedOffers;
+}
+
+TSharedPtr<FOnlineStoreOffer> FOnlineStoreEOS::GetOffer(const FUniqueOfferId& OfferId) const
+{
+	for (FOnlineStoreOfferRef Offer : CachedOffers)
+	{
+		if (Offer->OfferId == OfferId)
+		{
+			return Offer;
+		}
+	}
+	return nullptr;
+}
+
+typedef TEOSCallback<EOS_Ecom_OnCheckoutCallback, EOS_Ecom_CheckoutCallbackInfo> FCheckoutCallback;
+
+void FOnlineStoreEOS::Checkout(const FUniqueNetId& UserId, const FPurchaseCheckoutRequest& CheckoutRequest, const FOnPurchaseCheckoutComplete& Delegate)
+{
+	EOS_EpicAccountId AccountId = EOSSubsystem->UserManager->GetEpicAccountId(UserId);
+	if (AccountId == nullptr)
+	{
+		UE_LOG_ONLINE(Error, TEXT("Checkout: failed due to invalid user"));
+		Delegate.ExecuteIfBound(ONLINE_ERROR(EOnlineErrorResult::InvalidUser), MakeShared<FPurchaseReceipt>());
+		return;
+	}
+	if (CheckoutRequest.PurchaseOffers.Num() == 0)
+	{
+		UE_LOG_ONLINE(Error, TEXT("Checkout: failed due to no items to buy"));
+		Delegate.ExecuteIfBound(ONLINE_ERROR(EOnlineErrorResult::InvalidParams), MakeShared<FPurchaseReceipt>());
+		return;
+	}
+	if (CheckoutRequest.PurchaseOffers.Num() > EOS_ECOM_CHECKOUT_MAX_ENTRIES)
+	{
+		UE_LOG_ONLINE(Error, TEXT("Checkout: can only buy %d items at a time"), EOS_ECOM_CHECKOUT_MAX_ENTRIES);
+		Delegate.ExecuteIfBound(ONLINE_ERROR(EOnlineErrorResult::InvalidParams), MakeShared<FPurchaseReceipt>());
+		return;
+	}
+
+	const int32 NumItems = CheckoutRequest.PurchaseOffers.Num();
+	char Items[EOS_ECOM_CHECKOUT_MAX_ENTRIES][EOS_ECOM_TRANSACTIONID_MAXIMUM_LENGTH];
+	TArray<EOS_Ecom_CheckoutEntry> Entries;
+	Entries.AddZeroed(NumItems);
+
+	// Convert the items
+	for (int32 Index = 0; Index < NumItems; Index++)
+	{
+		Entries[Index].ApiVersion = EOS_ECOM_CHECKOUTENTRY_API_LATEST;
+		Entries[Index].OfferId = Items[Index];
+		FCStringAnsi::Strncpy(Items[Index], TCHAR_TO_UTF8(*CheckoutRequest.PurchaseOffers[Index].OfferId), EOS_ECOM_TRANSACTIONID_MAXIMUM_LENGTH);
+	}
+
+	EOS_Ecom_CheckoutOptions Options = { };
+	Options.ApiVersion = EOS_ECOM_CHECKOUT_API_LATEST;
+	Options.LocalUserId = AccountId;
+	Options.EntryCount = NumItems;
+	Options.Entries = (const EOS_Ecom_CheckoutEntry*)Entries.GetData();
+
+	FCheckoutCallback* CallbackObj = new FCheckoutCallback();
+	CallbackObj->CallbackLambda = [this, OnComplete = FOnPurchaseCheckoutComplete(Delegate)](const EOS_Ecom_CheckoutCallbackInfo* Data)
+	{
+		EOS_EResult Result = Data->ResultCode;
+		if (Result != EOS_EResult::EOS_Success)
+		{
+			UE_LOG_ONLINE(Error, TEXT("EOS_Ecom_Checkout: failed with error (%s)"), ANSI_TO_TCHAR(EOS_EResult_ToString(Data->ResultCode)));
+			OnComplete.ExecuteIfBound(ONLINE_ERROR(EOnlineErrorResult::Unknown), MakeShared<FPurchaseReceipt>());
+			return;
+		}
+
+		// Update the cached receipts
+		QueryReceipts(*EOSSubsystem->UserManager->GetLocalUniqueNetIdEOS(Data->LocalUserId), true,
+			FOnQueryReceiptsComplete::CreateLambda([this, PurchaseComplete = FOnPurchaseCheckoutComplete(OnComplete), TransId = FString(Data->TransactionId)](const FOnlineError& Result)
+		{
+			if (!Result.WasSuccessful())
+			{
+				UE_LOG_ONLINE(Error, TEXT("EOS_Ecom_Checkout: failed to query receipts after purchase"));
+				PurchaseComplete.ExecuteIfBound(ONLINE_ERROR(EOnlineErrorResult::Unknown), MakeShared<FPurchaseReceipt>());
+				return;
+			}
+
+			TSharedRef<FPurchaseReceipt> Receipt = MakeShared<FPurchaseReceipt>();
+			// Find the transaction in our receipts
+			for (const FPurchaseReceipt& SearchReceipt : CachedReceipts)
+			{
+				if (SearchReceipt.TransactionId == TransId)
+				{
+					Receipt = MakeShared<FPurchaseReceipt>(SearchReceipt);
+					break;
+				}
+			}
+			PurchaseComplete.ExecuteIfBound(ONLINE_ERROR(EOnlineErrorResult::Success), Receipt);
+		}));
+
+	};
+	EOS_Ecom_Checkout(EOSSubsystem->EcomHandle, &Options, CallbackObj, CallbackObj->GetCallbackPtr());
+
+}
+
+void FOnlineStoreEOS::FinalizePurchase(const FUniqueNetId& UserId, const FString& ReceiptId)
+{
+	UE_LOG_ONLINE(Error, TEXT("FinalizePurchase: Not supported. Did you mean FinalizeReceiptValidationInfo?"));
+}
+
+void FOnlineStoreEOS::RedeemCode(const FUniqueNetId& UserId, const FRedeemCodeRequest& RedeemCodeRequest, const FOnPurchaseRedeemCodeComplete& Delegate)
+{
+	static const TSharedRef<FPurchaseReceipt> BlankReceipt(MakeShared<FPurchaseReceipt>());
+	Delegate.ExecuteIfBound(ONLINE_ERROR(EOnlineErrorResult::NotImplemented), BlankReceipt);
+}
+
+typedef TEOSCallback<EOS_Ecom_OnQueryEntitlementsCallback, EOS_Ecom_QueryEntitlementsCallbackInfo> FQueryReceiptsCallback;
+
+void FOnlineStoreEOS::QueryReceipts(const FUniqueNetId& UserId, bool bRestoreReceipts, const FOnQueryReceiptsComplete& Delegate)
+{
+	EOS_EpicAccountId AccountId = EOSSubsystem->UserManager->GetEpicAccountId(UserId);
+	if (AccountId == nullptr)
+	{
+		UE_LOG_ONLINE(Error, TEXT("QueryReceipts: failed due to invalid user"));
+		Delegate.ExecuteIfBound(ONLINE_ERROR(EOnlineErrorResult::InvalidUser));
+		return;
+	}
+
+	CachedReceipts.Reset();
+
+	EOS_Ecom_QueryEntitlementsOptions Options = { };
+	Options.ApiVersion = EOS_ECOM_QUERYENTITLEMENTS_API_LATEST;
+	Options.LocalUserId = AccountId;
+	Options.bIncludeRedeemed = bRestoreReceipts ? EOS_TRUE : EOS_FALSE;
+
+	FQueryReceiptsCallback* CallbackObj = new FQueryReceiptsCallback();
+	CallbackObj->CallbackLambda = [this, OnComplete = FOnQueryReceiptsComplete(Delegate)](const EOS_Ecom_QueryEntitlementsCallbackInfo* Data)
+	{
+		EOS_EResult Result = Data->ResultCode;
+		if (Result != EOS_EResult::EOS_Success)
+		{
+			UE_LOG_ONLINE(Error, TEXT("EOS_Ecom_QueryEntitlements: failed with error (%s)"), ANSI_TO_TCHAR(EOS_EResult_ToString(Data->ResultCode)));
+			OnComplete.ExecuteIfBound(ONLINE_ERROR(EOnlineErrorResult::Unknown));
+			return;
+		}
+
+		EOS_Ecom_GetEntitlementsCountOptions CountOptions = { };
+		CountOptions.ApiVersion = EOS_ECOM_GETENTITLEMENTSCOUNT_API_LATEST;
+		CountOptions.LocalUserId = Data->LocalUserId;
+		uint32 Count = EOS_Ecom_GetEntitlementsCount(EOSSubsystem->EcomHandle, &CountOptions);
+		CachedReceipts.AddZeroed(Count);
+
+		EOS_Ecom_CopyEntitlementByIndexOptions CopyOptions = { };
+		CopyOptions.ApiVersion = EOS_ECOM_COPYENTITLEMENTBYINDEX_API_LATEST;
+		CopyOptions.LocalUserId = Data->LocalUserId;
+
+		for (uint32 Index = 0; Index < Count; Index++)
+		{
+			CopyOptions.EntitlementIndex = Index;
+
+			EOS_Ecom_Entitlement* Receipt = nullptr;
+			EOS_EResult CopyResult = EOS_Ecom_CopyEntitlementByIndex(EOSSubsystem->EcomHandle, &CopyOptions, &Receipt);
+			if (CopyResult != EOS_EResult::EOS_Success && CopyResult != EOS_EResult::EOS_Ecom_EntitlementStale)
+			{
+				UE_LOG_ONLINE(Error, TEXT("EOS_Ecom_CopyEntitlementByIndex: failed with error (%s)"), ANSI_TO_TCHAR(EOS_EResult_ToString(CopyResult)));
+				continue;
+			}
+
+			// Parse the entitlement into the receipt format
+			FPurchaseReceipt& PurchaseReceipt = CachedReceipts[Index];
+			PurchaseReceipt.TransactionId = Receipt->EntitlementId;
+			PurchaseReceipt.TransactionState = EPurchaseTransactionState::Purchased;
+			PurchaseReceipt.AddReceiptOffer(FOfferNamespace(), Receipt->CatalogItemId, 1);
+			FPurchaseReceipt::FLineItemInfo& LineItem = PurchaseReceipt.ReceiptOffers[0].LineItems.Emplace_GetRef();
+			LineItem.ItemName = Receipt->EntitlementName;
+			LineItem.UniqueId = Receipt->EntitlementId;
+			LineItem.ValidationInfo = Receipt->bRedeemed == EOS_TRUE ? "" : Receipt->EntitlementId;
+
+			EOS_Ecom_Entitlement_Release(Receipt);
+		}
+
+		OnComplete.ExecuteIfBound(ONLINE_ERROR(EOnlineErrorResult::Success));
+	};
+	EOS_Ecom_QueryEntitlements(EOSSubsystem->EcomHandle, &Options, CallbackObj, CallbackObj->GetCallbackPtr());
+}
+
+void FOnlineStoreEOS::GetReceipts(const FUniqueNetId& UserId, TArray<FPurchaseReceipt>& OutReceipts) const
+{
+	OutReceipts = CachedReceipts;
+}
+
+typedef TEOSCallback<EOS_Ecom_OnRedeemEntitlementsCallback, EOS_Ecom_RedeemEntitlementsCallbackInfo> FRedeemReceiptCallback;
+
+void FOnlineStoreEOS::FinalizeReceiptValidationInfo(const FUniqueNetId& UserId, FString& InReceiptValidationInfo, const FOnFinalizeReceiptValidationInfoComplete& Delegate)
+{
+	EOS_EpicAccountId AccountId = EOSSubsystem->UserManager->GetEpicAccountId(UserId);
+	if (AccountId == nullptr)
+	{
+		Delegate.ExecuteIfBound(ONLINE_ERROR(EOnlineErrorResult::InvalidUser), InReceiptValidationInfo);
+		return;
+	}
+	if (InReceiptValidationInfo.IsEmpty())
+	{
+		Delegate.ExecuteIfBound(ONLINE_ERROR(EOnlineErrorResult::InvalidParams), InReceiptValidationInfo);
+		return;
+	}
+
+	char const* Ids[1];
+	FTCHARToUTF8 EntitlementId(*InReceiptValidationInfo);
+	Ids[0] = EntitlementId.Get();
+
+	EOS_Ecom_RedeemEntitlementsOptions Options = { };
+	Options.ApiVersion = EOS_ECOM_REDEEMENTITLEMENTS_API_LATEST;
+	Options.LocalUserId = AccountId;
+	Options.EntitlementIdCount = 1;
+	Options.EntitlementIds = Ids;
+
+	FRedeemReceiptCallback* CallbackObj = new FRedeemReceiptCallback();
+	CallbackObj->CallbackLambda = [this, Info = FString(InReceiptValidationInfo), OnComplete = FOnFinalizeReceiptValidationInfoComplete(Delegate)](const EOS_Ecom_RedeemEntitlementsCallbackInfo* Data)
+	{
+		EOS_EResult Result = Data->ResultCode;
+		if (Result != EOS_EResult::EOS_Success)
+		{
+			UE_LOG_ONLINE(Error, TEXT("EOS_Ecom_RedeemEntitlements: failed with error (%s)"), ANSI_TO_TCHAR(EOS_EResult_ToString(Data->ResultCode)));
+			OnComplete.ExecuteIfBound(ONLINE_ERROR(EOnlineErrorResult::Unknown), Info);
+			return;
+		}
+
+		// Find the receipt in our list and mark as redeemed (clear the validation info)
+		for (FPurchaseReceipt& SearchReceipt : CachedReceipts)
+		{
+			if (SearchReceipt.TransactionId == Info)
+			{
+				// Clearing this field tells the game it can't be redeemed
+				SearchReceipt.ReceiptOffers[0].LineItems[0].ValidationInfo.Empty();
+				break;
+			}
+		}
+
+		OnComplete.ExecuteIfBound(ONLINE_ERROR(EOnlineErrorResult::Success), Info);
+	};
+	EOS_Ecom_RedeemEntitlements(EOSSubsystem->EcomHandle, &Options, CallbackObj, CallbackObj->GetCallbackPtr());
+}
+
+bool FOnlineStoreEOS::HandleEcomExec(UWorld* InWorld, const TCHAR* Cmd, FOutputDevice& Ar)
+{
+	if (FParse::Command(&Cmd, TEXT("OFFERS")))
+	{
+		QueryOffers(*EOSSubsystem->UserManager->GetLocalUniqueNetIdEOS(),
+			FOnQueryOnlineStoreOffersComplete::CreateLambda([this](bool bWasSuccessful, const TArray<FUniqueOfferId>& OfferIds, const FString& ErrorStr)
+		{
+			UE_LOG_ONLINE(Error, TEXT("QueryOffers: %s with error (%s)"), bWasSuccessful ? TEXT("succeeded") : TEXT("failed"), *ErrorStr);
+
+			for (const FUniqueOfferId& OfferId : OfferIds)
+			{
+				UE_LOG_ONLINE(Log, TEXT("OfferId: %s"), *OfferId);
+			}
+		}));
+		return true;
+	}
+	else if (FParse::Command(&Cmd, TEXT("RECEIPTS")))
+	{
+		QueryReceipts(*EOSSubsystem->UserManager->GetLocalUniqueNetIdEOS(), false,
+			FOnQueryReceiptsComplete::CreateLambda([this](const FOnlineError& Result)
+		{
+			UE_LOG_ONLINE(Log, TEXT("QueryReceipts: %s with error (%s)"), Result.WasSuccessful() ? TEXT("succeeded") : TEXT("failed"), *Result.GetErrorRaw());
+			for (const FPurchaseReceipt& Receipt : CachedReceipts)
+			{
+				UE_LOG_ONLINE(Log, TEXT("Receipt: %s"), *Receipt.TransactionId);
+				UE_LOG_ONLINE(Log, TEXT("\tOffer Id (%s), Quantity (%d)"), *Receipt.ReceiptOffers[0].OfferId, Receipt.ReceiptOffers[0].Quantity);
+				UE_LOG_ONLINE(Log, TEXT("\tLine item (%s) is %s"), *Receipt.ReceiptOffers[0].LineItems[0].ItemName, Receipt.ReceiptOffers[0].LineItems[0].IsRedeemable() ? TEXT("redeemable") : TEXT("not redeemable"));
+			}
+		}));
+		return true;
+	}
+	return false;
+}
+
+#endif
\ No newline at end of file
Index: FantasyBattle.uproject
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>{\r\n\t\"FileVersion\": 3,\r\n\t\"EngineAssociation\": \"5.0\",\r\n\t\"Category\": \"\",\r\n\t\"Description\": \"\",\r\n\t\"Modules\": [\r\n\t\t{\r\n\t\t\t\"Name\": \"FantasyBattle\",\r\n\t\t\t\"Type\": \"Runtime\",\r\n\t\t\t\"LoadingPhase\": \"Default\",\r\n\t\t\t\"AdditionalDependencies\": [\r\n\t\t\t\t\"Engine\",\r\n\t\t\t\t\"UMG\"\r\n\t\t\t]\r\n\t\t},\r\n\t\t{\r\n\t\t\t\"Name\": \"DiceRoll\",\r\n\t\t\t\"Type\": \"Runtime\",\r\n\t\t\t\"LoadingPhase\": \"Default\",\r\n\t\t\t\"AdditionalDependencies\": [\r\n\t\t\t\t\"Engine\"\r\n\t\t\t]\r\n\t\t},\r\n\t\t{\r\n\t\t\t\"Name\": \"SpecialRules\",\r\n\t\t\t\"Type\": \"Runtime\",\r\n\t\t\t\"LoadingPhase\": \"Default\",\r\n\t\t\t\"AdditionalDependencies\": [\r\n\t\t\t\t\"Engine\"\r\n\t\t\t]\r\n\t\t}\r\n\t]\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/FantasyBattle.uproject b/FantasyBattle.uproject
--- a/FantasyBattle.uproject	(revision 9b08c3c30042b95af90916955e891c673f23b32c)
+++ b/FantasyBattle.uproject	(date 1642813178912)
@@ -1,6 +1,6 @@
 {
 	"FileVersion": 3,
-	"EngineAssociation": "5.0",
+	"EngineAssociation": "{2C5849A3-4129-69B1-26A5-9AB1C10C64A8}",
 	"Category": "",
 	"Description": "",
 	"Modules": [
@@ -10,7 +10,8 @@
 			"LoadingPhase": "Default",
 			"AdditionalDependencies": [
 				"Engine",
-				"UMG"
+				"UMG",
+				"UMGEditor"
 			]
 		},
 		{
@@ -29,5 +30,42 @@
 				"Engine"
 			]
 		}
+	],
+	"Plugins": [
+		{
+			"Name": "OnlineSubsystemEOS",
+			"Enabled": true
+		},
+		{
+			"Name": "OnlineServicesEOS",
+			"Enabled": true
+		},
+		{
+			"Name": "EOSVoiceChat",
+			"Enabled": true
+		},
+		{
+			"Name": "EOSShared",
+			"Enabled": true
+		},
+		{
+			"Name": "OnlineSubsystemGooglePlay",
+			"Enabled": false,
+			"SupportedTargetPlatforms": [
+				"Android"
+			]
+		},
+		{
+			"Name": "OnlineSubsystemIOS",
+			"Enabled": false,
+			"SupportedTargetPlatforms": [
+				"IOS",
+				"TVOS"
+			]
+		},
+		{
+			"Name": "OnlineSubsystemSteam",
+			"Enabled": true
+		}
 	]
 }
\ No newline at end of file
Index: Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Private/OnlineSubsystemEOSPrivate.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Private/OnlineSubsystemEOSPrivate.h b/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Private/OnlineSubsystemEOSPrivate.h
new file mode 100644
--- /dev/null	(date 1641575208000)
+++ b/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Private/OnlineSubsystemEOSPrivate.h	(date 1641575208000)
@@ -0,0 +1,18 @@
+// Copyright Epic Games, Inc. All Rights Reserved.
+
+#pragma once
+
+#include "CoreMinimal.h"
+#include "OnlineSubsystem.h"
+#include "Modules/ModuleManager.h"
+
+#define INVALID_INDEX -1
+
+/** URL Prefix when using EOS socket connection */
+#define EOS_URL_PREFIX TEXT("EOS.")
+
+/** pre-pended to all NULL logging */
+#undef ONLINE_LOG_PREFIX
+#define ONLINE_LOG_PREFIX TEXT("EOS: ")
+
+
Index: Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Private/NetDriverEOS.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Private/NetDriverEOS.cpp b/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Private/NetDriverEOS.cpp
new file mode 100644
--- /dev/null	(date 1641575208000)
+++ b/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Private/NetDriverEOS.cpp	(date 1641575208000)
@@ -0,0 +1,230 @@
+// Copyright Epic Games, Inc. All Rights Reserved.
+
+#include "NetDriverEOS.h"
+#include "NetConnectionEOS.h"
+#include "SocketEOS.h"
+#include "OnlineSubsystem.h"
+#include "OnlineSubsystemNames.h"
+#include "OnlineSubsystemUtils.h"
+#include "SocketSubsystemEOS.h"
+#include "Misc/EngineVersionComparison.h"
+
+bool UNetDriverEOS::IsAvailable() const
+{
+	// Use passthrough sockets if we are a dedicated server
+	if (IsRunningDedicatedServer())
+	{
+		return false;
+	}
+
+	if (IOnlineSubsystem* Subsystem = Online::GetSubsystem(FindWorld(), EOS_SUBSYSTEM))
+	{
+		if (ISocketSubsystem* SocketSubsystem = ISocketSubsystem::Get(EOS_SUBSYSTEM))
+		{
+			return true;
+		}
+	}
+
+	return false;
+}
+
+bool UNetDriverEOS::InitBase(bool bInitAsClient, FNetworkNotify* InNotify, const FURL& URL, bool bReuseAddressAndPort, FString& Error)
+{
+	if (bIsPassthrough)
+	{
+		UE_LOG(LogSocketSubsystemEOS, Verbose, TEXT("Running as pass-through"));
+		return Super::InitBase(bInitAsClient, InNotify, URL, bReuseAddressAndPort, Error);
+	}
+
+	if (!UNetDriver::InitBase(bInitAsClient, InNotify, URL, bReuseAddressAndPort, Error))
+	{
+		UE_LOG(LogSocketSubsystemEOS, Warning, TEXT("Failed to init driver base"));
+		return false;
+	}
+
+	FSocketSubsystemEOS* const SocketSubsystem = static_cast<FSocketSubsystemEOS*>(GetSocketSubsystem());
+	if (!SocketSubsystem)
+	{
+		UE_LOG(LogSocketSubsystemEOS, Warning, TEXT("Could not get socket subsystem"));
+		return false;
+	}
+
+	// We don't care if our world is null, everything we uses handles it fine
+	const UWorld* const MyWorld = FindWorld();
+
+	// Get our local address (proves we're logged in)
+	TSharedRef<FInternetAddr> LocalAddress = SocketSubsystem->GetLocalBindAddr(MyWorld, *GLog);
+	if (!LocalAddress->IsValid())
+	{
+		// Not logged in?
+		Error = TEXT("Could not bind local address");
+		UE_LOG(LogSocketSubsystemEOS, Warning, TEXT("Could not bind local address"));
+		return false;
+	}
+
+	// Create our socket
+	SetSocketAndLocalAddress(SocketSubsystem->CreateSocket(NAME_DGram, TEXT("UE4"), NAME_None));
+	if (GetSocket() == nullptr)
+	{
+		UE_LOG(LogSocketSubsystemEOS, Warning, TEXT("Could not create socket"));
+		return false;
+	}
+
+	// Store our local address and set our port
+	TSharedRef<FInternetAddrEOS> EOSLocalAddress = StaticCastSharedRef<FInternetAddrEOS>(LocalAddress);
+	// Because some platforms remap ports, we will use the ID of the name of the net driver to be our channel
+	EOSLocalAddress->SetChannel(GetTypeHash(NetDriverName.ToString()));
+	// Set our net driver name so we don't accept connections across net driver types
+	EOSLocalAddress->SetSocketName(NetDriverName.ToString());
+
+	static_cast<FSocketEOS*>(GetSocket())->SetLocalAddress(*EOSLocalAddress);
+
+	LocalAddr = LocalAddress;
+
+	return true;
+}
+
+bool UNetDriverEOS::InitConnect(FNetworkNotify* InNotify, const FURL& ConnectURL, FString& Error)
+{
+	if (!bIsUsingP2PSockets || !IsAvailable() || !ConnectURL.Host.StartsWith(EOS_CONNECTION_URL_PREFIX, ESearchCase::IgnoreCase))
+	{
+		UE_LOG(LogSocketSubsystemEOS, Verbose, TEXT("Connecting using IPNetDriver passthrough. ConnectUrl = (%s)"), *ConnectURL.ToString());
+
+		bIsPassthrough = true;
+		return Super::InitConnect(InNotify, ConnectURL, Error);
+	}
+
+	bool bIsValid = false;
+	TSharedRef<FInternetAddrEOS> RemoteHost = MakeShared<FInternetAddrEOS>();
+	RemoteHost->SetIp(*ConnectURL.Host, bIsValid);
+	if (!bIsValid || ConnectURL.Port < 0)
+	{
+		Error = TEXT("Invalid remote address");
+		UE_LOG(LogSocketSubsystemEOS, Warning, TEXT("Invalid Remote Address. ConnectUrl = (%s)"), *ConnectURL.ToString());
+		return false;
+	}
+
+	UE_LOG(LogSocketSubsystemEOS, Verbose, TEXT("Connecting using EOSNetDriver. ConnectUrl = (%s)"), *ConnectURL.ToString());
+
+	if (!InitBase(true, InNotify, ConnectURL, false, Error))
+	{
+		return false;
+	}
+
+	// Set the address to what was parsed (us + remote)
+	LocalAddr = RemoteHost;
+
+	// Reference to our newly created socket
+	FSocket* CurSocket = GetSocket();
+
+	// Bind our local port
+	FSocketSubsystemEOS* const SocketSubsystem = static_cast<FSocketSubsystemEOS*>(GetSocketSubsystem());
+	check(SocketSubsystem);
+	if (!SocketSubsystem->BindNextPort(CurSocket, *LocalAddr, MaxPortCountToTry + 1, 1))
+	{
+		// Failure
+		Error = TEXT("Could not bind local port");
+		UE_LOG(LogSocketSubsystemEOS, Warning, TEXT("Could not bind local port in %d attempts"), MaxPortCountToTry);
+		return false;
+	}
+
+	// Create an unreal connection to the server
+	UNetConnectionEOS* Connection = NewObject<UNetConnectionEOS>(NetConnectionClass);
+	check(Connection);
+
+	// Set it as the server connection before anything else so everything knows this is a client
+	ServerConnection = Connection;
+	Connection->InitLocalConnection(this, CurSocket, ConnectURL, USOCK_Pending);
+
+	CreateInitialClientChannels();
+
+	return true;
+}
+
+bool UNetDriverEOS::InitListen(FNetworkNotify* InNotify, FURL& LocalURL, bool bReuseAddressAndPort, FString& Error)
+{
+	if (!bIsUsingP2PSockets || !IsAvailable() || LocalURL.HasOption(TEXT("bIsLanMatch")) || LocalURL.HasOption(TEXT("bUseIPSockets")))
+	{
+		UE_LOG(LogSocketSubsystemEOS, Verbose, TEXT("Init as IPNetDriver listen server. LocalURL = (%s)"), *LocalURL.ToString());
+
+		bIsPassthrough = true;
+		return Super::InitListen(InNotify, LocalURL, bReuseAddressAndPort, Error);
+	}
+
+	UE_LOG(LogSocketSubsystemEOS, Verbose, TEXT("Init as EOSNetDriver listen server. LocalURL = (%s)"), *LocalURL.ToString());
+
+	if (!InitBase(false, InNotify, LocalURL, bReuseAddressAndPort, Error))
+	{
+		return false;
+	}
+
+	// Bind our specified port if provided
+	FSocket* CurSocket = GetSocket();
+	if (!CurSocket->Listen(0))
+	{
+		Error = TEXT("Could not listen");
+		UE_LOG(LogSocketSubsystemEOS, Warning, TEXT("Could not listen on socket"));
+		return false;
+	}
+
+	InitConnectionlessHandler();
+
+	UE_LOG(LogSocketSubsystemEOS, Verbose, TEXT("Initialized as an EOSP2P listen server"));
+	return true;
+}
+
+ISocketSubsystem* UNetDriverEOS::GetSocketSubsystem()
+{
+	return ISocketSubsystem::Get(bIsPassthrough ? PLATFORM_SOCKETSUBSYSTEM : EOS_SUBSYSTEM);
+}
+
+void UNetDriverEOS::Shutdown()
+{
+	UE_LOG(LogSocketSubsystemEOS, Verbose, TEXT("Shutting down NetDriver"));
+
+	Super::Shutdown();
+
+	// Kill our P2P sessions now, instead of when garbage collection kicks in later
+	if (!bIsPassthrough)
+	{
+		if (UNetConnectionEOS* const EOSServerConnection = Cast<UNetConnectionEOS>(ServerConnection))
+		{
+			EOSServerConnection->DestroyEOSConnection();
+		}
+		for (UNetConnection* Client : ClientConnections)
+		{
+			if (UNetConnectionEOS* const EOSClient = Cast<UNetConnectionEOS>(Client))
+			{
+				EOSClient->DestroyEOSConnection();
+			}
+		}
+	}
+}
+
+int UNetDriverEOS::GetClientPort()
+{
+	if (bIsPassthrough)
+	{
+		return Super::GetClientPort();
+	}
+
+	// Starting range of dynamic/private/ephemeral ports
+	return 49152;
+}
+
+UWorld* UNetDriverEOS::FindWorld() const
+{
+	UWorld* MyWorld = GetWorld();
+
+	// If we don't have a world, we may be a pending net driver
+	if (!MyWorld && GEngine)
+	{
+		if (FWorldContext* WorldContext = GEngine->GetWorldContextFromPendingNetGameNetDriver(this))
+		{
+			MyWorld = WorldContext->World();
+		}
+	}
+
+	return MyWorld;
+}
+
Index: Source/FantasyBattle/Private/ArmySaveGame.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Source/FantasyBattle/Private/ArmySaveGame.cpp b/Source/FantasyBattle/Private/ArmySaveGame.cpp
new file mode 100644
--- /dev/null	(date 1643309171013)
+++ b/Source/FantasyBattle/Private/ArmySaveGame.cpp	(date 1643309171013)
@@ -0,0 +1,75 @@
+// Fill out your copyright notice in the Description page of Project Settings.
+
+
+#include "ArmySaveGame.h"
+#include "Kismet/GameplayStatics.h"
+
+bool UArmySaveGame::AddArmyToList(FArmyStat Army)
+{
+	UE_LOG(LogTemp, Warning, TEXT("Adding Army to Save in SaveGame"));
+	FString ArmyNameCheck = CheckArmyName(Army.ArmyName, Army.ArmyType);
+	if (ArmyNameCheck != Army.ArmyName)
+		Army.ArmyName = ArmyNameCheck;
+	SavedArmies.Add(Army);
+	if (!UGameplayStatics::SaveGameToSlot(this, SaveGameList, 0))
+	{
+		SavedArmies.RemoveAt(SavedArmies.Num() -1);
+		UE_LOG(LogTemp, Warning, TEXT("Failed to save %s"), *Army.ArmyName);
+		return false;	
+	}
+	UE_LOG(LogTemp, Warning, TEXT("Successfully saved %s"), *Army.ArmyName);
+	return true;
+}
+
+bool UArmySaveGame::ReplaceSavedArmy(FArmyStat newArmy, int32 Index, FString& ErrorStr)
+{
+	UE_LOG(LogTemp, Warning, TEXT("Replacing Army in SaveGame"));
+	FString ArmyNameCheck = CheckArmyName(newArmy.ArmyName, newArmy.ArmyType);
+	if (ArmyNameCheck != newArmy.ArmyName)
+		newArmy.ArmyName = ArmyNameCheck;
+	FArmyStat RemovedItem = SavedArmies[Index];
+	SavedArmies[Index] = newArmy;
+	if (!UGameplayStatics::SaveGameToSlot(this, SaveGameList, 0))
+	{
+		SavedArmies[Index] = RemovedItem;
+		ErrorStr = TEXT("Failed to save %s");
+		return false;	
+	}
+	ErrorStr = TEXT("Successfully saved %s");
+	return true;
+}
+
+FString UArmySaveGame::CheckArmyName(FString InName, EArmies Race)
+{
+	bool bFailed = true;
+	int32 iteration = 0;
+	FString ArmyRaceString = GetEnumValueToString(FString("EArmies"), Race);
+	FString ArmyName;
+	while (bFailed)
+	{
+		ArmyName = InName;
+		FString TempName = FString("000" + FString::FromInt(iteration));
+		if (InName.Equals(FString("")))
+		{
+			ArmyName = ArmyRaceString + TempName.Right(3);
+		}
+		else
+		{
+			if (iteration >= 1)
+			{
+				ArmyName = ArmyName + TempName.Right(3);
+			}
+		}
+		bFailed = false;
+		for (FArmyStat Army : SavedArmies)
+		{
+			if (ArmyName.Equals(Army.ArmyName))
+			{
+				bFailed = true;
+				break;
+			}
+		}
+		iteration += 1;
+	}
+	return ArmyName;
+}
Index: Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Private/EOSHelpers.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Private/EOSHelpers.h b/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Private/EOSHelpers.h
new file mode 100644
--- /dev/null	(date 1641575208000)
+++ b/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Private/EOSHelpers.h	(date 1641575208000)
@@ -0,0 +1,29 @@
+// Copyright Epic Games, Inc. All Rights Reserved.
+
+#pragma once
+
+#if WITH_EOS_SDK
+
+#if defined(EOS_PLATFORM_BASE_FILE_NAME)
+#include EOS_PLATFORM_BASE_FILE_NAME
+#endif
+
+#include "eos_auth_types.h"
+#include "eos_types.h"
+#include "Interfaces/OnlineExternalUIInterface.h"
+
+class FOnlineSubsystemEOS;
+using IEOSPlatformHandlePtr = TSharedPtr<class IEOSPlatformHandle, ESPMode::ThreadSafe>;
+
+class FEOSHelpers
+{
+public:
+	virtual ~FEOSHelpers() = default;
+
+	virtual FString PlatformCreateCacheDir(const FString &ArtifactName, const FString &EOSSettingsCacheDir);
+	virtual void PlatformAuthCredentials(EOS_Auth_Credentials &Credentials);
+	virtual void PlatformTriggerLoginUI(FOnlineSubsystemEOS* EOSSubsystem, const int ControllerIndex, bool bShowOnlineOnly, bool bShowSkipButton, const FOnLoginUIClosedDelegate& Delegate);
+	virtual IEOSPlatformHandlePtr CreatePlatform(EOS_Platform_Options& PlatformOptions);
+};
+
+#endif // WITH_EOS_SDK
\ No newline at end of file
Index: Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Private/OnlineStoreEOS.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Private/OnlineStoreEOS.h b/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Private/OnlineStoreEOS.h
new file mode 100644
--- /dev/null	(date 1641576012000)
+++ b/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Private/OnlineStoreEOS.h	(date 1641576012000)
@@ -0,0 +1,73 @@
+// Copyright Epic Games, Inc. All Rights Reserved.
+
+#pragma once
+
+#include "CoreMinimal.h"
+#include "Online/CoreOnline.h"
+#include "Interfaces/OnlineStoreInterfaceV2.h"
+#include "Interfaces/OnlinePurchaseInterface.h"
+#include "OnlineSubsystemEOSPackage.h"
+#include "OnlineSubsystemEOSTypes.h"
+
+#if WITH_EOS_SDK
+	#include "eos_ecom_types.h"
+
+class UWorld;
+
+/**
+ * Implementation for online store via EGS
+ */
+class FOnlineStoreEOS :
+	public IOnlineStoreV2,
+	public IOnlinePurchase,
+	public TSharedFromThis<FOnlineStoreEOS, ESPMode::ThreadSafe>
+{
+public:
+	virtual ~FOnlineStoreEOS() = default;
+
+// Begin IOnlineStoreV2
+	virtual void QueryCategories(const FUniqueNetId& UserId, const FOnQueryOnlineStoreCategoriesComplete& Delegate) override;
+	virtual void GetCategories(TArray<FOnlineStoreCategory>& OutCategories) const override;
+	virtual void QueryOffersByFilter(const FUniqueNetId& UserId, const FOnlineStoreFilter& Filter, const FOnQueryOnlineStoreOffersComplete& Delegate) override;
+	virtual void QueryOffersById(const FUniqueNetId& UserId, const TArray<FUniqueOfferId>& OfferIds, const FOnQueryOnlineStoreOffersComplete& Delegate) override;
+	virtual void GetOffers(TArray<FOnlineStoreOfferRef>& OutOffers) const override;
+	virtual TSharedPtr<FOnlineStoreOffer> GetOffer(const FUniqueOfferId& OfferId) const override;
+// End IOnlineStoreV2
+
+// Begin IOnlinePurchase
+	virtual bool IsAllowedToPurchase(const FUniqueNetId& UserId) override { return true; }
+	virtual void Checkout(const FUniqueNetId& UserId, const FPurchaseCheckoutRequest& CheckoutRequest, const FOnPurchaseCheckoutComplete& Delegate) override;
+	virtual void FinalizePurchase(const FUniqueNetId& UserId, const FString& ReceiptId) override;
+	virtual void RedeemCode(const FUniqueNetId& UserId, const FRedeemCodeRequest& RedeemCodeRequest, const FOnPurchaseRedeemCodeComplete& Delegate) override;
+	virtual void QueryReceipts(const FUniqueNetId& UserId, bool bRestoreReceipts, const FOnQueryReceiptsComplete& Delegate) override;
+	virtual void GetReceipts(const FUniqueNetId& UserId, TArray<FPurchaseReceipt>& OutReceipts) const override;
+	virtual void FinalizeReceiptValidationInfo(const FUniqueNetId& UserId, FString& InReceiptValidationInfo, const FOnFinalizeReceiptValidationInfoComplete& Delegate) override;
+// End IOnlinePurchase
+
+PACKAGE_SCOPE:
+	FOnlineStoreEOS(FOnlineSubsystemEOS* InSubsystem);
+
+	bool HandleEcomExec(UWorld* InWorld, const TCHAR* Cmd, FOutputDevice& Ar);
+
+private:
+	/** Default constructor disabled */
+	FOnlineStoreEOS() = delete;
+
+	void QueryOffers(const FUniqueNetId& UserId, const FOnQueryOnlineStoreOffersComplete& Delegate);
+
+	/** Reference to the main EOS subsystem */
+	FOnlineSubsystemEOS* EOSSubsystem;
+
+	/** The set of offers for this title */
+	TArray<FOnlineStoreOfferRef> CachedOffers;
+	/** List of offer ids for this title */
+	TArray<FUniqueOfferId> CachedOfferIds;
+
+	/** List of receipts for the user */
+//@todo joeg - make this support multiple users
+	TArray<FPurchaseReceipt> CachedReceipts;
+};
+
+typedef TSharedPtr<FOnlineStoreEOS, ESPMode::ThreadSafe> FOnlineStoreEOSPtr;
+
+#endif
Index: Source/FantasyBattle/Public/ArmySaveGame.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Source/FantasyBattle/Public/ArmySaveGame.h b/Source/FantasyBattle/Public/ArmySaveGame.h
new file mode 100644
--- /dev/null	(date 1643301183956)
+++ b/Source/FantasyBattle/Public/ArmySaveGame.h	(date 1643301183956)
@@ -0,0 +1,40 @@
+// Fill out your copyright notice in the Description page of Project Settings.
+
+#pragma once
+
+#include "CoreMinimal.h"
+#include "StructLibrary.h"
+#include "EnumLibrary.h"
+#include "GameFramework/SaveGame.h"
+#include "ArmySaveGame.generated.h"
+
+
+/**
+ * 
+ */
+UCLASS()
+class FANTASYBATTLE_API UArmySaveGame : public USaveGame
+{
+	GENERATED_BODY()
+
+public:
+
+	bool AddArmyToList(FArmyStat Army);
+
+	bool ReplaceSavedArmy(FArmyStat newArmy, int32 Index, FString& ErrorStr);
+
+	UFUNCTION(BlueprintPure)
+	FORCEINLINE FString GetSaveGameString() {return SaveGameList;}
+
+	UFUNCTION(BlueprintPure)
+	FORCEINLINE TArray<FArmyStat> GetSavedArmies() {return SavedArmies;}
+	
+private:
+	
+	UPROPERTY(VisibleAnywhere)
+	TArray<FArmyStat> SavedArmies;
+	
+	FString SaveGameList = TEXT("SaveGameList");
+
+	FString CheckArmyName(FString InName, EArmies Race);
+};
Index: Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Private/OnlineLeaderboardsEOS.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Private/OnlineLeaderboardsEOS.cpp b/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Private/OnlineLeaderboardsEOS.cpp
new file mode 100644
--- /dev/null	(date 1641576012000)
+++ b/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Private/OnlineLeaderboardsEOS.cpp	(date 1641576012000)
@@ -0,0 +1,374 @@
+// Copyright Epic Games, Inc. All Rights Reserved.
+
+#include "OnlineLeaderboardsEOS.h"
+#include "OnlineSubsystem.h"
+#include "OnlineSubsystemEOS.h"
+#include "OnlineSubsystemEOSTypes.h"
+#include "UserManagerEOS.h"
+#include "OnlineStatsEOS.h"
+
+#if WITH_EOS_SDK
+#include "eos_leaderboards.h"
+#include "eos_userinfo.h"
+
+struct FQueryLeaderboardForUserOptions :
+	public EOS_Leaderboards_QueryLeaderboardUserScoresOptions
+{
+	TArray<char*> PointerArray;
+	TArray<EOS_Leaderboards_UserScoresQueryStatInfo> StatInfoArray;
+	TArray<EOS_ProductUserId> ProductUserIds;
+
+	FQueryLeaderboardForUserOptions(const uint32 InNumColumns, TArray<EOS_ProductUserId>& InProductUserIds)
+		: EOS_Leaderboards_QueryLeaderboardUserScoresOptions()
+		, ProductUserIds(MoveTemp(InProductUserIds))
+	{
+		ApiVersion = EOS_LEADERBOARDS_QUERYLEADERBOARDUSERSCORES_API_LATEST;
+
+		StartTime = EOS_LEADERBOARDS_TIME_UNDEFINED;
+		EndTime = EOS_LEADERBOARDS_TIME_UNDEFINED;
+
+		PointerArray.AddZeroed(InNumColumns);
+		for (int32 Index = 0; Index < PointerArray.Num(); Index++)
+		{
+			PointerArray[Index] = new char[EOS_OSS_STRING_BUFFER_LENGTH];
+		}
+
+		StatInfoArray.AddZeroed(InNumColumns);
+		StatInfo = StatInfoArray.GetData();
+		StatInfoCount = InNumColumns;
+
+		UserIds = ProductUserIds.GetData();
+		UserIdsCount = ProductUserIds.Num();
+	}
+
+	~FQueryLeaderboardForUserOptions()
+	{
+		for (int32 Index = 0; Index < PointerArray.Num(); Index++)
+		{
+			delete[] PointerArray[Index];
+		}
+	}
+};
+
+struct FQueryLeaderboardForUsersContext
+{
+	TArray<FUniqueNetIdRef> Players;
+	FOnlineLeaderboardReadRef ReadObject;
+
+	FQueryLeaderboardForUsersContext(const TArray<FUniqueNetIdRef>& InPlayers, FOnlineLeaderboardReadRef& InReadObject)
+		: Players(InPlayers)
+		, ReadObject(InReadObject)
+	{
+	}
+
+	void AddEmptyRowForPlayer(FUniqueNetIdRef NetId, const FString& Nickname)
+	{
+		FOnlineStatsRow Row(Nickname, NetId);
+		for (const FColumnMetaData& Column : ReadObject->ColumnMetadata)
+		{
+			Row.Columns.Add(Column.ColumnName, FVariantData());
+		}
+		Row.Rank = -1;
+		ReadObject->Rows.Add(Row);
+	}
+};
+
+typedef TEOSCallback<EOS_Leaderboards_OnQueryLeaderboardUserScoresCompleteCallback, EOS_Leaderboards_OnQueryLeaderboardUserScoresCompleteCallbackInfo> FQueryLeaderboardForUsersCallback;
+
+bool FOnlineLeaderboardsEOS::ReadLeaderboards(const TArray<FUniqueNetIdRef>& Players, FOnlineLeaderboardReadRef& ReadObject)
+{
+	if (Players.Num() == 0)
+	{
+		EOSSubsystem->ExecuteNextTick([this]()
+			{
+				TriggerOnLeaderboardReadCompleteDelegates(false);
+			});
+		return true;
+	}
+
+	TArray<EOS_ProductUserId> ProductUserIds;
+	ProductUserIds.Empty(Players.Num());
+	// Validate the number of known users
+	for (const FUniqueNetIdRef& NetId : Players)
+	{
+		const FUniqueNetIdEOS& EOSId = FUniqueNetIdEOS::Cast(*NetId);
+		EOS_ProductUserId UserId = EOS_ProductUserId_FromString(TCHAR_TO_UTF8(*EOSId.ProductUserIdStr));
+		if (UserId != nullptr)
+		{
+			ProductUserIds.Add(UserId);
+		}
+	}
+
+	FQueryLeaderboardForUserOptions Options(ReadObject->ColumnMetadata.Num(), ProductUserIds);
+	Options.LocalUserId = EOSSubsystem->UserManager->GetLocalProductUserId(0);
+	// Convert the column names to stats
+	int32 Index = 0;
+	for (const FColumnMetaData& Column : ReadObject->ColumnMetadata)
+	{
+		FCStringAnsi::Strncpy(Options.PointerArray[Index], TCHAR_TO_UTF8(*Column.ColumnName.ToString()), EOS_OSS_STRING_BUFFER_LENGTH);
+		EOS_Leaderboards_UserScoresQueryStatInfo& StatInfo = Options.StatInfoArray[Index];
+		StatInfo.ApiVersion = EOS_LEADERBOARDS_USERSCORESQUERYSTATINFO_API_LATEST;
+		StatInfo.StatName = Options.PointerArray[Index];
+		StatInfo.Aggregation = EOS_ELeaderboardAggregation::EOS_LA_Latest;
+		Index++;
+	}
+
+	TSharedPtr<FQueryLeaderboardForUsersContext> QueryContext = MakeShared<FQueryLeaderboardForUsersContext>(Players, ReadObject);
+
+	FQueryLeaderboardForUsersCallback* CallbackObj = new FQueryLeaderboardForUsersCallback();
+	CallbackObj->CallbackLambda = [this, QueryContext](const EOS_Leaderboards_OnQueryLeaderboardUserScoresCompleteCallbackInfo* Data)
+	{
+		bool bWasSuccessful = Data->ResultCode == EOS_EResult::EOS_Success;
+		if (!bWasSuccessful)
+		{
+	
+			UE_LOG_ONLINE_LEADERBOARD(Error, TEXT("EOS_Leaderboards_QueryLeaderboardUserScores() failed with EOS result code (%s)"), ANSI_TO_TCHAR(EOS_EResult_ToString(Data->ResultCode)));
+			QueryContext->ReadObject->ReadState = EOnlineAsyncTaskState::Failed;
+			TriggerOnLeaderboardReadCompleteDelegates(false);
+			return;
+		}
+
+		char StatName[EOS_OSS_STRING_BUFFER_LENGTH];
+
+		for (FUniqueNetIdRef NetId : QueryContext->Players)
+		{
+			FString Nickname = EOSSubsystem->UserManager->GetPlayerNickname(*NetId);
+			EOS_ProductUserId UserId = EOSSubsystem->UserManager->GetProductUserId(*NetId);
+			if (UserId == nullptr)
+			{
+				QueryContext->AddEmptyRowForPlayer(NetId, Nickname);
+				continue;
+			}
+
+			FOnlineStatsRow Row(Nickname, NetId);
+
+			EOS_Leaderboards_CopyLeaderboardUserScoreByUserIdOptions UserCopyOptions = { };
+			UserCopyOptions.ApiVersion = EOS_LEADERBOARDS_COPYLEADERBOARDUSERSCOREBYUSERID_API_LATEST;
+			UserCopyOptions.UserId = UserId;
+			UserCopyOptions.StatName = StatName;
+
+			// Read each stat from the leaderboard
+			for (const FColumnMetaData& Column : QueryContext->ReadObject->ColumnMetadata)
+			{
+				// Update which stat we are requesting
+				FCStringAnsi::Strncpy(StatName, TCHAR_TO_UTF8(*Column.ColumnName.ToString()), EOS_OSS_STRING_BUFFER_LENGTH);
+
+				EOS_Leaderboards_LeaderboardUserScore* LeaderboardUserScore = nullptr;
+				EOS_EResult UserCopyResult = EOS_Leaderboards_CopyLeaderboardUserScoreByUserId(EOSSubsystem->LeaderboardsHandle, &UserCopyOptions, &LeaderboardUserScore);
+				if (UserCopyResult != EOS_EResult::EOS_Success)
+				{
+					Row.Columns.Add(Column.ColumnName, FVariantData());
+					continue;
+				}
+
+				Row.Columns.Add(Column.ColumnName, FVariantData(LeaderboardUserScore->Score));
+
+				EOS_Leaderboards_LeaderboardUserScore_Release(LeaderboardUserScore);
+			}
+			QueryContext->ReadObject->Rows.Add(Row);
+		}
+
+		// Manually build the ranks by sorting and then assigning rank values
+		FName SortedColumn = QueryContext->ReadObject->SortedColumn;
+		QueryContext->ReadObject->Rows.Sort([SortedColumn](const FOnlineStatsRow& RowA, const FOnlineStatsRow& RowB)
+		{
+			const FVariantData& ValueA = RowA.Columns[SortedColumn];
+			const FVariantData& ValueB = RowB.Columns[SortedColumn];
+			if (ValueA.GetType() == ValueB.GetType())
+			{
+				int32 ScoreA = 0;
+				int32 ScoreB = 0;
+				ValueA.GetValue(ScoreA);
+				ValueB.GetValue(ScoreB);
+				return ScoreA >= ScoreB;
+			}
+			return true;
+		});
+		int32 Rank = 1;
+		for (FOnlineStatsRow& Row : QueryContext->ReadObject->Rows)
+		{
+			Row.Rank = Rank++;
+		}
+
+		QueryContext->ReadObject->ReadState = EOnlineAsyncTaskState::Done;
+
+		TriggerOnLeaderboardReadCompleteDelegates(true);
+	};
+
+	ReadObject->ReadState = EOnlineAsyncTaskState::InProgress;
+
+	EOS_Leaderboards_QueryLeaderboardUserScores(EOSSubsystem->LeaderboardsHandle, &Options, CallbackObj, CallbackObj->GetCallbackPtr());
+
+	return true;
+}
+
+bool FOnlineLeaderboardsEOS::ReadLeaderboardsForFriends(int32 LocalUserNum, FOnlineLeaderboardReadRef& ReadObject)
+{
+	TArray<TSharedRef<FOnlineFriend>> Friends;
+	EOSSubsystem->UserManager->GetFriendsList(LocalUserNum, FString(), Friends);
+	if (Friends.Num() == 0)
+	{
+		EOSSubsystem->ExecuteNextTick([this]()
+			{
+				TriggerOnLeaderboardReadCompleteDelegates(false);
+			});
+		return true;
+	}
+
+	TArray<FUniqueNetIdRef> Players;
+	Players.Reset(Friends.Num());
+
+	for (TSharedRef<const FOnlineFriend> Friend : Friends)
+	{
+		Players.Add(Friend->GetUserId());
+	}
+
+	return ReadLeaderboards(Players, ReadObject);
+}
+
+typedef TEOSCallback<EOS_Leaderboards_OnQueryLeaderboardRanksCompleteCallback, EOS_Leaderboards_OnQueryLeaderboardRanksCompleteCallbackInfo> FQueryLeaderboardCallback;
+
+bool FOnlineLeaderboardsEOS::ReadLeaderboardsAroundRank(int32 Rank, uint32 Range, FOnlineLeaderboardReadRef& ReadObject)
+{
+	if (Rank > EOS_MAX_NUM_RANKINGS)
+	{
+		UE_LOG_ONLINE_LEADERBOARD(Warning, TEXT("ReadLeaderboardsAroundRank() - Rank (%d) must be <= 1000"), Rank);
+		EOSSubsystem->ExecuteNextTick([this]()
+			{
+				TriggerOnLeaderboardReadCompleteDelegates(false);
+			});
+		return true;
+	}
+
+	// Calculate the range that we'll copy out of the full results
+	uint32 StartIndex = (uint32)FMath::Clamp<int32>(Rank - (int32)Range, 0, EOS_MAX_NUM_RANKINGS);
+	uint32 EndIndex = FMath::Clamp<uint32>(Rank + (int32)Range, 0, EOS_MAX_NUM_RANKINGS - 1);
+
+	char LeaderboardId[EOS_OSS_STRING_BUFFER_LENGTH];
+	EOS_Leaderboards_QueryLeaderboardRanksOptions Options = { };
+	Options.ApiVersion = EOS_LEADERBOARDS_QUERYLEADERBOARDRANKS_API_LATEST;
+	Options.LeaderboardId = LeaderboardId;
+	Options.LocalUserId = EOSSubsystem->UserManager->GetLocalProductUserId(0);
+	FCStringAnsi::Strncpy(LeaderboardId, TCHAR_TO_UTF8(*ReadObject->LeaderboardName.ToString()), EOS_OSS_STRING_BUFFER_LENGTH);
+
+	FQueryLeaderboardCallback* CallbackObj = new FQueryLeaderboardCallback();
+	FOnlineLeaderboardReadRef LambdaReadObject = ReadObject;
+	CallbackObj->CallbackLambda = [this, LambdaReadObject, StartIndex, EndIndex](const EOS_Leaderboards_OnQueryLeaderboardRanksCompleteCallbackInfo* Data)
+	{
+		bool bWasSuccessful = Data->ResultCode == EOS_EResult::EOS_Success;
+		if (!bWasSuccessful)
+		{
+			UE_LOG_ONLINE_LEADERBOARD(Error, TEXT("EOS_Leaderboards_QueryLeaderboardRanks() failed with EOS result code (%s)"), ANSI_TO_TCHAR(EOS_EResult_ToString(Data->ResultCode)));
+			LambdaReadObject->ReadState = EOnlineAsyncTaskState::Failed;
+			TriggerOnLeaderboardReadCompleteDelegates(false);
+			return;
+		}
+		EOS_Leaderboards_GetLeaderboardRecordCountOptions CountOptions = { };
+		CountOptions.ApiVersion = EOS_LEADERBOARDS_GETLEADERBOARDRECORDCOUNT_API_LATEST;
+
+		uint32 LeaderboardCount = EOS_Leaderboards_GetLeaderboardRecordCount(EOSSubsystem->LeaderboardsHandle, &CountOptions);
+		// Handle fewer entries than our start index
+		if (LeaderboardCount <= StartIndex)
+		{
+			LambdaReadObject->ReadState = EOnlineAsyncTaskState::Done;
+			TriggerOnLeaderboardReadCompleteDelegates(false);
+			return;
+		}
+		// Handle fewer entries than our ending page index
+		uint32 NewEndIndex = FMath::Clamp<uint32>(EndIndex, 0, LeaderboardCount - 1);
+
+		EOS_Leaderboards_CopyLeaderboardRecordByIndexOptions CopyOptions = { };
+		CopyOptions.ApiVersion = EOS_LEADERBOARDS_COPYLEADERBOARDRECORDBYINDEX_API_LATEST;
+
+		EOS_Connect_GetProductUserIdMappingOptions Options = { };
+		Options.ApiVersion = EOS_CONNECT_GETPRODUCTUSERIDMAPPING_API_LATEST;
+		Options.AccountIdType = EOS_EExternalAccountType::EOS_EAT_EPIC;
+		Options.LocalUserId = EOSSubsystem->UserManager->GetLocalProductUserId(0);
+
+		// Allow for us reading a page out of the whole stats range returned
+		for (uint32 Index = StartIndex; Index <= NewEndIndex; Index++)
+		{
+			CopyOptions.LeaderboardRecordIndex = Index;
+
+			EOS_Leaderboards_LeaderboardRecord* Record = nullptr;
+			EOS_EResult Result = EOS_Leaderboards_CopyLeaderboardRecordByIndex(EOSSubsystem->LeaderboardsHandle, &CopyOptions, &Record);
+			if (Result == EOS_EResult::EOS_Success)
+			{
+				char EpicIdStr[EOS_CONNECT_EXTERNAL_ACCOUNT_ID_MAX_LENGTH+1];
+				int32 EpicIdStrSize = sizeof(EpicIdStr);
+				Options.TargetProductUserId = Record->UserId;
+
+				Result = EOS_Connect_GetProductUserIdMapping(EOSSubsystem->ConnectHandle, &Options, EpicIdStr, &EpicIdStrSize);
+				if (Result == EOS_EResult::EOS_Success)
+				{
+					FString Nickname = UTF8_TO_TCHAR(Record->UserDisplayName);
+					if(Nickname.IsEmpty())
+					{
+						Nickname = TEXT("Unknown Player");
+					}
+					const EOS_EpicAccountId AccountId = EOS_EpicAccountId_FromString(EpicIdStr);
+					const FUniqueNetIdEOSRef NetId = FUniqueNetIdEOS::Create(MakeNetIdStringFromIds(AccountId, Record->UserId));
+
+					FOnlineStatsRow* Row = new(LambdaReadObject->Rows) FOnlineStatsRow(Nickname, NetId);
+					Row->Rank = Record->Rank;
+					Row->Columns.Add(LambdaReadObject->SortedColumn, FVariantData(Record->Score));
+				}
+			}
+		}
+
+		LambdaReadObject->ReadState = EOnlineAsyncTaskState::Done;
+		TriggerOnLeaderboardReadCompleteDelegates(true);
+	};
+
+	ReadObject->ReadState = EOnlineAsyncTaskState::InProgress;
+
+	EOS_Leaderboards_QueryLeaderboardRanks(EOSSubsystem->LeaderboardsHandle, &Options, CallbackObj, CallbackObj->GetCallbackPtr());
+
+	return true;
+}
+
+bool FOnlineLeaderboardsEOS::ReadLeaderboardsAroundUser(FUniqueNetIdRef Player, uint32 Range, FOnlineLeaderboardReadRef& ReadObject)
+{
+	TArray<FUniqueNetIdRef> Players;
+	Players.Add(Player);
+
+	return ReadLeaderboards(Players, ReadObject);
+}
+
+void FOnlineLeaderboardsEOS::FreeStats(FOnlineLeaderboardRead& ReadObject)
+{
+	// Nothing needed to be done here
+}
+
+bool FOnlineLeaderboardsEOS::WriteLeaderboards(const FName& SessionName, const FUniqueNetId& Player, FOnlineLeaderboardWrite& WriteObject)
+{
+	TArray<FOnlineStatsUserUpdatedStats> StatsToWrite;
+
+	FOnlineStatsUserUpdatedStats& UpdatedStats = StatsToWrite.Emplace_GetRef(Player.AsShared());
+	for (const TPair<FName, FVariantData>& Stat : WriteObject.Properties)
+	{
+		UpdatedStats.Stats.Add(Stat.Key.ToString(), FOnlineStatUpdate(Stat.Value, FOnlineStatUpdate::EOnlineStatModificationType::Unknown));
+	}
+
+	EOSSubsystem->StatsInterfacePtr->UpdateStats(Player.AsShared(), StatsToWrite, FOnlineStatsUpdateStatsComplete());
+	return true;
+}
+
+bool FOnlineLeaderboardsEOS::FlushLeaderboards(const FName& SessionName)
+{
+	UE_LOG_ONLINE_LEADERBOARD(Warning, TEXT("FlushLeaderboards() is not supported"));
+
+	EOSSubsystem->ExecuteNextTick([this, SessionName]()
+		{
+			TriggerOnLeaderboardFlushCompleteDelegates(SessionName, false);
+		});
+	
+	return true;
+}
+
+bool FOnlineLeaderboardsEOS::WriteOnlinePlayerRatings(const FName& SessionName, int32 LeaderboardId, const TArray<FOnlinePlayerScore>& PlayerScores)
+{
+	return false;
+}
+
+#endif
Index: FantasyBattle.sln.DotSettings.user
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/FantasyBattle.sln.DotSettings.user b/FantasyBattle.sln.DotSettings.user
new file mode 100644
--- /dev/null	(date 1641919694000)
+++ b/FantasyBattle.sln.DotSettings.user	(date 1641919694000)
@@ -0,0 +1,62 @@
+<wpf:ResourceDictionary xml:space="preserve" xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml" xmlns:s="clr-namespace:System;assembly=mscorlib" xmlns:ss="urn:shemas-jetbrains-com:settings-storage-xaml" xmlns:wpf="http://schemas.microsoft.com/winfx/2006/xaml/presentation">
+	<s:String x:Key="/Default/CodeInspection/ExcludedFiles/FilesAndFoldersToSkip2/=7020124F_002D9FFC_002D4AC3_002D8F3D_002DAAB8E0240759_002Ff_003AXAudio2_002EBuild_002Ecs_002Fl_003A_002E_002E_003F_002E_002E_003FUnrealEngine_003FEngine_003FSource_003FRuntime_003FWindows_003FXAudio2_003FXAudio2_002EBuild_002Ecs/@EntryIndexedValue">ForceIncluded</s:String>
+	
+	
+	<s:String x:Key="/Default/Environment/Hierarchy/Build/SolBuilderDuo/UseMsbuildSolutionBuilder/@EntryValue">NewVersion</s:String>
+	<s:Boolean x:Key="/Default/UnloadedProject/UnloadedProjects/=21602a33_002D996a_002D33c2_002Db079_002Dc6f2b1c2bd8a_0023BootstrapPackagedGame/@EntryIndexedValue">True</s:Boolean>
+	<s:Boolean x:Key="/Default/UnloadedProject/UnloadedProjects/=3dfd7085_002Dd0be_002D3a0f_002D9c1b_002D7565551cc7be_0023ZenDashboard/@EntryIndexedValue">True</s:Boolean>
+	<s:Boolean x:Key="/Default/UnloadedProject/UnloadedProjects/=45097151_002D6d31_002D3466_002Dba74_002De2db2983faac_0023BaseTextureBuildWorker/@EntryIndexedValue">True</s:Boolean>
+	<s:Boolean x:Key="/Default/UnloadedProject/UnloadedProjects/=2d73867f_002Da47e_002D370d_002D99a3_002D521d6b6f7d66_0023DatasmithUE4ArchiCAD/@EntryIndexedValue">True</s:Boolean>
+	<s:Boolean x:Key="/Default/UnloadedProject/UnloadedProjects/=4eb073fc_002Db79f_002D3c00_002Db571_002De4d69bac30ee_0023DatasmithArchiCAD/@EntryIndexedValue">True</s:Boolean>
+	<s:Boolean x:Key="/Default/UnloadedProject/UnloadedProjects/=a4da7380_002D5c78_002D310b_002D87a0_002D33b7c850159a_0023DatasmithCADWorker/@EntryIndexedValue">True</s:Boolean>
+	<s:Boolean x:Key="/Default/UnloadedProject/UnloadedProjects/=414ce8c9_002D2d1b_002D3d82_002Dbe3f_002D0bb240304259_0023DatasmithFacadeCSharp/@EntryIndexedValue">True</s:Boolean>
+	<s:Boolean x:Key="/Default/UnloadedProject/UnloadedProjects/=70bae1ac_002D6899_002D3007_002Da3c9_002D804f14895510_0023DatasmithMax2016/@EntryIndexedValue">True</s:Boolean>
+	<s:Boolean x:Key="/Default/UnloadedProject/UnloadedProjects/=3bde35b6_002D45e2_002D37d4_002D94e8_002Db0439b9ea084_0023DatasmithMax2017/@EntryIndexedValue">True</s:Boolean>
+	<s:Boolean x:Key="/Default/UnloadedProject/UnloadedProjects/=448bf37d_002D0538_002D3b1a_002Db9a2_002Dcf65d9193a1f_0023DatasmithMax2018/@EntryIndexedValue">True</s:Boolean>
+	<s:Boolean x:Key="/Default/UnloadedProject/UnloadedProjects/=caed7318_002D6bac_002D33d8_002D8e97_002Db11f35213321_0023DatasmithMax2019/@EntryIndexedValue">True</s:Boolean>
+	<s:Boolean x:Key="/Default/UnloadedProject/UnloadedProjects/=06742240_002Dce76_002D30eb_002Db9f4_002D5a94dc854f1c_0023DatasmithMax2020/@EntryIndexedValue">True</s:Boolean>
+	<s:Boolean x:Key="/Default/UnloadedProject/UnloadedProjects/=af31c979_002Ddbdc_002D3168_002Dab43_002Da49a84123bb3_0023DatasmithMax2021/@EntryIndexedValue">True</s:Boolean>
+	<s:Boolean x:Key="/Default/UnloadedProject/UnloadedProjects/=02241c79_002D2521_002D3f36_002D83b3_002D7cacd8a89488_0023DatasmithMax2022/@EntryIndexedValue">True</s:Boolean>
+	<s:Boolean x:Key="/Default/UnloadedProject/UnloadedProjects/=bf285745_002D120f_002D3920_002D83a3_002D460cd3df4065_0023DatasmithNavisworks2019/@EntryIndexedValue">True</s:Boolean>
+	<s:Boolean x:Key="/Default/UnloadedProject/UnloadedProjects/=33c91a56_002D8e14_002D3a7b_002Db3eb_002D769b837aa12b_0023DatasmithNavisworks2020/@EntryIndexedValue">True</s:Boolean>
+	<s:Boolean x:Key="/Default/UnloadedProject/UnloadedProjects/=f6e0293f_002D34c2_002D3d23_002Dae87_002D2c52a590dd39_0023DatasmithNavisworks2021/@EntryIndexedValue">True</s:Boolean>
+	<s:Boolean x:Key="/Default/UnloadedProject/UnloadedProjects/=6e216b2a_002Ddc4b_002D3595_002D9131_002D114f107e7adc_0023DatasmithNavisworks2022/@EntryIndexedValue">True</s:Boolean>
+	<s:Boolean x:Key="/Default/UnloadedProject/UnloadedProjects/=be09bc3b_002D19c4_002D332d_002Dbebf_002D9ba375109d37_0023DatasmithRevit2018/@EntryIndexedValue">True</s:Boolean>
+	<s:Boolean x:Key="/Default/UnloadedProject/UnloadedProjects/=b8171f5d_002Dd724_002D3c9a_002D8eb0_002Dda57d748d793_0023DatasmithRevit2019/@EntryIndexedValue">True</s:Boolean>
+	<s:Boolean x:Key="/Default/UnloadedProject/UnloadedProjects/=d5a1d2aa_002Dca5b_002D3660_002D9d24_002D461e7e570128_0023DatasmithRevit2020/@EntryIndexedValue">True</s:Boolean>
+	<s:Boolean x:Key="/Default/UnloadedProject/UnloadedProjects/=a710c9a2_002D082b_002D3be7_002Da98e_002D0141509dc06d_0023DatasmithRevit2021/@EntryIndexedValue">True</s:Boolean>
+	<s:Boolean x:Key="/Default/UnloadedProject/UnloadedProjects/=af3b0a77_002D64d3_002D3fe2_002D974a_002Df00f764d0605_0023DatasmithRevit2022/@EntryIndexedValue">True</s:Boolean>
+	<s:Boolean x:Key="/Default/UnloadedProject/UnloadedProjects/=13bec603_002D3757_002D3c18_002Db715_002D8cd305bbcf98_0023DatasmithRhino6/@EntryIndexedValue">True</s:Boolean>
+	<s:Boolean x:Key="/Default/UnloadedProject/UnloadedProjects/=c3d3e4c0_002Dd10a_002D385d_002D8693_002D986b203d1bda_0023DatasmithRhino7/@EntryIndexedValue">True</s:Boolean>
+	<s:Boolean x:Key="/Default/UnloadedProject/UnloadedProjects/=8efabc11_002D9dbc_002D3d94_002D847f_002D66bd410f66b6_0023DatasmithSDK/@EntryIndexedValue">True</s:Boolean>
+	<s:Boolean x:Key="/Default/UnloadedProject/UnloadedProjects/=d5a8693c_002D580f_002D3436_002D8d85_002Dbc4bef8d4746_0023DatasmithSketchUpRuby2019/@EntryIndexedValue">True</s:Boolean>
+	<s:Boolean x:Key="/Default/UnloadedProject/UnloadedProjects/=1d14ed53_002D12d3_002D3ff7_002Dbb03_002Dcbb3ad42b2c8_0023DatasmithSketchUpRuby2020/@EntryIndexedValue">True</s:Boolean>
+	<s:Boolean x:Key="/Default/UnloadedProject/UnloadedProjects/=8a79a860_002Daa7d_002D3e50_002D88d3_002Dfae35044fa45_0023DatasmithSketchUpRuby2021/@EntryIndexedValue">True</s:Boolean>
+	<s:Boolean x:Key="/Default/UnloadedProject/UnloadedProjects/=1a4107b9_002D5dc8_002D346a_002D8838_002D7f715ebaf8ba_0023DatasmithSolidworks2021/@EntryIndexedValue">True</s:Boolean>
+	<s:Boolean x:Key="/Default/UnloadedProject/UnloadedProjects/=04693b59_002D3f0e_002D319e_002Db27e_002D430880214d56_0023TextureShareSDK/@EntryIndexedValue">True</s:Boolean>
+	<s:Boolean x:Key="/Default/UnloadedProject/UnloadedProjects/=f2073a0a_002D0058_002D30a2_002Db349_002D9163a813a954_0023BenchmarkTool/@EntryIndexedValue">True</s:Boolean>
+	<s:Boolean x:Key="/Default/UnloadedProject/UnloadedProjects/=d3532444_002Da366_002D3e4b_002Dbfd7_002D35fbfb59e7c0_0023BlankProgram/@EntryIndexedValue">True</s:Boolean>
+	<s:Boolean x:Key="/Default/UnloadedProject/UnloadedProjects/=d9fe48d2_002D6aab_002D356d_002Db2f1_002D80b8ccadf9ee_0023BuildPatchTool/@EntryIndexedValue">True</s:Boolean>
+	<s:Boolean x:Key="/Default/UnloadedProject/UnloadedProjects/=ea4495b9_002Db3a4_002D359c_002D8583_002D26804bd65f69_0023ChaosVisualDebugger/@EntryIndexedValue">True</s:Boolean>
+	<s:Boolean x:Key="/Default/UnloadedProject/UnloadedProjects/=50c66432_002Ddca6_002D39bc_002Db857_002D4f1156cc4451_0023CrashReportClient/@EntryIndexedValue">True</s:Boolean>
+	<s:Boolean x:Key="/Default/UnloadedProject/UnloadedProjects/=505fb70a_002Dc5c4_002D3e61_002D8273_002D97ba223fe4ff_0023CrashReportClientEditor/@EntryIndexedValue">True</s:Boolean>
+	<s:Boolean x:Key="/Default/UnloadedProject/UnloadedProjects/=a8b1b219_002Df85d_002D30a7_002D8790_002Db44a8af3fe43_0023EpicWebHelper/@EntryIndexedValue">True</s:Boolean>
+	<s:Boolean x:Key="/Default/UnloadedProject/UnloadedProjects/=afe395d6_002Deeea_002D3e05_002Dba95_002D898d3060ea9d_0023HeadlessChaosPerf/@EntryIndexedValue">True</s:Boolean>
+	<s:Boolean x:Key="/Default/UnloadedProject/UnloadedProjects/=c65c2248_002Dc61f_002D3a3b_002Da8c4_002Dc96a329de004_0023HeadlessChaos/@EntryIndexedValue">True</s:Boolean>
+	<s:Boolean x:Key="/Default/UnloadedProject/UnloadedProjects/=d37363dc_002Da149_002D346c_002Db8e0_002D1d0dde0c5cf0_0023InterchangeWorker/@EntryIndexedValue">True</s:Boolean>
+	<s:Boolean x:Key="/Default/UnloadedProject/UnloadedProjects/=abaa1992_002Df2ad_002D3bf9_002Da77a_002De1ae4942c436_0023LiveCodingConsole/@EntryIndexedValue">True</s:Boolean>
+	<s:Boolean x:Key="/Default/UnloadedProject/UnloadedProjects/=1edf1c96_002Dba0f_002D3a6f_002D8b31_002Dfbda5c94ede4_0023LowLevelTests/@EntryIndexedValue">True</s:Boolean>
+	<s:Boolean x:Key="/Default/UnloadedProject/UnloadedProjects/=574e4d71_002Dd317_002D336b_002D92ca_002D8135a1b1fb66_0023ShaderCompileWorker/@EntryIndexedValue">True</s:Boolean>
+	<s:Boolean x:Key="/Default/UnloadedProject/UnloadedProjects/=3214cc66_002D3e94_002D3a1f_002D9bd1_002D06003e653136_0023SlateViewer/@EntryIndexedValue">True</s:Boolean>
+	<s:Boolean x:Key="/Default/UnloadedProject/UnloadedProjects/=6703d56c_002Dae09_002D36f1_002Dadaa_002D8de86a5ed6ab_0023SwitchboardListener/@EntryIndexedValue">True</s:Boolean>
+	<s:Boolean x:Key="/Default/UnloadedProject/UnloadedProjects/=7ec0b66b_002Dc852_002D3d27_002D9423_002D1c67198500bd_0023TestPAL/@EntryIndexedValue">True</s:Boolean>
+	<s:Boolean x:Key="/Default/UnloadedProject/UnloadedProjects/=5f67958c_002D02d9_002D3ec1_002D84a2_002Db113ba69fc75_0023UnrealFrontend/@EntryIndexedValue">True</s:Boolean>
+	<s:Boolean x:Key="/Default/UnloadedProject/UnloadedProjects/=9978e18f_002D2bbe_002D3b3b_002Daf0b_002D47b9e6a901f0_0023UnrealHeaderTool/@EntryIndexedValue">True</s:Boolean>
+	<s:Boolean x:Key="/Default/UnloadedProject/UnloadedProjects/=5f84faa4_002D94b2_002D32e5_002Da2f7_002Dcd793f9c6195_0023UnrealInsights/@EntryIndexedValue">True</s:Boolean>
+	<s:Boolean x:Key="/Default/UnloadedProject/UnloadedProjects/=b0f1d209_002Dd501_002D3f10_002Db36f_002D04d3f583b1d8_0023UnrealLightmass/@EntryIndexedValue">True</s:Boolean>
+	<s:Boolean x:Key="/Default/UnloadedProject/UnloadedProjects/=e3d16099_002De171_002D390d_002D8235_002D688f1b486370_0023UnrealMultiUserServer/@EntryIndexedValue">True</s:Boolean>
+	<s:Boolean x:Key="/Default/UnloadedProject/UnloadedProjects/=0c688aa3_002Dcdc1_002D3806_002Daad9_002Df5b654559cdb_0023UnrealObjectPtrTool/@EntryIndexedValue">True</s:Boolean>
+	<s:Boolean x:Key="/Default/UnloadedProject/UnloadedProjects/=47aac367_002D979f_002D374d_002Da85d_002D32861dcf4abd_0023UnrealPak/@EntryIndexedValue">True</s:Boolean>
+	<s:Boolean x:Key="/Default/UnloadedProject/UnloadedProjects/=0f77a34f_002D725e_002D3fa4_002Dbd75_002D4a2748d9d861_0023UnrealRecoverySvc/@EntryIndexedValue">True</s:Boolean>
+	<s:Boolean x:Key="/Default/UnloadedProject/UnloadedProjects/=3a2b2fd8_002D7663_002D308b_002Db2db_002D053e01f6cd2f_0023UnrealVersionSelector/@EntryIndexedValue">True</s:Boolean>
+	</wpf:ResourceDictionary>
\ No newline at end of file
Index: Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Private/OnlineTitleFileEOS.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Private/OnlineTitleFileEOS.h b/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Private/OnlineTitleFileEOS.h
new file mode 100644
--- /dev/null	(date 1641576012000)
+++ b/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Private/OnlineTitleFileEOS.h	(date 1641576012000)
@@ -0,0 +1,72 @@
+// Copyright Epic Games, Inc. All Rights Reserved.
+
+#pragma once
+
+#include "CoreMinimal.h"
+#include "Online/CoreOnline.h"
+#include "Interfaces/OnlineTitleFileInterface.h"
+#include "OnlineSubsystemEOSPackage.h"
+#include "OnlineSubsystemEOSTypes.h"
+
+class FOnlineSubsystemEOS;
+
+#if WITH_EOS_SDK
+#include "eos_titlestorage_types.h"
+
+struct FEOSTitleFile
+{
+	TArray<uint8> Contents;
+	size_t ContentSize;
+	size_t ContentIndex;
+	bool bIsLoaded;
+	bool bInProgress;
+	FString Filename;
+	EOS_HTitleStorageFileTransferRequest FileTransferRequest;		// TODO: Mark.Fitt this does not auto release
+
+	FEOSTitleFile() : ContentSize(0), ContentIndex(0), bIsLoaded(false), bInProgress(false)
+	{
+	}
+
+	void Unload();
+};
+
+using FTitleFileCollection = TMap<FString, FEOSTitleFile>;
+
+class FOnlineTitleFileEOS
+	: public IOnlineTitleFile, public TSharedFromThis<FOnlineTitleFileEOS, ESPMode::ThreadSafe>
+{
+public:
+	FOnlineTitleFileEOS() = delete;
+	virtual ~FOnlineTitleFileEOS() = default;
+
+//~IOnlineTitleFile
+	virtual bool GetFileContents(const FString& FileName, TArray<uint8>& FileContents) override;
+	virtual bool ClearFiles() override;
+	virtual bool ClearFile(const FString& FileName) override;
+	virtual void DeleteCachedFiles(bool bSkipEnumerated) override;
+	virtual bool EnumerateFiles(const FPagedQuery& Page = FPagedQuery()) override;
+	virtual void GetFileList(TArray<FCloudFileHeader>& Files) override;
+	virtual bool ReadFile(const FString& FileName) override;
+//~IOnlineTitleFile
+
+PACKAGE_SCOPE:
+	FOnlineTitleFileEOS(FOnlineSubsystemEOS* InSubsystem)
+		: EOSSubsystem(InSubsystem)
+	{
+	}
+
+	bool HandleTitleFileExec(UWorld* InWorld, const TCHAR* Cmd, FOutputDevice& Ar);
+
+protected:
+	FOnlineSubsystemEOS* EOSSubsystem;
+
+private:
+	/** Results of the last file enumeration */
+	TArray<FCloudFileHeader> QueryFileSet;
+	/** The list of available files, indexed by filename that have been or are loaded */
+	FTitleFileCollection FileSet;
+};
+
+typedef TSharedPtr<FOnlineTitleFileEOS, ESPMode::ThreadSafe> FOnlineTitleFileEOSPtr;
+
+#endif
\ No newline at end of file
Index: Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Private/SocketEOS.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Private/SocketEOS.h b/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Private/SocketEOS.h
new file mode 100644
--- /dev/null	(date 1641575208000)
+++ b/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Private/SocketEOS.h	(date 1641575208000)
@@ -0,0 +1,105 @@
+// Copyright Epic Games, Inc. All Rights Reserved.
+
+#pragma once
+
+#include "CoreMinimal.h"
+#include "Sockets.h"
+#include "InternetAddrEOS.h"
+#include "Engine/World.h"
+#include "OnlineSubsystemEOSTypes.h"
+
+class FOnlineSubsystemEOS;
+class FSocketSubsystemEOS;
+
+#define WANTS_NP_LOGGING 0
+
+#if WANTS_NP_LOGGING
+	#define NP_LOG(Msg, ...) NpLog(*FString::Printf(Msg, __VA_ARGS__))
+
+	void NpLog(const TCHAR* Msg);
+#else
+	#define NP_LOG(Msg, ...)
+#endif
+
+#if WITH_EOS_SDK
+	#include "eos_p2p_types.h"
+
+	typedef TEOSGlobalCallback<EOS_P2P_OnIncomingConnectionRequestCallback, EOS_P2P_OnIncomingConnectionRequestInfo> FConnectNotifyCallback;
+	typedef TEOSGlobalCallback<EOS_P2P_OnRemoteConnectionClosedCallback, EOS_P2P_OnRemoteConnectionClosedInfo> FClosedNotifyCallback;
+#endif
+
+class FSocketEOS
+	: public FSocket
+{
+public:
+	FSocketEOS(FSocketSubsystemEOS& SocketSubsystem, const FString& InSocketDescription);
+	virtual ~FSocketEOS();
+
+	//~ Begin FSocket Interface
+	virtual bool Shutdown(ESocketShutdownMode Mode) override;
+	virtual bool Close() override;
+	virtual bool Bind(const FInternetAddr& Addr) override;
+	virtual bool Connect(const FInternetAddr& Addr) override;
+	virtual bool Listen(int32 MaxBacklog) override;
+	virtual bool WaitForPendingConnection(bool& bHasPendingConnection, const FTimespan& WaitTime) override;
+	virtual bool HasPendingData(uint32& PendingDataSize) override;
+	virtual class FSocket* Accept(const FString& InSocketDescription) override;
+	virtual class FSocket* Accept(FInternetAddr& OutAddr, const FString& InSocketDescription) override;
+	virtual bool SendTo(const uint8* Data, int32 Count, int32& BytesSent, const FInternetAddr& Destination) override;
+	virtual bool Send(const uint8* Data, int32 Count, int32& BytesSent) override;
+	virtual bool RecvFrom(uint8* Data, int32 BufferSize, int32& BytesRead, FInternetAddr& Source, ESocketReceiveFlags::Type Flags = ESocketReceiveFlags::None) override;
+	virtual bool Recv(uint8* Data, int32 BufferSize, int32& BytesRead, ESocketReceiveFlags::Type Flags = ESocketReceiveFlags::None) override;
+	virtual bool Wait(ESocketWaitConditions::Type Condition, FTimespan WaitTime) override;
+	virtual ESocketConnectionState GetConnectionState() override;
+	virtual void GetAddress(FInternetAddr& OutAddr) override;
+	virtual bool GetPeerAddress(FInternetAddr& OutAddr) override;
+	virtual bool SetNonBlocking(bool bIsNonBlocking = true) override;
+	virtual bool SetBroadcast(bool bAllowBroadcast = true) override;
+	virtual bool SetNoDelay(bool bIsNoDelay = true) override;
+	virtual bool JoinMulticastGroup(const FInternetAddr& GroupAddress) override;
+	virtual bool LeaveMulticastGroup(const FInternetAddr& GroupAddress) override;
+	virtual bool SetMulticastLoopback(bool bLoopback) override;
+	virtual bool SetMulticastTtl(uint8 TimeToLive) override;
+	virtual bool JoinMulticastGroup(const FInternetAddr& GroupAddress, const FInternetAddr& InterfaceAddress) override;
+	virtual bool LeaveMulticastGroup(const FInternetAddr& GroupAddress, const FInternetAddr& InterfaceAddress) override;
+	virtual bool SetMulticastInterface(const FInternetAddr& InterfaceAddress) override;
+	virtual bool SetReuseAddr(bool bAllowReuse = true) override;
+	virtual bool SetLinger(bool bShouldLinger = true, int32 Timeout = 0) override;
+	virtual bool SetRecvErr(bool bUseErrorQueue = true) override;
+	virtual bool SetSendBufferSize(int32 Size, int32& NewSize) override;
+	virtual bool SetReceiveBufferSize(int32 Size, int32& NewSize) override;
+	virtual int32 GetPortNo() override;
+	//~ End FSocket Interface
+
+	void SetLocalAddress(const FInternetAddrEOS& InLocalAddress);
+
+	bool Close(const FInternetAddrEOS& RemoteAddress);
+
+	bool WasClosed(const FInternetAddrEOS& RemoteAddress)
+	{
+		int32 Index = -1;
+		return ClosedRemotes.Find(RemoteAddress, Index);
+	}
+
+	void RegisterClosedNotification();
+
+private:
+	/** Reference to our subsystem */
+	FSocketSubsystemEOS& SocketSubsystem;
+
+	/** Our local address; session/port will be invalid when not bound */
+	FInternetAddrEOS LocalAddress;
+
+	/** Are we currently listening? */
+	bool bIsListening;
+
+	TArray<FInternetAddrEOS> ClosedRemotes;
+
+#if WITH_EOS_SDK
+	FConnectNotifyCallback* ConnectNotifyCallback;
+	EOS_NotificationId ConnectNotifyId;
+
+	FClosedNotifyCallback* ClosedNotifyCallback;
+	EOS_NotificationId ClosedNotifyId;
+#endif
+};
Index: Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Private/OnlineSubsystemModuleEOS.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Private/OnlineSubsystemModuleEOS.cpp b/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Private/OnlineSubsystemModuleEOS.cpp
new file mode 100644
--- /dev/null	(date 1641575208000)
+++ b/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Private/OnlineSubsystemModuleEOS.cpp	(date 1641575208000)
@@ -0,0 +1,119 @@
+// Copyright Epic Games, Inc. All Rights Reserved.
+
+#include "OnlineSubsystemEOSModule.h"
+#include "OnlineSubsystemModule.h"
+#include "OnlineSubsystemNames.h"
+#include "OnlineSubsystemEOS.h"
+#include "EOSSettings.h"
+
+#include "Features/IModularFeature.h"
+#include "Features/IModularFeatures.h"
+
+#include "Misc/CoreDelegates.h"
+#include "Misc/ConfigCacheIni.h"
+
+#if WITH_EDITOR
+	#include "ISettingsModule.h"
+	#include "ISettingsSection.h"
+#endif
+
+#define LOCTEXT_NAMESPACE "EOS"
+
+IMPLEMENT_MODULE(FOnlineSubsystemEOSModule, OnlineSubsystemEOS);
+
+/**
+ * Class responsible for creating instance(s) of the subsystem
+ */
+class FOnlineFactoryEOS :
+	public IOnlineFactory
+{
+public:
+
+	FOnlineFactoryEOS() {}
+	virtual ~FOnlineFactoryEOS() {}
+
+	virtual IOnlineSubsystemPtr CreateSubsystem(FName InstanceName)
+	{
+		FOnlineSubsystemEOSPtr OnlineSub = MakeShared<FOnlineSubsystemEOS, ESPMode::ThreadSafe>(InstanceName);
+		if (!OnlineSub->Init())
+		{
+			UE_LOG_ONLINE(Warning, TEXT("EOS API failed to initialize!"));
+			OnlineSub->Shutdown();
+			OnlineSub = nullptr;
+		}
+
+		return OnlineSub;
+	}
+};
+
+void FOnlineSubsystemEOSModule::StartupModule()
+{
+	if (IsRunningCommandlet())
+	{
+		return;
+	}
+
+	EOSFactory = new FOnlineFactoryEOS();
+
+	// Create and register our singleton factory with the main online subsystem for easy access
+	FOnlineSubsystemModule& OSS = FModuleManager::GetModuleChecked<FOnlineSubsystemModule>("OnlineSubsystem");
+	OSS.RegisterPlatformService(EOS_SUBSYSTEM, EOSFactory);
+
+#if WITH_EOS_SDK
+	// Have to call this as early as possible in order to hook the rendering device
+	FOnlineSubsystemEOS::ModuleInit();
+#endif
+
+#if WITH_EDITOR
+	FCoreDelegates::OnPostEngineInit.AddRaw(this, &FOnlineSubsystemEOSModule::OnPostEngineInit);
+	FCoreDelegates::OnPreExit.AddRaw(this, &FOnlineSubsystemEOSModule::OnPreExit);
+#endif
+}
+
+#if WITH_EDITOR
+void FOnlineSubsystemEOSModule::OnPostEngineInit()
+{
+	if (ISettingsModule* SettingsModule = FModuleManager::GetModulePtr<ISettingsModule>("Settings"))
+	{
+		SettingsModule->RegisterSettings("Project", "Plugins", "Online Subsystem EOS",
+			LOCTEXT("OSSEOSSettingsName", "Online Subsystem EOS"),
+			LOCTEXT("OSSEOSSettingsDescription", "Configure Online Subsystem EOS"),
+			GetMutableDefault<UEOSSettings>());
+	}
+}
+#endif
+
+#if WITH_EDITOR
+void FOnlineSubsystemEOSModule::OnPreExit()
+{
+	if (ISettingsModule* SettingsModule = FModuleManager::GetModulePtr<ISettingsModule>("Settings"))
+	{
+		SettingsModule->UnregisterSettings("Project", "Plugins", "Online Subsystem EOS");
+	}
+}
+#endif
+
+void FOnlineSubsystemEOSModule::ShutdownModule()
+{
+	if (IsRunningCommandlet())
+	{
+		return;
+	}
+
+#if WITH_EDITOR
+	FCoreDelegates::OnPostEngineInit.RemoveAll(this);
+	FCoreDelegates::OnPreExit.RemoveAll(this);
+#endif
+
+#if WITH_EOS_SDK
+	FOnlineSubsystemEOS::ModuleShutdown();
+#endif
+
+	FOnlineSubsystemModule& OSS = FModuleManager::GetModuleChecked<FOnlineSubsystemModule>("OnlineSubsystem");
+	OSS.UnregisterPlatformService(EOS_SUBSYSTEM);
+
+	delete EOSFactory;
+	EOSFactory = nullptr;
+}
+
+#undef LOCTEXT_NAMESPACE
Index: Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Private/OnlineSessionEOS.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Private/OnlineSessionEOS.h b/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Private/OnlineSessionEOS.h
new file mode 100644
--- /dev/null	(date 1641576012000)
+++ b/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Private/OnlineSessionEOS.h	(date 1641576012000)
@@ -0,0 +1,314 @@
+// Copyright Epic Games, Inc. All Rights Reserved.
+
+#pragma once
+
+#include "Misc/ScopeLock.h"
+#include "OnlineSessionSettings.h"
+#include "Interfaces/OnlineSessionInterface.h"
+#include "OnlineSubsystemEOSPackage.h"
+#include "LANBeacon.h"
+#include "OnlineSubsystemEOSTypes.h"
+
+class FOnlineSubsystemEOS;
+
+#if WITH_EOS_SDK
+	#include "eos_sessions_types.h"
+	#include "eos_lobby_types.h"
+
+
+typedef TEOSCallback<EOS_Sessions_OnUpdateSessionCallback, EOS_Sessions_UpdateSessionCallbackInfo> FUpdateSessionCallback;
+
+struct FSessionSearchEOS
+{
+	EOS_HSessionSearch SearchHandle;
+
+	FSessionSearchEOS(EOS_HSessionSearch InSearchHandle)
+		: SearchHandle(InSearchHandle)
+	{
+	}
+
+	virtual ~FSessionSearchEOS()
+	{
+		EOS_SessionSearch_Release(SearchHandle);
+	}
+};
+
+/**
+ * Interface for interacting with EOS sessions
+ */
+class FOnlineSessionEOS :
+	public IOnlineSession
+{
+public:
+	FOnlineSessionEOS() = delete;
+	virtual ~FOnlineSessionEOS();
+
+	virtual FUniqueNetIdPtr CreateSessionIdFromString(const FString& SessionIdStr) override;
+
+	FNamedOnlineSession* GetNamedSession(FName SessionName) override
+	{
+		FScopeLock ScopeLock(&SessionLock);
+		for (int32 SearchIndex = 0; SearchIndex < Sessions.Num(); SearchIndex++)
+		{
+			if (Sessions[SearchIndex].SessionName == SessionName)
+			{
+				return &Sessions[SearchIndex];
+			}
+		}
+		return nullptr;
+	}
+
+	virtual void RemoveNamedSession(FName SessionName) override
+	{
+		FScopeLock ScopeLock(&SessionLock);
+		for (int32 SearchIndex = 0; SearchIndex < Sessions.Num(); SearchIndex++)
+		{
+			if (Sessions[SearchIndex].SessionName == SessionName)
+			{
+				Sessions.RemoveAtSwap(SearchIndex);
+				return;
+			}
+		}
+	}
+
+	virtual EOnlineSessionState::Type GetSessionState(FName SessionName) const override
+	{
+		FScopeLock ScopeLock(&SessionLock);
+		for (int32 SearchIndex = 0; SearchIndex < Sessions.Num(); SearchIndex++)
+		{
+			if (Sessions[SearchIndex].SessionName == SessionName)
+			{
+				return Sessions[SearchIndex].SessionState;
+			}
+		}
+
+		return EOnlineSessionState::NoSession;
+	}
+
+	virtual bool HasPresenceSession() override
+	{
+		FScopeLock ScopeLock(&SessionLock);
+		for (int32 SearchIndex = 0; SearchIndex < Sessions.Num(); SearchIndex++)
+		{
+			if (Sessions[SearchIndex].SessionSettings.bUsesPresence)
+			{
+				return true;
+			}
+		}
+
+		return false;
+	}
+
+// IOnlineSession Interface
+	virtual bool CreateSession(int32 HostingPlayerNum, FName SessionName, const FOnlineSessionSettings& NewSessionSettings) override;
+	virtual bool CreateSession(const FUniqueNetId& HostingPlayerId, FName SessionName, const FOnlineSessionSettings& NewSessionSettings) override;
+	virtual bool StartSession(FName SessionName) override;
+	virtual bool UpdateSession(FName SessionName, FOnlineSessionSettings& UpdatedSessionSettings, bool bShouldRefreshOnlineData = true) override;
+	virtual bool EndSession(FName SessionName) override;
+	virtual bool DestroySession(FName SessionName, const FOnDestroySessionCompleteDelegate& CompletionDelegate = FOnDestroySessionCompleteDelegate()) override;
+	virtual bool IsPlayerInSession(FName SessionName, const FUniqueNetId& UniqueId) override;
+	virtual bool StartMatchmaking(const TArray< FUniqueNetIdRef >& LocalPlayers, FName SessionName, const FOnlineSessionSettings& NewSessionSettings, TSharedRef<FOnlineSessionSearch>& SearchSettings) override;
+	virtual bool CancelMatchmaking(int32 SearchingPlayerNum, FName SessionName) override;
+	virtual bool CancelMatchmaking(const FUniqueNetId& SearchingPlayerId, FName SessionName) override;
+	virtual bool FindSessions(int32 SearchingPlayerNum, const TSharedRef<FOnlineSessionSearch>& SearchSettings) override;
+	virtual bool FindSessions(const FUniqueNetId& SearchingPlayerId, const TSharedRef<FOnlineSessionSearch>& SearchSettings) override;
+	virtual bool FindSessionById(const FUniqueNetId& SearchingUserId, const FUniqueNetId& SessionId, const FUniqueNetId& FriendId, const FOnSingleSessionResultCompleteDelegate& CompletionDelegate) override;
+	virtual bool CancelFindSessions() override;
+	virtual bool PingSearchResults(const FOnlineSessionSearchResult& SearchResult) override;
+	virtual bool JoinSession(int32 PlayerNum, FName SessionName, const FOnlineSessionSearchResult& DesiredSession) override;
+	virtual bool JoinSession(const FUniqueNetId& PlayerId, FName SessionName, const FOnlineSessionSearchResult& DesiredSession) override;
+	virtual bool FindFriendSession(int32 LocalUserNum, const FUniqueNetId& Friend) override;
+	virtual bool FindFriendSession(const FUniqueNetId& LocalUserId, const FUniqueNetId& Friend) override;
+	virtual bool FindFriendSession(const FUniqueNetId& LocalUserId, const TArray<FUniqueNetIdRef>& FriendList) override;
+	virtual bool SendSessionInviteToFriend(int32 LocalUserNum, FName SessionName, const FUniqueNetId& Friend) override;
+	virtual bool SendSessionInviteToFriend(const FUniqueNetId& LocalUserId, FName SessionName, const FUniqueNetId& Friend) override;
+	virtual bool SendSessionInviteToFriends(int32 LocalUserNum, FName SessionName, const TArray< FUniqueNetIdRef >& Friends) override;
+	virtual bool SendSessionInviteToFriends(const FUniqueNetId& LocalUserId, FName SessionName, const TArray< FUniqueNetIdRef >& Friends) override;
+	virtual bool GetResolvedConnectString(FName SessionName, FString& ConnectInfo, FName PortType) override;
+	virtual bool GetResolvedConnectString(const FOnlineSessionSearchResult& SearchResult, FName PortType, FString& ConnectInfo) override;
+	virtual FOnlineSessionSettings* GetSessionSettings(FName SessionName) override;
+	virtual bool RegisterPlayer(FName SessionName, const FUniqueNetId& PlayerId, bool bWasInvited) override;
+	virtual bool RegisterPlayers(FName SessionName, const TArray< FUniqueNetIdRef >& Players, bool bWasInvited = false) override;
+	virtual bool UnregisterPlayer(FName SessionName, const FUniqueNetId& PlayerId) override;
+	virtual bool UnregisterPlayers(FName SessionName, const TArray< FUniqueNetIdRef >& Players) override;
+	virtual void RegisterLocalPlayer(const FUniqueNetId& PlayerId, FName SessionName, const FOnRegisterLocalPlayerCompleteDelegate& Delegate) override;
+	virtual void UnregisterLocalPlayer(const FUniqueNetId& PlayerId, FName SessionName, const FOnUnregisterLocalPlayerCompleteDelegate& Delegate) override;
+	virtual void RemovePlayerFromSession(int32 LocalUserNum, FName SessionName, const FUniqueNetId& TargetPlayerId) override;
+	virtual int32 GetNumSessions() override;
+	virtual void DumpSessionState() override;
+// ~IOnlineSession Interface
+
+PACKAGE_SCOPE:
+	/** Critical sections for thread safe operation of session lists */
+	mutable FCriticalSection SessionLock;
+
+	/** Current session settings */
+	TArray<FNamedOnlineSession> Sessions;
+
+	/** Current search object */
+	TSharedPtr<FOnlineSessionSearch> CurrentSessionSearch;
+
+	/** Current search start time. */
+	double SessionSearchStartInSeconds;
+
+	FOnlineSessionEOS(FOnlineSubsystemEOS* InSubsystem)
+		: CurrentSessionSearch(nullptr)
+		, SessionSearchStartInSeconds(0)
+		, EOSSubsystem(InSubsystem)
+	{
+	}
+
+	/**
+	 * Session tick for various background tasks
+	 */
+	void Tick(float DeltaTime);
+
+	// IOnlineSession
+	class FNamedOnlineSession* AddNamedSession(FName SessionName, const FOnlineSessionSettings& SessionSettings) override
+	{
+		FScopeLock ScopeLock(&SessionLock);
+		return new (Sessions) FNamedOnlineSession(SessionName, SessionSettings);
+	}
+
+	class FNamedOnlineSession* AddNamedSession(FName SessionName, const FOnlineSession& Session) override
+	{
+		FScopeLock ScopeLock(&SessionLock);
+		return new (Sessions) FNamedOnlineSession(SessionName, Session);
+	}
+
+	void CheckPendingSessionInvite();
+
+	void RegisterLocalPlayers(class FNamedOnlineSession* Session);
+
+	void Init(const FString& InBucketId);
+
+private:
+	// EOS Lobbies
+
+	EOS_HLobby LobbyHandle;
+	TMap<FString, TSharedRef<EOS_HLobbyDetails>> LobbySearchResultsCache;
+
+	// Lobby session callbacks and methods
+	FCallbackBase* LobbyCreatedCallback;
+	FCallbackBase* LobbySearchFindCallback;
+	FCallbackBase* LobbyJoinedCallback;
+	FCallbackBase* LobbyLeftCallback;
+	FCallbackBase* LobbyDestroyedCallback;
+	FCallbackBase* LobbySendInviteCallback;
+
+	uint32 CreateLobbySession(int32 HostingPlayerNum, FNamedOnlineSession* Session);
+	uint32 FindLobbySession(int32 SearchingPlayerNum, const TSharedRef<FOnlineSessionSearch>& SearchSettings);
+	void StartLobbySearch(int32 SearchingPlayerNum, EOS_HLobbySearch LobbySearchHandle, const TSharedRef<FOnlineSessionSearch>& SearchSettings, const FOnSingleSessionResultCompleteDelegate& CompletionDelegate);
+	uint32 JoinLobbySession(int32 PlayerNum, FNamedOnlineSession* Session, const FOnlineSession* SearchSession);
+	uint32 UpdateLobbySession(FNamedOnlineSession* Session);
+	uint32 StartLobbySession(FNamedOnlineSession* Session);
+	uint32 EndLobbySession(FNamedOnlineSession* Session);
+	uint32 DestroyLobbySession(FNamedOnlineSession* Session, const FOnDestroySessionCompleteDelegate& CompletionDelegate);
+	bool SendLobbyInvite(FName SessionName, EOS_ProductUserId SenderId, EOS_ProductUserId ReceiverId);
+
+	// Lobby notification callbacks and methods
+	EOS_NotificationId LobbyUpdateReceivedId;
+	FCallbackBase* LobbyUpdateReceivedCallback;
+	EOS_NotificationId LobbyMemberUpdateReceivedId;
+	FCallbackBase* LobbyMemberUpdateReceivedCallback;
+	EOS_NotificationId LobbyMemberStatusReceivedId;
+	FCallbackBase* LobbyMemberStatusReceivedCallback;
+	EOS_NotificationId LobbyInviteAcceptedId;
+	FCallbackBase* LobbyInviteAcceptedCallback;
+	EOS_NotificationId JoinLobbyAcceptedId;
+	FCallbackBase* JoinLobbyAcceptedCallback;
+
+	void OnLobbyUpdateReceived(const EOS_LobbyId& LobbyId);
+	void OnLobbyMemberUpdateReceived(const EOS_LobbyId& LobbyId, const EOS_ProductUserId& TargetUserId);
+	void OnMemberStatusReceived(const EOS_LobbyId& LobbyId, const EOS_ProductUserId& TargetUserId, EOS_ELobbyMemberStatus CurrentStatus);
+	void OnLobbyInviteAccepted(const char* InviteId, const EOS_ProductUserId& LocalUserId, const EOS_ProductUserId& TargetUserId);
+	void OnJoinLobbyAccepted(const EOS_ProductUserId& LocalUserId, const EOS_UI_EventId& UiEventId);
+
+	// Lobby Update
+	void SetLobbyPermissionLevel(EOS_HLobbyModification LobbyModificationHandle, FNamedOnlineSession* Session);
+	void SetLobbyMaxMembers(EOS_HLobbyModification LobbyModificationHandle, FNamedOnlineSession* Session);
+	void SetLobbyAttributes(EOS_HLobbyModification LobbyModificationHandle, FNamedOnlineSession* Session);
+	void AddLobbyAttribute(EOS_HLobbyModification LobbyModificationHandle, const EOS_Lobby_AttributeData* Attribute);
+	void AddLobbyMemberAttribute(EOS_HLobbyModification LobbyModificationHandle, const EOS_Lobby_AttributeData* Attribute);
+	void AddLobbyMember(const FUniqueNetIdEOSRef LobbyNetId, const EOS_ProductUserId& TargetUserId);
+
+	// Lobby search
+	void AddLobbySearchAttribute(EOS_HLobbySearch LobbySearchHandle, const EOS_Lobby_AttributeData* Attribute, EOS_EOnlineComparisonOp ComparisonOp);
+	void AddLobbySearchResult(EOS_HLobbyDetails LobbyDetailsHandle, const TSharedRef<FOnlineSessionSearch>& SearchSettings);
+	void CopyLobbyData(EOS_HLobbyDetails LobbyDetailsHandle, EOS_LobbyDetails_Info* LobbyDetailsInfo, FOnlineSession& OutSession);
+	void CopyLobbyAttributes(EOS_HLobbyDetails LobbyDetailsHandle, FOnlineSession& OutSession);
+	void CopyLobbyMemberAttributes(EOS_HLobbyDetails LobbyDetailsHandle, const EOS_ProductUserId& TargetUserId, FSessionSettings& OutSessionSettings);
+
+	// Helper methods
+	typedef TFunction<void(const EOS_ProductUserId& ProductUserId, EOS_EpicAccountId& EpicAccountId)> GetEpicAccountIdAsyncCallback;
+
+	void GetEpicAccountIdAsync(const EOS_ProductUserId& ProductUserId, const GetEpicAccountIdAsyncCallback& Callback);
+	void RegisterLobbyNotifications();
+	FNamedOnlineSession* GetNamedSessionFromLobbyId(const FUniqueNetIdEOS& LobbyId);
+	bool GetEpicAccountIdFromProductUserId(const EOS_ProductUserId& ProductUserId, EOS_EpicAccountId& EpicAccountId);
+	EOS_ELobbyPermissionLevel GetLobbyPermissionLevelFromSessionSettings(const FOnlineSessionSettings& SessionSettings);
+	uint32_t GetLobbyMaxMembersFromSessionSettings(const FOnlineSessionSettings& SessionSettings);
+
+	// EOS Sessions
+	uint32 CreateEOSSession(int32 HostingPlayerNum, FNamedOnlineSession* Session);
+	uint32 JoinEOSSession(int32 PlayerNum, FNamedOnlineSession* Session, const FOnlineSession* SearchSession);
+	uint32 StartEOSSession(FNamedOnlineSession* Session);
+	uint32 UpdateEOSSession(FNamedOnlineSession* Session);
+	uint32 EndEOSSession(FNamedOnlineSession* Session);
+	uint32 DestroyEOSSession(FNamedOnlineSession* Session, const FOnDestroySessionCompleteDelegate& CompletionDelegate);
+	uint32 FindEOSSession(int32 SearchingPlayerNum, const TSharedRef<FOnlineSessionSearch>& SearchSettings);
+	bool SendEOSSessionInvite(FName SessionName, EOS_ProductUserId SenderId, EOS_ProductUserId ReceiverId);
+	void FindEOSSessionById(int32 SearchingPlayerNum, const FUniqueNetId& SessionId, const FOnSingleSessionResultCompleteDelegate& CompletionDelegate);
+
+	bool SendSessionInvite(FName SessionName, EOS_ProductUserId SenderId, EOS_ProductUserId ReceiverId);
+
+	void BeginSessionAnalytics(FNamedOnlineSession* Session);
+	void EndSessionAnalytics();
+
+	void AddSearchResult(EOS_HSessionDetails SessionHandle, const TSharedRef<FOnlineSessionSearch>& SearchSettings);
+	void AddSearchAttribute(EOS_HSessionSearch SearchHandle, const EOS_Sessions_AttributeData* Attribute, EOS_EOnlineComparisonOp ComparisonOp);
+	void CopySearchResult(EOS_HSessionDetails SessionHandle, EOS_SessionDetails_Info* SessionInfo, FOnlineSession& SessionSettings);
+	void CopyAttributes(EOS_HSessionDetails SessionHandle, FOnlineSession& OutSession);
+
+	void SetPermissionLevel(EOS_HSessionModification SessionModHandle, FNamedOnlineSession* Session);
+	void SetJoinInProgress(EOS_HSessionModification SessionModHandle, FNamedOnlineSession* Session);
+	void AddAttribute(EOS_HSessionModification SessionModHandle, const EOS_Sessions_AttributeData* Attribute);
+	void SetAttributes(EOS_HSessionModification SessionModHandle, FNamedOnlineSession* Session);
+	uint32 SharedSessionUpdate(EOS_HSessionModification SessionModHandle, FNamedOnlineSession* Session, FUpdateSessionCallback* Callback);
+
+	void TickLanTasks(float DeltaTime);
+	uint32 CreateLANSession(int32 HostingPlayerNum, FNamedOnlineSession* Session);
+	uint32 JoinLANSession(int32 PlayerNum, class FNamedOnlineSession* Session, const class FOnlineSession* SearchSession);
+	uint32 FindLANSession();
+
+	void AppendSessionToPacket(class FNboSerializeToBufferEOS& Packet, class FOnlineSession* Session);
+	void AppendSessionSettingsToPacket(class FNboSerializeToBufferEOS& Packet, FOnlineSessionSettings* SessionSettings);
+	void ReadSessionFromPacket(class FNboSerializeFromBufferEOS& Packet, class FOnlineSession* Session);
+	void ReadSettingsFromPacket(class FNboSerializeFromBufferEOS& Packet, FOnlineSessionSettings& SessionSettings);
+	void OnValidQueryPacketReceived(uint8* PacketData, int32 PacketLength, uint64 ClientNonce);
+	void OnValidResponsePacketReceived(uint8* PacketData, int32 PacketLength);
+	void OnLANSearchTimeout();
+	static void SetPortFromNetDriver(const FOnlineSubsystemEOS& Subsystem, const TSharedPtr<FOnlineSessionInfo>& SessionInfo);
+	bool IsHost(const FNamedOnlineSession& Session) const;
+
+	/** Reference to the main EOS subsystem */
+	FOnlineSubsystemEOS* EOSSubsystem;
+
+	/** Handles advertising sessions over LAN and client searches */
+	TSharedPtr<FLANSession> LANSession;
+	/** EOS handle wrapper to hold onto it for scope of the search */
+	TSharedPtr<FSessionSearchEOS> CurrentSearchHandle;
+	/** The last accepted invite search. It searches by session id */
+	TSharedPtr<FOnlineSessionSearch> LastInviteSearch;
+
+	/** Notification state for SDK events */
+	EOS_NotificationId SessionInviteAcceptedId;
+	FCallbackBase* SessionInviteAcceptedCallback;
+
+	bool bIsDedicatedServer;
+	bool bIsUsingP2PSockets;
+};
+
+typedef TSharedPtr<FOnlineSessionEOS, ESPMode::ThreadSafe> FOnlineSessionEOSPtr;
+
+#endif
Index: Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Private/OnlineTitleFileEOS.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Private/OnlineTitleFileEOS.cpp b/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Private/OnlineTitleFileEOS.cpp
new file mode 100644
--- /dev/null	(date 1641575208000)
+++ b/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Private/OnlineTitleFileEOS.cpp	(date 1641575208000)
@@ -0,0 +1,493 @@
+// Copyright Epic Games, Inc. All Rights Reserved.
+
+#include "OnlineTitleFileEOS.h"
+#include "OnlineSubsystem.h"
+#include "OnlineSubsystemEOS.h"
+#include "OnlineSubsystemEOSTypes.h"
+#include "UserManagerEOS.h"
+#include "EOSSettings.h"
+
+#if WITH_EOS_SDK
+#include "eos_titlestorage.h"
+
+typedef TEOSCallback<EOS_TitleStorage_OnDeleteCacheCompleteCallback, EOS_TitleStorage_DeleteCacheCallbackInfo> FDeleteCacheCompleteCallback;
+
+typedef TEOSCallback<EOS_TitleStorage_OnQueryFileListCompleteCallback, EOS_TitleStorage_QueryFileListCallbackInfo> FQueryFileListCallback;
+
+typedef TEOSCallbackWithNested2<EOS_TitleStorage_OnReadFileCompleteCallback, EOS_TitleStorage_ReadFileCallbackInfo,
+	EOS_TitleStorage_OnReadFileDataCallback, EOS_TitleStorage_ReadFileDataCallbackInfo, EOS_TitleStorage_EReadResult,
+	EOS_TitleStorage_OnFileTransferProgressCallback, EOS_TitleStorage_FileTransferProgressCallbackInfo
+> FReadTitleFileCompleteCallback;
+
+void FEOSTitleFile::Unload()
+{
+	if (bIsLoaded)
+	{
+		Contents.Empty();
+		bIsLoaded = false;
+	}
+	else if (bInProgress)
+	{
+		UE_LOG_ONLINE_TITLEFILE(Warning, TEXT("Unload() file (%s) is being read"), *Filename);
+	}
+}
+
+bool FOnlineTitleFileEOS::GetFileContents(const FString& FileName, TArray<uint8>& FileContents)
+{
+	FEOSTitleFile* File = FileSet.Find(FileName);
+	if (File != nullptr)
+	{
+		if (File->bIsLoaded)
+		{
+			FileContents = File->Contents;
+			UE_LOG_ONLINE_TITLEFILE(Verbose, TEXT("GetFileContents() got data for (%s), %d bytes"), *FileName, FileContents.Num());
+			return true;
+		}
+		else
+		{
+			// Are we still downloading?
+			if (File->bInProgress)
+			{
+				UE_LOG_ONLINE_TITLEFILE(Warning, TEXT("GetFileContents() file (%s) is being read"), *FileName);
+			}
+			// Contents have been cleared
+			else
+			{
+				UE_LOG_ONLINE_TITLEFILE(Warning, TEXT("GetFileContents() file (%s) has not been loaded"), *FileName);
+			}
+		}
+	}
+	else
+	{
+		UE_LOG_ONLINE_TITLEFILE(Warning, TEXT("GetFileContents() unknown file (%s)"), *FileName);
+	}
+
+	return false;
+}
+
+bool FOnlineTitleFileEOS::ClearFiles()
+{
+	for (TPair<FString, FEOSTitleFile>& TitleFile : FileSet)
+	{
+		FEOSTitleFile& File = TitleFile.Value;
+		File.Unload();
+	}
+	return true;
+}
+
+bool FOnlineTitleFileEOS::ClearFile(const FString& FileName)
+{
+	FEOSTitleFile* File = FileSet.Find(FileName);
+	if (File != nullptr)
+	{
+		File->Unload();
+		return true;
+	}
+	return false;
+}
+
+void FOnlineTitleFileEOS::DeleteCachedFiles(bool bSkipEnumerated)
+{
+	if (bSkipEnumerated)
+	{
+		UE_LOG_ONLINE_TITLEFILE(Warning, TEXT("DeleteCachedFiles() bSkipEnumerated option ignored"));
+	}
+
+	EOS_TitleStorage_DeleteCacheOptions DeleteCacheOptions = { };
+	DeleteCacheOptions.ApiVersion = EOS_TITLESTORAGE_DELETECACHEOPTIONS_API_LATEST;
+	DeleteCacheOptions.LocalUserId = EOSSubsystem->UserManager->GetLocalProductUserId();	// Get a local user if one is available, but this is not required
+
+	FDeleteCacheCompleteCallback* CallbackObj = new FDeleteCacheCompleteCallback();
+	CallbackObj->CallbackLambda = [this](const EOS_TitleStorage_DeleteCacheCallbackInfo* Data)
+	{
+		bool bWasSuccessful = Data->ResultCode == EOS_EResult::EOS_Success;
+		if (bWasSuccessful)
+		{
+			UE_LOG_ONLINE_TITLEFILE(Verbose, TEXT("Deleted cached files"));
+		}
+		else
+		{
+			UE_LOG_ONLINE_TITLEFILE(Error, TEXT("EOS_TitleStorage_DeleteCache() failed with error code (%s)"), ANSI_TO_TCHAR(EOS_EResult_ToString(Data->ResultCode)));
+		}
+	};
+
+	EOS_TitleStorage_DeleteCache(EOSSubsystem->TitleStorageHandle, &DeleteCacheOptions, CallbackObj, CallbackObj->GetCallbackPtr());
+}
+
+bool FOnlineTitleFileEOS::EnumerateFiles(const FPagedQuery& Page)
+{
+	FString ErrorStr;
+	bool bStarted = true;
+	TArray<FString> TitleStorageTags = UEOSSettings::GetSettings().TitleStorageTags;
+
+	if (TitleStorageTags.Num() == 0)
+	{
+		ErrorStr = TEXT("No tags defined");
+		bStarted = false;
+	}
+	else if (Page.Start >= TitleStorageTags.Num())
+	{
+		ErrorStr = FString::Printf(TEXT("Unknown tag page %d"), Page.Start);
+		bStarted = false;
+	}
+
+	if (!bStarted)
+	{
+		EOSSubsystem->ExecuteNextTick([this, ErrorStr]()
+		{
+			UE_LOG_ONLINE_TITLEFILE(Error, TEXT("EnumerateFiles() %s"), *ErrorStr);
+			TriggerOnEnumerateFilesCompleteDelegates(false, *ErrorStr);
+		});
+		return true;
+	}
+
+	// Find all tags defined for the start page
+	FString& PageTagsRaw = TitleStorageTags[Page.Start];
+	const TCHAR* TagDelims[1] = { TEXT("+") };
+	TArray<FString> PageTags;
+	PageTagsRaw.ParseIntoArray(PageTags, TagDelims, 1, false);
+
+	TArray<FTCHARToUTF8> PageTagsBuffer;
+	TArray<const char*> AnsiTags;
+	PageTagsBuffer.Reserve(PageTags.Num());
+	AnsiTags.Reserve(PageTags.Num());
+
+	for (int TagIndex = 0; TagIndex < PageTags.Num(); ++TagIndex)
+	{
+		const FString& PageTag = PageTags[TagIndex];
+		FTCHARToUTF8& Converter = PageTagsBuffer.Emplace_GetRef(*PageTag);
+		AnsiTags.Emplace(Converter.Get());
+		UE_LOG_ONLINE_TITLEFILE(VeryVerbose, TEXT("EnumerateFiles() using tag (%s)"), *PageTag);
+	}
+	UE_LOG_ONLINE_TITLEFILE(VeryVerbose, TEXT("EnumerateFiles() found %d tags"), AnsiTags.Num());
+
+
+	EOS_TitleStorage_QueryFileListOptions QueryFileListOptions = { };
+	QueryFileListOptions.ApiVersion = EOS_TITLESTORAGE_QUERYFILELISTOPTIONS_API_LATEST;
+	QueryFileListOptions.LocalUserId = EOSSubsystem->UserManager->GetLocalProductUserId();	// Get a local user if one is available, but this is not required
+	QueryFileListOptions.ListOfTags = const_cast<const char**>(AnsiTags.GetData());
+	QueryFileListOptions.ListOfTagsCount = AnsiTags.Num();
+
+	FQueryFileListCallback* CallbackObj = new FQueryFileListCallback();
+	CallbackObj->CallbackLambda = [this](const EOS_TitleStorage_QueryFileListCallbackInfo* Data)
+	{
+		FString ErrorStr;
+		bool bWasSuccessful = Data->ResultCode == EOS_EResult::EOS_Success;
+		if (bWasSuccessful)
+		{
+			uint32 FileCount = Data->FileCount;
+			UE_LOG_ONLINE_TITLEFILE(Verbose, TEXT("Found %d files"), FileCount);
+
+			QueryFileSet.Empty();
+
+			for (uint32 Index = 0; Index < FileCount; ++Index)
+			{
+				EOS_TitleStorage_CopyFileMetadataAtIndexOptions CopyFileMetadataAtIndexOptions = { };
+				CopyFileMetadataAtIndexOptions.ApiVersion = EOS_TITLESTORAGE_COPYFILEMETADATAATINDEXOPTIONS_API_LATEST;
+				CopyFileMetadataAtIndexOptions.LocalUserId = Data->LocalUserId;
+				CopyFileMetadataAtIndexOptions.Index = Index;
+
+				EOS_TitleStorage_FileMetadata* FileMetadata = nullptr;
+
+				EOS_EResult Result = EOS_TitleStorage_CopyFileMetadataAtIndex(EOSSubsystem->TitleStorageHandle, &CopyFileMetadataAtIndexOptions, &FileMetadata);
+				if (Result == EOS_EResult::EOS_Success)
+				{
+					if (FileMetadata && FileMetadata->Filename)
+					{
+						QueryFileSet.Emplace(FCloudFileHeader(ANSI_TO_TCHAR(FileMetadata->Filename), ANSI_TO_TCHAR(FileMetadata->Filename), FileMetadata->FileSizeBytes));
+						UE_LOG_ONLINE_TITLEFILE(VeryVerbose, TEXT("Metadata for (%s), size %d"), ANSI_TO_TCHAR(FileMetadata->Filename), FileMetadata->FileSizeBytes);
+					}
+					EOS_TitleStorage_FileMetadata_Release(FileMetadata);
+				}
+				else
+				{
+					ErrorStr = ANSI_TO_TCHAR(EOS_EResult_ToString(Result));
+					UE_LOG_ONLINE_TITLEFILE(Error, TEXT("EOS_TitleStorage_CopyFileMetadataAtIndex() failed with error code (%s)"), *ErrorStr);
+				}
+			}
+		}
+		else
+		{
+			ErrorStr = ANSI_TO_TCHAR(EOS_EResult_ToString(Data->ResultCode));
+			UE_LOG_ONLINE_TITLEFILE(Error, TEXT("EOS_TitleStorage_QueryFileList() failed with error code (%s)"), *ErrorStr);
+		}
+
+		TriggerOnEnumerateFilesCompleteDelegates(bWasSuccessful, *ErrorStr);
+	};
+
+	EOS_TitleStorage_QueryFileList(EOSSubsystem->TitleStorageHandle, &QueryFileListOptions, CallbackObj, CallbackObj->GetCallbackPtr());
+	return true;
+}
+
+// Get the results from the last completed EnumerateFiles request. This data has the potential to become stale over time.
+void FOnlineTitleFileEOS::GetFileList(TArray<FCloudFileHeader>& Files)
+{
+	Files = QueryFileSet;
+}
+
+bool FOnlineTitleFileEOS::ReadFile(const FString& FileName)
+{
+	// If this file is already downloading, dont try to start it again.
+	// Do allow the re-reading of files previously cleared, or already loaded files that may have changed in the cloud.
+	FEOSTitleFile *ExistingTitleFile = FileSet.Find(FileName);
+	if (ExistingTitleFile != nullptr && ExistingTitleFile->bInProgress)
+	{
+		EOSSubsystem->ExecuteNextTick([this, FileName]()
+		{
+			UE_LOG_ONLINE_TITLEFILE(Warning, TEXT("ReadFile() already being read (%s)"), *FileName);
+			TriggerOnReadFileCompleteDelegates(false, FileName);
+		});
+		return true;
+	}
+
+	FReadTitleFileCompleteCallback* CallbackObj = new FReadTitleFileCompleteCallback();
+
+	CallbackObj->SetNested1CallbackLambda([this](const EOS_TitleStorage_ReadFileDataCallbackInfo* Data)
+	{
+		UE_LOG_ONLINE_TITLEFILE(VeryVerbose, TEXT("Read file data (%s) %d bytes"), ANSI_TO_TCHAR(Data->Filename), Data->DataChunkLengthBytes);
+		FEOSTitleFile* TitleFile = FileSet.Find(FString(ANSI_TO_TCHAR(Data->Filename)));
+		if (TitleFile != nullptr)
+		{
+			check(TitleFile->bInProgress);
+			// Is this is the first chunk of data we have received for this file?
+			if (TitleFile->ContentSize == 0 && TitleFile->ContentIndex == 0)
+			{
+				// Store the actual size of the file being read
+				TitleFile->ContentSize = Data->TotalFileSizeBytes;
+
+				// Is the file being read empty?
+				if (TitleFile->ContentSize == 0)
+				{
+					return EOS_TitleStorage_EReadResult::EOS_TS_RR_ContinueReading;
+				}
+
+				TitleFile->Contents.AddUninitialized(Data->TotalFileSizeBytes);
+			}
+
+			if (TitleFile->ContentIndex + Data->DataChunkLengthBytes <= TitleFile->ContentSize)
+			{
+				check(Data->DataChunkLengthBytes > 0);
+				FMemory::Memcpy(TitleFile->Contents.GetData()+ TitleFile->ContentIndex, Data->DataChunk, Data->DataChunkLengthBytes);
+				TitleFile->ContentIndex += Data->DataChunkLengthBytes;
+				return EOS_TitleStorage_EReadResult::EOS_TS_RR_ContinueReading;
+			}
+			else
+			{
+				UE_LOG_ONLINE_TITLEFILE(Warning, TEXT("EOS_TitleStorage_ReadFile() read size exceeded specified file size (%s)"), ANSI_TO_TCHAR(Data->Filename));
+				return EOS_TitleStorage_EReadResult::EOS_TS_RR_FailRequest;
+			}
+		}
+		else
+		{
+			UE_LOG_ONLINE_TITLEFILE(Warning, TEXT("EOS_TitleStorage_ReadFile() unknown file cancelling transfer request (%s)"), ANSI_TO_TCHAR(Data->Filename));
+		}
+
+		return EOS_TitleStorage_EReadResult::EOS_TS_RR_CancelRequest;
+	});
+
+	CallbackObj->SetNested2CallbackLambda([this](const EOS_TitleStorage_FileTransferProgressCallbackInfo* Data)
+	{
+		UE_LOG_ONLINE_TITLEFILE(VeryVerbose, TEXT("File transfer progress (%s) %d bytes"), ANSI_TO_TCHAR(Data->Filename), Data->BytesTransferred);
+		TriggerOnReadFileProgressDelegates(FString(ANSI_TO_TCHAR(Data->Filename)), Data->BytesTransferred);
+	});
+
+	CallbackObj->CallbackLambda = [this](const EOS_TitleStorage_ReadFileCallbackInfo* Data)
+	{
+		bool bWasSuccessful = Data->ResultCode == EOS_EResult::EOS_Success;
+
+		FEOSTitleFile* TitleFile = FileSet.Find(FString(ANSI_TO_TCHAR(Data->Filename)));
+		if (TitleFile != nullptr)
+		{
+			if (TitleFile->FileTransferRequest != nullptr)
+			{
+				EOS_TitleStorageFileTransferRequest_Release(TitleFile->FileTransferRequest);
+				TitleFile->FileTransferRequest = nullptr;
+			}
+
+			if (bWasSuccessful)
+			{
+				TitleFile->bIsLoaded = true;
+				TitleFile->bInProgress = false;
+				UE_LOG_ONLINE_TITLEFILE(Verbose, TEXT("Read (%s), size %d"), *TitleFile->Filename, TitleFile->ContentSize);
+			}
+			else
+			{
+				// If we fail to complete reading the file, discard it from the known files
+				FileSet.Remove(FString(ANSI_TO_TCHAR(Data->Filename)));
+
+				UE_LOG_ONLINE_TITLEFILE(Error, TEXT("EOS_TitleStorage_ReadFile() failed with error code (%s)"), ANSI_TO_TCHAR(EOS_EResult_ToString(Data->ResultCode)));
+			}
+		}
+		else
+		{
+			bWasSuccessful = false;
+			UE_LOG_ONLINE_TITLEFILE(Warning, TEXT("EOS_TitleStorage_ReadFile() unknown transfer request (%s)"), ANSI_TO_TCHAR(Data->Filename));
+		}
+
+		TriggerOnReadFileCompleteDelegates(bWasSuccessful, FString(ANSI_TO_TCHAR(Data->Filename)));
+	};
+
+	FTCHARToUTF8 FileNameConverter(*FileName);
+	const char* AnsiFileName = FileNameConverter.Get();
+
+	int32 ReadChunkSize = UEOSSettings::GetSettings().TitleStorageReadChunkLength;
+	if (ReadChunkSize <= 0)
+	{
+		UE_LOG_ONLINE_TITLEFILE(Warning, TEXT("ReadFile() invalid size TitleStorageReadChunkLength %d"), ReadChunkSize);
+		ReadChunkSize = 16 * 1024;
+	}
+
+	EOS_TitleStorage_ReadFileOptions ReadFileOptions = { };
+	ReadFileOptions.ApiVersion = EOS_TITLESTORAGE_READFILEOPTIONS_API_LATEST;
+	ReadFileOptions.LocalUserId = EOSSubsystem->UserManager->GetLocalProductUserId();	// Get a local user if one is available, but this is not required
+	ReadFileOptions.Filename = AnsiFileName;
+	ReadFileOptions.ReadChunkLengthBytes = (uint32)ReadChunkSize;
+	ReadFileOptions.ReadFileDataCallback = CallbackObj->GetNested1CallbackPtr();
+	ReadFileOptions.FileTransferProgressCallback = CallbackObj->GetNested2CallbackPtr();
+
+	UE_LOG_ONLINE_TITLEFILE(Verbose, TEXT("ReadFile() reading (%s)"), *FileName);
+	EOS_HTitleStorageFileTransferRequest FileTransferRequest = EOS_TitleStorage_ReadFile(EOSSubsystem->TitleStorageHandle, &ReadFileOptions, CallbackObj, CallbackObj->GetCallbackPtr());
+
+	bool bStarted = (FileTransferRequest != nullptr);
+	if (bStarted)
+	{
+		FEOSTitleFile TitleFile;
+		TitleFile.Filename = FileName;
+		TitleFile.FileTransferRequest = FileTransferRequest;
+		TitleFile.bInProgress = true;
+		FileSet.FindOrAdd(FileName) = MoveTemp(TitleFile);			// Replace the last title file, or create a new entry
+	}
+	else
+	{
+		EOSSubsystem->ExecuteNextTick([this, FileName]()
+		{
+			UE_LOG_ONLINE_TITLEFILE(Error, TEXT("ReadFile() failed to create a transfer request (%s)"), *FileName);
+			TriggerOnReadFileCompleteDelegates(false, FileName);
+		});
+	}
+
+	return true;
+}
+
+FDelegateHandle OnEnumerateFilesCompleteDelegateHandle;
+FDelegateHandle OnReadFileProgressDelegateHandle;
+FDelegateHandle OnReadFileCompleteDelegateHandle;
+
+bool FOnlineTitleFileEOS::HandleTitleFileExec(UWorld* InWorld, const TCHAR* Cmd, FOutputDevice& Ar)
+{
+	if (FParse::Command(&Cmd, TEXT("ENUMERATE")))
+	{
+		FString PageString;
+		int32 Page = 0;
+
+		if (FParse::Token(Cmd, PageString, false))
+		{
+			Page = FCString::Atoi(*PageString);
+		}
+
+		OnEnumerateFilesCompleteDelegateHandle = AddOnEnumerateFilesCompleteDelegate_Handle(FOnEnumerateFilesCompleteDelegate::CreateLambda([this](bool bWasSuccessful, const FString& Error)
+		{
+			UE_LOG_ONLINE(Log, TEXT("EnumerateFiles: %s with error (%s)"), bWasSuccessful ? TEXT("succeeded") : TEXT("failed"), *Error);
+
+			ClearOnEnumerateFilesCompleteDelegate_Handle(OnEnumerateFilesCompleteDelegateHandle);
+		}));
+
+		EnumerateFiles(FPagedQuery(Page));
+		return true;
+	}
+	else if (FParse::Command(&Cmd, TEXT("GETFILELIST")))
+	{
+		TArray<FCloudFileHeader> Files;
+
+		GetFileList(Files);
+		UE_LOG_ONLINE(Log, TEXT("GetFilesList: %d files last enumerated"), Files.Num());
+
+		for (int32 Index = 0; Index < Files.Num(); ++Index)
+		{
+			UE_LOG_ONLINE(Log, TEXT("GetFilesList: File (%s), encrypted size %d bytes"), *Files[Index].FileName, Files[Index].FileSize);
+		}
+
+		return true;
+	}
+	else if (FParse::Command(&Cmd, TEXT("READFILE")))
+	{
+		FString FileName = FParse::Token(Cmd, false);
+		if (FileName.IsEmpty())
+		{
+			UE_LOG_ONLINE(Log, TEXT("ReadFile: Missing filename"));
+			return true;
+		}
+
+		// Note: These delegates will trigger for all files being read, if multiple requests are inflight
+		OnReadFileProgressDelegateHandle = AddOnReadFileProgressDelegate_Handle(FOnReadFileProgressDelegate::CreateLambda([this](const FString& FileName, uint64 NumBytes)
+		{
+			UE_LOG_ONLINE(Log, TEXT("ReadFile: Progress (%s) %d bytes read"), *FileName, NumBytes);
+		}));
+
+		OnReadFileCompleteDelegateHandle = AddOnReadFileCompleteDelegate_Handle(FOnReadFileCompleteDelegate::CreateLambda([this](bool bWasSuccessful, const FString& Error)
+		{
+			UE_LOG_ONLINE(Log, TEXT("ReadFile: %s with error (%s)"), bWasSuccessful ? TEXT("succeeded") : TEXT("failed"), *Error);
+
+			ClearOnReadFileProgressDelegate_Handle(OnReadFileProgressDelegateHandle);
+			ClearOnReadFileCompleteDelegate_Handle(OnReadFileCompleteDelegateHandle);
+		}));
+
+		ReadFile(FileName);
+		return true;
+	}
+	else if (FParse::Command(&Cmd, TEXT("GETFILECONTENTS")))
+	{
+		FString FileName = FParse::Token(Cmd, false);
+		if (FileName.IsEmpty())
+		{
+			UE_LOG_ONLINE(Log, TEXT("GetFileContents: Missing filename"));
+			return true;
+		}
+
+		TArray<uint8> FileContents;
+
+		if (GetFileContents(FileName, FileContents))
+		{
+			UE_LOG_ONLINE(Log, TEXT("GetFileContents: Got contents for (%s), size %d bytes"), *FileName, FileContents.Num());
+		}
+		else
+		{
+			UE_LOG_ONLINE(Log, TEXT("GetFilesContents: Unknown filename or not loaded (%s)"), *FileName);
+		}
+
+		return true;
+	}
+	else if (FParse::Command(&Cmd, TEXT("CLEARFILES")))
+	{
+		ClearFiles();
+		return true;
+	}
+	else if (FParse::Command(&Cmd, TEXT("CLEARFILE")))
+	{
+		FString FileName = FParse::Token(Cmd, false);
+		if (FileName.IsEmpty())
+		{
+			UE_LOG_ONLINE(Log, TEXT("ClearFile: Missing filename"));
+			return true;
+		}
+
+		if (ClearFile(FileName))
+		{
+			UE_LOG_ONLINE(Log, TEXT("ClearFile: Cleared (%s)"), *FileName);
+		}
+		else
+		{
+			UE_LOG_ONLINE(Log, TEXT("ClearFile: Unknown filename or not loaded (%s)"), *FileName);
+		}
+
+		return true;
+	}
+	else if (FParse::Command(&Cmd, TEXT("DELETECACHEDFILES")))
+	{
+		DeleteCachedFiles(false);
+		return true;
+	}
+	return false;
+}
+
+#endif
Index: Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Private/NetConnectionEOS.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Private/NetConnectionEOS.h b/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Private/NetConnectionEOS.h
new file mode 100644
--- /dev/null	(date 1641575208000)
+++ b/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Private/NetConnectionEOS.h	(date 1641575208000)
@@ -0,0 +1,31 @@
+// Copyright Epic Games, Inc. All Rights Reserved.
+
+#pragma once
+
+#include "CoreMinimal.h"
+#include "IpConnection.h"
+#include "NetConnectionEOS.generated.h"
+
+UCLASS(Transient, Config=Engine)
+class UNetConnectionEOS
+	: public UIpConnection
+{
+	GENERATED_BODY()
+
+public:
+	explicit UNetConnectionEOS(const FObjectInitializer& ObjectInitializer);
+
+//~ Begin NetConnection Interface
+	virtual void InitLocalConnection(UNetDriver* InDriver, FSocket* InSocket, const FURL& InURL, EConnectionState InState, int32 InMaxPacket = 0, int32 InPacketOverhead = 0) override;
+	virtual void InitRemoteConnection(UNetDriver* InDriver, FSocket* InSocket, const FURL& InURL, const FInternetAddr& InRemoteAddr, EConnectionState InState, int32 InMaxPacket = 0, int32 InPacketOverhead = 0) override;
+	virtual void CleanUp() override;
+//~ End NetConnection Interface
+
+	void DestroyEOSConnection();
+
+public:
+	bool bIsPassthrough;
+
+protected:
+	bool bHasP2PSession;
+};
Index: Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Private/OnlineAchievementsEOS.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Private/OnlineAchievementsEOS.cpp b/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Private/OnlineAchievementsEOS.cpp
new file mode 100644
--- /dev/null	(date 1641575208000)
+++ b/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Private/OnlineAchievementsEOS.cpp	(date 1641575208000)
@@ -0,0 +1,233 @@
+// Copyright Epic Games, Inc. All Rights Reserved.
+
+#include "OnlineAchievementsEOS.h"
+#include "OnlineSubsystem.h"
+#include "OnlineSubsystemEOS.h"
+#include "OnlineSubsystemEOSTypes.h"
+#include "OnlineStatsEOS.h"
+#include "UserManagerEOS.h"
+
+
+#if WITH_EOS_SDK
+#include "eos_achievements.h"
+
+void FOnlineAchievementsEOS::WriteAchievements(const FUniqueNetId& PlayerId, FOnlineAchievementsWriteRef& WriteObject, const FOnAchievementsWrittenDelegate& Delegate)
+{
+	TArray<FOnlineStatsUserUpdatedStats> StatsToWrite;
+
+	FOnlineStatsUserUpdatedStats& UpdatedStats = StatsToWrite.Emplace_GetRef(PlayerId.AsShared());
+	for (const TPair<FName, FVariantData>& Stat : WriteObject->Properties)
+	{
+		UpdatedStats.Stats.Add(Stat.Key.ToString(), FOnlineStatUpdate(Stat.Value, FOnlineStatUpdate::EOnlineStatModificationType::Unknown));
+	}
+
+	EOSSubsystem->StatsInterfacePtr->UpdateStats(PlayerId.AsShared(), StatsToWrite, FOnlineStatsUpdateStatsComplete());
+
+	WriteObject->WriteState = EOnlineAsyncTaskState::Done;
+	Delegate.ExecuteIfBound(PlayerId, true);
+}
+
+typedef TEOSCallback<EOS_Achievements_OnQueryPlayerAchievementsCompleteCallback, EOS_Achievements_OnQueryPlayerAchievementsCompleteCallbackInfo> FQueryProgressCallback;
+
+void FOnlineAchievementsEOS::QueryAchievements(const FUniqueNetId& PlayerId, const FOnQueryAchievementsCompleteDelegate& Delegate)
+{
+	int32 LocalUserId = EOSSubsystem->UserManager->GetLocalUserNumFromUniqueNetId(PlayerId);
+	if (LocalUserId < 0)
+	{
+		UE_LOG_ONLINE_ACHIEVEMENTS(Error, TEXT("Can't query achievement progress for non-local user (%)"), *PlayerId.ToString());
+		Delegate.ExecuteIfBound(PlayerId, false);
+		return;
+	}
+
+	EOS_Achievements_QueryPlayerAchievementsOptions Options = { };
+	Options.ApiVersion = EOS_ACHIEVEMENTS_QUERYPLAYERACHIEVEMENTS_API_LATEST;
+#if EOS_ACHIEVEMENTS_QUERYPLAYERACHIEVEMENTS_API_LATEST >= 2
+	Options.LocalUserId = EOSSubsystem->UserManager->GetLocalProductUserId(LocalUserId);
+	Options.TargetUserId = Options.LocalUserId;
+#else
+	Options.UserId = EOSSubsystem->UserManager->GetLocalProductUserId(LocalUserId);
+#endif
+
+	FQueryProgressCallback* CallbackObj = new FQueryProgressCallback();
+	CallbackObj->CallbackLambda = [this, LambdaPlayerId = PlayerId.AsShared(), OnComplete = FOnQueryAchievementsCompleteDelegate(Delegate)](const EOS_Achievements_OnQueryPlayerAchievementsCompleteCallbackInfo* Data)
+	{
+		bool bWasSuccessful = Data->ResultCode == EOS_EResult::EOS_Success;
+		if (bWasSuccessful)
+		{
+			TSharedRef<TArray<FOnlineAchievement>> Cheevos = MakeShareable(new TArray<FOnlineAchievement>());
+			CachedAchievementsMap.Add(LambdaPlayerId, Cheevos);
+
+			int32 LocalUserNum = EOSSubsystem->UserManager->GetLocalUserNumFromUniqueNetId(*LambdaPlayerId);
+			EOS_ProductUserId UserId = EOSSubsystem->UserManager->GetLocalProductUserId(LocalUserNum);
+
+			EOS_Achievements_GetPlayerAchievementCountOptions CountOptions = { };
+			CountOptions.ApiVersion = EOS_ACHIEVEMENTS_GETPLAYERACHIEVEMENTCOUNT_API_LATEST;
+			CountOptions.UserId = UserId;
+			uint32 Count = EOS_Achievements_GetPlayerAchievementCount(EOSSubsystem->AchievementsHandle, &CountOptions);
+
+			EOS_Achievements_CopyPlayerAchievementByIndexOptions CopyOptions = { };
+			CopyOptions.ApiVersion = EOS_ACHIEVEMENTS_COPYPLAYERACHIEVEMENTBYINDEX_API_LATEST;
+#if EOS_ACHIEVEMENTS_COPYPLAYERACHIEVEMENTBYINDEX_API_LATEST >= 2
+			CopyOptions.LocalUserId = UserId;
+			CopyOptions.TargetUserId = UserId;
+#else
+			CopyOptions.UserId = UserId;
+#endif
+
+			for (uint32 Index = 0; Index < Count; Index++)
+			{
+				CopyOptions.AchievementIndex = Index;
+
+				EOS_Achievements_PlayerAchievement* AchievementEOS = nullptr;
+				EOS_EResult Result = EOS_Achievements_CopyPlayerAchievementByIndex(EOSSubsystem->AchievementsHandle, &CopyOptions, &AchievementEOS);
+				if (Result == EOS_EResult::EOS_Success)
+				{
+					FOnlineAchievement* Achievement = new(*Cheevos) FOnlineAchievement();
+
+					Achievement->Id = AchievementEOS->AchievementId;
+					Achievement->Progress = AchievementEOS->Progress;
+
+					EOS_Achievements_PlayerAchievement_Release(AchievementEOS);
+
+					if (UE_BUILD_DEBUG)
+					{
+						UE_LOG_ONLINE_ACHIEVEMENTS(Log, TEXT("Achievement progress (%s)"), *Achievement->ToDebugString());
+					}
+				}
+				else
+				{
+					UE_LOG_ONLINE_ACHIEVEMENTS(Error, TEXT("EOS_Achievements_CopyPlayerAchievementByIndex() failed with error code (%s)"), ANSI_TO_TCHAR(EOS_EResult_ToString(Result)));
+				}
+			}
+		}
+		else
+		{
+			UE_LOG_ONLINE_ACHIEVEMENTS(Error, TEXT("EOS_Achievements_QueryPlayerAchievements() failed with error code (%s)"), ANSI_TO_TCHAR(EOS_EResult_ToString(Data->ResultCode)));
+		}
+		OnComplete.ExecuteIfBound(*LambdaPlayerId, bWasSuccessful);
+	};
+	EOS_Achievements_QueryPlayerAchievements(EOSSubsystem->AchievementsHandle, &Options, CallbackObj, CallbackObj->GetCallbackPtr());
+}
+
+typedef TEOSCallback<EOS_Achievements_OnQueryDefinitionsCompleteCallback, EOS_Achievements_OnQueryDefinitionsCompleteCallbackInfo> FQueryDefinitionsCallback;
+
+void FOnlineAchievementsEOS::QueryAchievementDescriptions(const FUniqueNetId& PlayerId, const FOnQueryAchievementsCompleteDelegate& Delegate)
+{
+	if (CachedAchievementDefinitions.Num())
+	{
+		UE_LOG_ONLINE_ACHIEVEMENTS(Warning, TEXT("Using cached achievement definitions"));
+		Delegate.ExecuteIfBound(PlayerId, true);
+		return;
+	}
+
+	int32 LocalUserId = EOSSubsystem->UserManager->GetLocalUserNumFromUniqueNetId(PlayerId);
+	if (LocalUserId < 0)
+	{
+		UE_LOG_ONLINE_ACHIEVEMENTS(Error, TEXT("Can't query achievement definitions for non-local user (%)"), *PlayerId.ToString());
+		Delegate.ExecuteIfBound(PlayerId, false);
+		return;
+	}
+
+	EOS_Achievements_QueryDefinitionsOptions Options = { };
+	Options.ApiVersion = EOS_ACHIEVEMENTS_QUERYDEFINITIONS_API_LATEST;
+	Options.LocalUserId = EOSSubsystem->UserManager->GetLocalProductUserId(LocalUserId);
+
+	FQueryDefinitionsCallback* CallbackObj = new FQueryDefinitionsCallback();
+	CallbackObj->CallbackLambda = [this, LambdaPlayerId = PlayerId.AsShared(), OnComplete = FOnQueryAchievementsCompleteDelegate(Delegate)](const EOS_Achievements_OnQueryDefinitionsCompleteCallbackInfo* Data)
+	{
+		bool bWasSuccessful = Data->ResultCode == EOS_EResult::EOS_Success;
+		if (bWasSuccessful)
+		{
+			EOS_Achievements_GetAchievementDefinitionCountOptions CountOptions = { };
+			CountOptions.ApiVersion = EOS_ACHIEVEMENTS_GETACHIEVEMENTDEFINITIONCOUNT_API_LATEST;
+			uint32 Count = EOS_Achievements_GetAchievementDefinitionCount(EOSSubsystem->AchievementsHandle, &CountOptions);
+
+			EOS_Achievements_CopyAchievementDefinitionByIndexOptions CopyOptions = { };
+			CopyOptions.ApiVersion = EOS_ACHIEVEMENTS_COPYDEFINITIONBYINDEX_API_LATEST;
+			CachedAchievementDefinitions.Empty(Count);
+			CachedAchievementDefinitionsMap.Empty();
+
+			for (uint32 Index = 0; Index < Count; Index++)
+			{
+				CopyOptions.AchievementIndex = Index;
+				EOS_Achievements_Definition* Definition = nullptr;
+
+				EOS_EResult Result = EOS_Achievements_CopyAchievementDefinitionByIndex(EOSSubsystem->AchievementsHandle, &CopyOptions, &Definition);
+				if (Result == EOS_EResult::EOS_Success)
+				{
+					FOnlineAchievementDesc* Desc = new(CachedAchievementDefinitions) FOnlineAchievementDesc();
+					// Work around for the ID not being part of the description
+					CachedAchievementDefinitionsMap.Add(Definition->AchievementId, Desc);
+
+					Desc->Title = FText::FromString(Definition->DisplayName);
+					Desc->LockedDesc = FText::FromString(Definition->LockedDescription);
+					Desc->UnlockedDesc = FText::FromString(Definition->CompletionDescription);
+					Desc->bIsHidden = Definition->bIsHidden == EOS_TRUE;
+
+					EOS_Achievements_Definition_Release(Definition);
+
+					if (UE_BUILD_DEBUG)
+					{
+						UE_LOG_ONLINE_ACHIEVEMENTS(Log, TEXT("Achievement desc is (%s)"), *Desc->ToDebugString());
+					}
+				}
+				else
+				{
+					UE_LOG_ONLINE_ACHIEVEMENTS(Error, TEXT("EOS_Achievements_CopyAchievementDefinitionByIndex() failed with error code (%s)"), ANSI_TO_TCHAR(EOS_EResult_ToString(Result)));
+				}
+			}
+		}
+		else
+		{
+			UE_LOG_ONLINE_ACHIEVEMENTS(Error, TEXT("EOS_Achievements_QueryDefinitions() failed with error code (%s)"), ANSI_TO_TCHAR(EOS_EResult_ToString(Data->ResultCode)));
+		}
+		OnComplete.ExecuteIfBound(*LambdaPlayerId, bWasSuccessful);
+	};
+	EOS_Achievements_QueryDefinitions(EOSSubsystem->AchievementsHandle, &Options, CallbackObj, CallbackObj->GetCallbackPtr());
+}
+
+EOnlineCachedResult::Type FOnlineAchievementsEOS::GetCachedAchievement(const FUniqueNetId& PlayerId, const FString& AchievementId, FOnlineAchievement& OutAchievement)
+{
+	if (const TSharedRef<TArray<FOnlineAchievement>>* Achievements = CachedAchievementsMap.Find(PlayerId.AsShared()))
+	{
+		for (const FOnlineAchievement& Achievement : **Achievements)
+		{
+			if (Achievement.Id == AchievementId)
+			{
+				OutAchievement = Achievement;
+				return EOnlineCachedResult::Success;
+			}
+		}
+	}
+	return EOnlineCachedResult::NotFound;
+}
+
+EOnlineCachedResult::Type FOnlineAchievementsEOS::GetCachedAchievements(const FUniqueNetId& PlayerId, TArray<FOnlineAchievement>& OutAchievements)
+{
+	if (const TSharedRef<TArray<FOnlineAchievement>>* CachedAchievements = CachedAchievementsMap.Find(PlayerId.AsShared()))
+	{
+		OutAchievements = **CachedAchievements;
+		return EOnlineCachedResult::Success;
+	}
+	return EOnlineCachedResult::NotFound;
+}
+
+EOnlineCachedResult::Type FOnlineAchievementsEOS::GetCachedAchievementDescription(const FString& AchievementId, FOnlineAchievementDesc& OutAchievementDesc)
+{
+	if (CachedAchievementDefinitionsMap.Contains(AchievementId))
+	{
+		OutAchievementDesc = *CachedAchievementDefinitionsMap[AchievementId];
+		return EOnlineCachedResult::Success;
+	}
+	return EOnlineCachedResult::NotFound;
+}
+
+#if !UE_BUILD_SHIPPING
+bool FOnlineAchievementsEOS::ResetAchievements(const FUniqueNetId&)
+{
+	UE_LOG_ONLINE_ACHIEVEMENTS(Warning, TEXT("ResetAchievements() is not supported"));
+	return false;
+}
+#endif
+
+#endif
Index: Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Private/OnlineStatsEOS.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Private/OnlineStatsEOS.cpp b/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Private/OnlineStatsEOS.cpp
new file mode 100644
--- /dev/null	(date 1641576012000)
+++ b/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Private/OnlineStatsEOS.cpp	(date 1641576012000)
@@ -0,0 +1,365 @@
+// Copyright Epic Games, Inc. All Rights Reserved.
+
+#include "OnlineStatsEOS.h"
+#include "OnlineSubsystem.h"
+#include "OnlineSubsystemEOS.h"
+#include "OnlineSubsystemEOSTypes.h"
+#include "UserManagerEOS.h"
+
+#if WITH_EOS_SDK
+#include "eos_stats.h"
+
+#define FLOAT_STAT_SCALER 1000.f
+
+inline int32 FloatStatToIntStat(float Value)
+{
+	return FMath::TruncToInt(Value * FLOAT_STAT_SCALER);
+}
+
+inline float IntStatToFloatStat(int32 Value)
+{
+	return (float)Value / FLOAT_STAT_SCALER;
+}
+
+struct FStatNameBuffer
+{
+	char StatName[EOS_OSS_STRING_BUFFER_LENGTH];
+};
+
+
+void FOnlineStatsEOS::QueryStats(const FUniqueNetIdRef LocalUserId, const FUniqueNetIdRef StatsUser, const FOnlineStatsQueryUserStatsComplete& Delegate)
+{
+	UE_LOG_ONLINE_STATS(Warning, TEXT("QueryStats() without a list of stats names to query is not supported"));
+	const TSharedPtr<const FOnlineStatsUserStats> Result = MakeShared<const FOnlineStatsUserStats>(StatsUser);
+	Delegate.ExecuteIfBound(FOnlineError(EOnlineErrorResult::NotImplemented), Result);
+}
+
+struct FQueryStatsOptions :
+	public EOS_Stats_QueryStatsOptions
+{
+	TArray<char*> PointerArray;
+
+	FQueryStatsOptions(const uint32 InNumStatIds) :
+		EOS_Stats_QueryStatsOptions()
+	{
+		ApiVersion = EOS_STATS_QUERYSTATS_API_LATEST;
+
+		StartTime = EOS_STATS_TIME_UNDEFINED;
+		EndTime = EOS_STATS_TIME_UNDEFINED;
+
+		PointerArray.AddZeroed(InNumStatIds);
+		for (int32 Index = 0; Index < PointerArray.Num(); Index++)
+		{
+			PointerArray[Index] = new char[EOS_OSS_STRING_BUFFER_LENGTH];
+		}
+		StatNames = (const char**)PointerArray.GetData();
+		StatNamesCount = InNumStatIds;
+	}
+
+	~FQueryStatsOptions()
+	{
+		for (int32 Index = 0; Index < PointerArray.Num(); Index++)
+		{
+			delete [] PointerArray[Index];
+		}
+	}
+};
+
+typedef TEOSCallback<EOS_Stats_OnQueryStatsCompleteCallback, EOS_Stats_OnQueryStatsCompleteCallbackInfo> FReadStatsCallback;
+
+struct FStatsQueryContext
+{
+	int32 NumPlayerReads;
+	TArray<FString> StatNames;
+	FOnlineStatsQueryUsersStatsComplete Delegate;
+	/** Stats are added here as they come in from the service. They are added to the global cache at the end */
+	TUniqueNetIdMap<TSharedRef<FOnlineStatsUserStats>> StatsCache;
+
+	FStatsQueryContext(int32 InNumPlayerReads, const TArray<FString>& InStatNames, const FOnlineStatsQueryUsersStatsComplete& InDelegate)
+		: NumPlayerReads(InNumPlayerReads)
+		, StatNames(InStatNames)
+		, Delegate(InDelegate)
+	{
+	}
+};
+
+typedef TSharedPtr<FStatsQueryContext> FStatsQueryContextPtr;
+
+// N^2 append operation
+void AppendStats(TUniqueNetIdMap<TSharedRef<FOnlineStatsUserStats>>& StatsCache, const TUniqueNetIdMap<TSharedRef<FOnlineStatsUserStats>>& StatsCacheToAppend)
+{
+	for (const TPair<FUniqueNetIdRef, TSharedRef<FOnlineStatsUserStats>>& StatsUser : StatsCacheToAppend)
+	{
+		TSharedRef<FOnlineStatsUserStats>* UserCachedStats = StatsCache.Find(StatsUser.Key);
+		if (!UserCachedStats)
+		{
+			UserCachedStats = &StatsCache.Emplace(StatsUser.Key, MakeShared<FOnlineStatsUserStats>(StatsUser.Key));
+		}
+
+		for (TPair<FString, FOnlineStatValue>& NewStat : StatsUser.Value->Stats)
+		{
+			FOnlineStatValue& StatToUpdate = (*UserCachedStats)->Stats.FindOrAdd(NewStat.Key);
+			StatToUpdate = NewStat.Value;
+		}
+	}
+}
+
+void FOnlineStatsEOS::QueryStats(const FUniqueNetIdRef LocalUserId, const TArray<FUniqueNetIdRef>& StatUsers, const TArray<FString>& StatNames, const FOnlineStatsQueryUsersStatsComplete& Delegate)
+{
+	const FUniqueNetIdEOS& LocalEOSId = FUniqueNetIdEOS::Cast(*LocalUserId);
+	EOS_ProductUserId LocalEOSUserId = EOS_ProductUserId_FromString(TCHAR_TO_UTF8(*LocalEOSId.ProductUserIdStr));
+	if (StatNames.Num() == 0)
+	{
+		UE_LOG_ONLINE_STATS(Warning, TEXT("QueryStats() without a list of stats names to query is not supported"));
+		Delegate.ExecuteIfBound(FOnlineError(EOnlineErrorResult::NotImplemented), TArray<TSharedRef<const FOnlineStatsUserStats>>());
+		return;
+	}
+	if (StatUsers.Num() == 0)
+	{
+		UE_LOG_ONLINE_STATS(Warning, TEXT("QueryStats() without a list of users to query is not supported"));
+		Delegate.ExecuteIfBound(FOnlineError(EOnlineErrorResult::NotImplemented), TArray<TSharedRef<const FOnlineStatsUserStats>>());
+		return;
+	}
+
+	// Do the stat name building once rather than for each person
+	FQueryStatsOptions Options(StatNames.Num());
+	for (int32 Index = 0; Index < StatNames.Num(); Index++)
+	{
+		FCStringAnsi::Strncpy(Options.PointerArray[Index], TCHAR_TO_UTF8(*StatNames[Index].ToUpper()), EOS_OSS_STRING_BUFFER_LENGTH);
+	}
+
+	int32 NumKnownUsers = 0;
+	// Validate the number of known users
+	for (const FUniqueNetIdRef& StatUserId : StatUsers)
+	{
+		const FUniqueNetIdEOS& EOSId = FUniqueNetIdEOS::Cast(*StatUserId);
+		EOS_ProductUserId UserId = EOS_ProductUserId_FromString(TCHAR_TO_UTF8(*EOSId.ProductUserIdStr));
+		if (UserId == nullptr)
+		{
+			continue;
+		}
+		NumKnownUsers++;
+	}
+
+	// This object will live across all calls and be freed at the end
+	FStatsQueryContextPtr StatsQueryContext = MakeShareable(new FStatsQueryContext(NumKnownUsers, StatNames, Delegate));
+	// Kick off a read for each user
+	for (const FUniqueNetIdRef& StatUserId : StatUsers)
+	{
+		const FUniqueNetIdEOS& EOSId = FUniqueNetIdEOS::Cast(*StatUserId);
+		const EOS_ProductUserId TargetEOSUserId = EOS_ProductUserId_FromString(TCHAR_TO_UTF8(*EOSId.ProductUserIdStr));
+		if (TargetEOSUserId == nullptr)
+		{
+			continue;
+		}
+
+		Options.LocalUserId = LocalEOSUserId;
+		Options.TargetUserId = TargetEOSUserId;
+
+		FReadStatsCallback* CallbackObj = new FReadStatsCallback();
+		CallbackObj->CallbackLambda = [this, StatsQueryContext](const EOS_Stats_OnQueryStatsCompleteCallbackInfo* Data)
+		{
+			StatsQueryContext->NumPlayerReads--;
+			bool bWasSuccessful = Data->ResultCode == EOS_EResult::EOS_Success;
+			if (bWasSuccessful)
+			{
+				FUniqueNetIdEOSPtr StatUserId = EOSSubsystem->UserManager->GetLocalUniqueNetIdEOS(Data->TargetUserId);
+				if (StatUserId.IsValid())
+				{
+					char StatNameANSI[EOS_OSS_STRING_BUFFER_LENGTH];
+					EOS_Stats_CopyStatByNameOptions Options = { };
+					Options.ApiVersion = EOS_STATS_COPYSTATBYNAME_API_LATEST;
+					Options.TargetUserId = Data->TargetUserId;
+					Options.Name = StatNameANSI;
+
+					TSharedPtr<FOnlineStatsUserStats> UserStats = StatsCache.Emplace(StatUserId.ToSharedRef(), MakeShared<FOnlineStatsUserStats>(StatUserId.ToSharedRef()));
+					// Read each stat that we were looking for so we can mark missing ones as "empty"
+					for (const FString& StatName : StatsQueryContext->StatNames)
+					{
+						FCStringAnsi::Strncpy(StatNameANSI, TCHAR_TO_UTF8(*StatName.ToUpper()), EOS_OSS_STRING_BUFFER_LENGTH);
+
+						EOS_Stats_Stat* ReadStat = nullptr;
+						if (EOS_Stats_CopyStatByName(EOSSubsystem->StatsHandle, &Options, &ReadStat) == EOS_EResult::EOS_Success)
+						{
+							UE_LOG_ONLINE_STATS(VeryVerbose, TEXT("Found value for stat %s"), *StatName);
+
+							UserStats->Stats.Add(StatName, FOnlineStatValue(ReadStat->Value));
+
+							EOS_Stats_Stat_Release(ReadStat);
+						}
+						else
+						{
+							// Put an empty stat in
+							UE_LOG_ONLINE_STATS(VeryVerbose, TEXT("Value not found for stat %s, adding empty value"), *StatName);
+							UserStats->Stats.Add(StatName, FOnlineStatValue());
+						}
+					}
+				}
+			}
+			else
+			{
+				UE_LOG_ONLINE_STATS(Error, TEXT("EOS_Stats_QueryStats() for user (%s) failed with EOS result code (%s)"), *LexToString(Data->TargetUserId), *LexToString(Data->ResultCode));
+			}
+			if (StatsQueryContext->NumPlayerReads <= 0)
+			{
+				TArray<TSharedRef<const FOnlineStatsUserStats>> OutArray;
+				for (const TPair<FUniqueNetIdRef, TSharedRef<FOnlineStatsUserStats>>& StatsUser : StatsCache)
+				{
+					OutArray.Add(StatsUser.Value);
+				}
+				StatsQueryContext->Delegate.ExecuteIfBound(FOnlineError(StatsCache.Num() > 0), OutArray);
+			}
+		};
+		EOS_Stats_QueryStats(EOSSubsystem->StatsHandle, &Options, CallbackObj, CallbackObj->GetCallbackPtr());
+	}
+}
+
+TSharedPtr<const FOnlineStatsUserStats> FOnlineStatsEOS::GetStats(const FUniqueNetIdRef StatsUserId) const
+{
+	if (const TSharedRef<FOnlineStatsUserStats>* const FoundStats = StatsCache.Find(StatsUserId))
+	{
+		return *FoundStats;
+	}
+	return nullptr;
+}
+
+inline int32 GetVariantValue(const FOnlineStatValue& Data)
+{
+	int32 Value = 0;
+	switch (Data.GetType())
+	{
+		case EOnlineKeyValuePairDataType::Int32:
+		{
+			Data.GetValue(Value);
+			break;
+		}
+		case EOnlineKeyValuePairDataType::UInt32:
+		{
+			uint32 Value1 = 0;
+			Data.GetValue(Value);
+			Value = (int32)Value1;
+			break;
+		}
+		case EOnlineKeyValuePairDataType::Int64:
+		{
+			int64 Value1 = 0;
+			Data.GetValue(Value1);
+			Value = (int32)Value1;
+			break;
+		}
+		case EOnlineKeyValuePairDataType::UInt64:
+		{
+			uint64 Value1 = 0;
+			Data.GetValue(Value1);
+			Value = (int32)Value1;
+			break;
+		}
+		case EOnlineKeyValuePairDataType::Bool:
+		{
+			bool Value1 = false;
+			Data.GetValue(Value1);
+			Value = Value1 ? 1 : 0;
+			break;
+		}
+		case EOnlineKeyValuePairDataType::Float:
+		{
+			float Value1 = 0.f;
+			Data.GetValue(Value1);
+			Value = FloatStatToIntStat(Value1);
+			break;
+		}
+		case EOnlineKeyValuePairDataType::Double:
+		{
+			double Value1 = 0.f;
+			Data.GetValue(Value1);
+			Value = FloatStatToIntStat(Value1);
+			break;
+		}
+	}
+	return Value;
+}
+
+typedef TEOSCallback<EOS_Stats_OnIngestStatCompleteCallback, EOS_Stats_IngestStatCompleteCallbackInfo> FWriteStatsCallback;
+
+void FOnlineStatsEOS::WriteStats(EOS_ProductUserId LocalUserId, EOS_ProductUserId UserId, const FOnlineStatsUserUpdatedStats& PlayerStats)
+{
+	TArray<EOS_Stats_IngestData> EOSData;
+	TArray<FStatNameBuffer> EOSStatNames;
+	// Preallocate all of the memory
+	EOSData.AddZeroed(PlayerStats.Stats.Num());
+	EOSStatNames.AddZeroed(PlayerStats.Stats.Num());
+	uint32 Index = 0;
+	// Convert the stats to the EOS format
+	for (const TPair<FString, FOnlineStatUpdate>& Stat : PlayerStats.Stats)
+	{
+		EOS_Stats_IngestData& EOSStat = EOSData[Index];
+		EOSStat.ApiVersion = EOS_STATS_INGESTDATA_API_LATEST;
+
+		EOSStat.IngestAmount = GetVariantValue(Stat.Value.GetValue());
+		FCStringAnsi::Strncpy(EOSStatNames[Index].StatName, TCHAR_TO_UTF8(*Stat.Key.ToUpper()), EOS_OSS_STRING_BUFFER_LENGTH);
+		EOSStat.StatName = EOSStatNames[Index].StatName;
+
+		Index++;
+	}
+
+	EOS_Stats_IngestStatOptions Options = { };
+	Options.ApiVersion = EOS_STATS_INGESTSTAT_API_LATEST;
+	Options.LocalUserId = LocalUserId;
+	Options.TargetUserId = UserId;
+	Options.Stats = EOSData.GetData();
+	Options.StatsCount = EOSData.Num();
+
+	FWriteStatsCallback* CallbackObj = new FWriteStatsCallback();
+	CallbackObj->CallbackLambda = [this](const EOS_Stats_IngestStatCompleteCallbackInfo* Data)
+	{
+		bool bWasSuccessful = Data->ResultCode == EOS_EResult::EOS_Success;
+		if (!bWasSuccessful)
+		{
+			UE_LOG_ONLINE_STATS(Error, TEXT("EOS_Stats_IngestStat() failed with EOS result code (%s)"), ANSI_TO_TCHAR(EOS_EResult_ToString(Data->ResultCode)));
+		}
+	};
+	EOS_Stats_IngestStat(EOSSubsystem->StatsHandle, &Options, CallbackObj, CallbackObj->GetCallbackPtr());
+}
+
+void FOnlineStatsEOS::UpdateStats(const FUniqueNetIdRef LocalUserId, const TArray<FOnlineStatsUserUpdatedStats>& UpdatedUserStats, const FOnlineStatsUpdateStatsComplete& Delegate)
+{
+	const FUniqueNetIdEOS& EOSId = FUniqueNetIdEOS::Cast(*LocalUserId);
+	EOS_ProductUserId UserId = EOS_ProductUserId_FromString(TCHAR_TO_UTF8(*EOSId.ProductUserIdStr));
+	if (UserId == nullptr)
+	{
+		UE_LOG_ONLINE_STATS(Error, TEXT("UpdateStats() failed for unknown player (%s)"), *EOSId.UniqueNetIdStr);
+		Delegate.ExecuteIfBound(FOnlineError(EOnlineErrorResult::InvalidCreds));
+		return;
+	}
+	if (UpdatedUserStats.Num() == 0 )
+	{
+		UE_LOG_ONLINE_STATS(Error, TEXT("UpdateStats() failed for player due to no user stats being specified"));
+		Delegate.ExecuteIfBound(FOnlineError(EOnlineErrorResult::InvalidParams));
+		return;
+	}
+
+	// Trigger one write for each user
+	for (const FOnlineStatsUserUpdatedStats& StatsUpdate : UpdatedUserStats)
+	{
+		EOS_ProductUserId StatsUser = EOSSubsystem->UserManager->GetProductUserId(*StatsUpdate.Account);
+		if (StatsUser != nullptr)
+		{
+			WriteStats(UserId, StatsUser, StatsUpdate);
+		}
+		else
+		{
+			UE_LOG_ONLINE_STATS(Error, TEXT("UpdateStats() failed for unknown player (%s)"), *StatsUpdate.Account->ToDebugString());
+		}
+	}
+	// Mabye these wrote correctly...
+	Delegate.ExecuteIfBound(FOnlineError(EOnlineErrorResult::Success));
+}
+
+#if !UE_BUILD_SHIPPING
+void FOnlineStatsEOS::ResetStats(const FUniqueNetIdRef StatsUserId)
+{
+	UE_LOG_ONLINE_STATS(Warning, TEXT("ResetStats() is not supported"));
+}
+#endif
+
+#endif
Index: Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Private/Android/AndroidEOSHelpers.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Private/Android/AndroidEOSHelpers.h b/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Private/Android/AndroidEOSHelpers.h
new file mode 100644
--- /dev/null	(date 1641575208000)
+++ b/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Private/Android/AndroidEOSHelpers.h	(date 1641575208000)
@@ -0,0 +1,11 @@
+// Copyright Epic Games, Inc. All Rights Reserved.
+
+#pragma once
+
+#if WITH_EOS_SDK
+
+#include "EOSHelpers.h"
+
+using FPlatformEOSHelpers = FEOSHelpers;
+
+#endif
\ No newline at end of file
Index: Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Private/Windows/WindowsEOSHelpers.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Private/Windows/WindowsEOSHelpers.cpp b/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Private/Windows/WindowsEOSHelpers.cpp
new file mode 100644
--- /dev/null	(date 1641575208000)
+++ b/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Private/Windows/WindowsEOSHelpers.cpp	(date 1641575208000)
@@ -0,0 +1,34 @@
+// Copyright Epic Games, Inc. All Rights Reserved.
+
+#include "WindowsEOSHelpers.h"
+
+#if WITH_EOS_SDK
+
+#include "EOSShared.h"
+#include "HAL/FileManager.h"
+#include "Misc/Paths.h"
+#if WITH_EOS_RTC
+#include "Windows/eos_Windows.h"
+#endif
+
+IEOSPlatformHandlePtr FWindowsEOSHelpers::CreatePlatform(EOS_Platform_Options& PlatformOptions)
+{
+#if WITH_EOS_RTC
+	const FTCHARToUTF8 Utf8XAudioPath(*IFileManager::Get().ConvertToAbsolutePathForExternalAppForRead(*FPaths::Combine(FPaths::EngineDir(), TEXT("Binaries/ThirdParty/Windows/XAudio2_9"), PLATFORM_64BITS ? TEXT("x64") : TEXT("x86"), TEXT("xaudio2_9redist.dll"))));
+
+	EOS_Windows_RTCOptions WindowsRtcOptions = { 0 };
+	WindowsRtcOptions.ApiVersion = EOS_WINDOWS_RTCOPTIONS_API_LATEST;
+	static_assert(EOS_WINDOWS_RTCOPTIONS_API_LATEST == 1, "EOS_Windows_RTCOptions updated, check new fields");
+	WindowsRtcOptions.XAudio29DllPath = Utf8XAudioPath.Get();
+
+	EOS_Platform_RTCOptions* RTCOptions = const_cast<EOS_Platform_RTCOptions*>(PlatformOptions.RTCOptions);
+	if (ensure(RTCOptions))
+	{
+		RTCOptions->PlatformSpecificOptions = &WindowsRtcOptions;
+	}
+#endif // WITH_EOS_RTC
+
+	return FEOSHelpers::CreatePlatform(PlatformOptions);
+}
+
+#endif // WITH_EOS_SDK
\ No newline at end of file
Index: Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Private/Windows/WindowsEOSHelpers.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Private/Windows/WindowsEOSHelpers.h b/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Private/Windows/WindowsEOSHelpers.h
new file mode 100644
--- /dev/null	(date 1641575208000)
+++ b/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Private/Windows/WindowsEOSHelpers.h	(date 1641575208000)
@@ -0,0 +1,19 @@
+// Copyright Epic Games, Inc. All Rights Reserved.
+
+#pragma once
+
+#if WITH_EOS_SDK
+
+#include "EOSHelpers.h"
+
+class FWindowsEOSHelpers : public FEOSHelpers
+{
+public:
+	virtual ~FWindowsEOSHelpers() = default;
+
+	virtual IEOSPlatformHandlePtr CreatePlatform(EOS_Platform_Options& PlatformOptions) override;
+};
+
+using FPlatformEOSHelpers = FWindowsEOSHelpers;
+
+#endif // WITH_EOS_SDK
\ No newline at end of file
Index: Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Private/OnlineSubsystemEOS.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Private/OnlineSubsystemEOS.cpp b/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Private/OnlineSubsystemEOS.cpp
new file mode 100644
--- /dev/null	(date 1641576012000)
+++ b/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Private/OnlineSubsystemEOS.cpp	(date 1641576012000)
@@ -0,0 +1,719 @@
+// Copyright Epic Games, Inc. All Rights Reserved.
+
+#include "OnlineSubsystemEOS.h"
+#include "OnlineSubsystemUtils.h"
+#include "UserManagerEOS.h"
+#include "OnlineSessionEOS.h"
+#include "OnlineStatsEOS.h"
+#include "OnlineLeaderboardsEOS.h"
+#include "OnlineAchievementsEOS.h"
+#include "OnlineTitleFileEOS.h"
+#include "OnlineUserCloudEOS.h"
+#include "OnlineStoreEOS.h"
+#include "EOSSettings.h"
+#include "EOSShared.h"
+#include "IEOSSDKManager.h"
+
+#include "Features/IModularFeatures.h"
+#include "Misc/App.h"
+#include "Misc/NetworkVersion.h"
+#include "Misc/App.h"
+#include "Misc/ConfigCacheIni.h"
+
+#if WITH_EOS_SDK
+
+// Missing defines
+#define EOS_ENCRYPTION_KEY_MAX_LENGTH 64
+#define EOS_ENCRYPTION_KEY_MAX_BUFFER_LEN (EOS_ENCRYPTION_KEY_MAX_LENGTH + 1)
+
+#if WITH_EOS_RTC
+
+#include "EOSVoiceChatFactory.h"
+#include "EOSVoiceChatUser.h"
+#include "VoiceChatResult.h"
+#include "VoiceChatErrors.h"
+
+/** Class that blocks login/logout for the OSS EOS managed IVoiceChatUser interfaces. */
+class FOnlineSubsystemEOSVoiceChatUserWrapper : public IVoiceChatUser
+{
+public:
+	FOnlineSubsystemEOSVoiceChatUserWrapper(FEOSVoiceChatUser& InVoiceChatUser) : VoiceChatUser(InVoiceChatUser) {}
+	~FOnlineSubsystemEOSVoiceChatUserWrapper() = default;
+
+	// ~Begin IVoiceChatUser
+	virtual void SetSetting(const FString& Name, const FString& Value) override { VoiceChatUser.SetSetting(Name, Value); }
+	virtual FString GetSetting(const FString& Name) override { return VoiceChatUser.GetSetting(Name); }
+	virtual void SetAudioInputVolume(float Volume) override { VoiceChatUser.SetAudioInputVolume(Volume); }
+	virtual void SetAudioOutputVolume(float Volume) override { VoiceChatUser.SetAudioOutputVolume(Volume); }
+	virtual float GetAudioInputVolume() const override { return VoiceChatUser.GetAudioInputVolume(); }
+	virtual float GetAudioOutputVolume() const override { return VoiceChatUser.GetAudioOutputVolume(); }
+	virtual void SetAudioInputDeviceMuted(bool bIsMuted) override { VoiceChatUser.SetAudioInputDeviceMuted(bIsMuted); }
+	virtual void SetAudioOutputDeviceMuted(bool bIsMuted) override { VoiceChatUser.SetAudioOutputDeviceMuted(bIsMuted); }
+	virtual bool GetAudioInputDeviceMuted() const override { return VoiceChatUser.GetAudioInputDeviceMuted(); }
+	virtual bool GetAudioOutputDeviceMuted() const override { return VoiceChatUser.GetAudioOutputDeviceMuted(); }
+	virtual TArray<FVoiceChatDeviceInfo> GetAvailableInputDeviceInfos() const override { return VoiceChatUser.GetAvailableInputDeviceInfos(); }
+	virtual TArray<FVoiceChatDeviceInfo> GetAvailableOutputDeviceInfos() const override { return VoiceChatUser.GetAvailableOutputDeviceInfos(); }
+	virtual FOnVoiceChatAvailableAudioDevicesChangedDelegate& OnVoiceChatAvailableAudioDevicesChanged() override { return VoiceChatUser.OnVoiceChatAvailableAudioDevicesChanged(); }
+	virtual void SetInputDeviceId(const FString& InputDeviceId) override { VoiceChatUser.SetInputDeviceId(InputDeviceId); }
+	virtual void SetOutputDeviceId(const FString& OutputDeviceId) override { VoiceChatUser.SetOutputDeviceId(OutputDeviceId); }
+	virtual FVoiceChatDeviceInfo GetInputDeviceInfo() const override { return VoiceChatUser.GetInputDeviceInfo(); }
+	virtual FVoiceChatDeviceInfo GetOutputDeviceInfo() const override { return VoiceChatUser.GetOutputDeviceInfo(); }
+	virtual FVoiceChatDeviceInfo GetDefaultInputDeviceInfo() const override { return VoiceChatUser.GetDefaultInputDeviceInfo(); }
+	virtual FVoiceChatDeviceInfo GetDefaultOutputDeviceInfo() const override { return VoiceChatUser.GetDefaultOutputDeviceInfo(); }
+	virtual void Login(FPlatformUserId PlatformId, const FString& PlayerName, const FString& Credentials, const FOnVoiceChatLoginCompleteDelegate& Delegate) override
+	{
+		UE_LOG_ONLINE(Error, TEXT("FOnlineSubsystemEOS: IVoiceChatUser::Login called on OSS EOS managed VoiceChatUser interface."));
+		checkNoEntry();
+		Delegate.ExecuteIfBound(PlayerName, VoiceChat::Errors::NotPermitted());
+	}
+	virtual void Logout(const FOnVoiceChatLogoutCompleteDelegate& Delegate) override
+	{
+		UE_LOG_ONLINE(Error, TEXT("FOnlineSubsystemEOS: IVoiceChatUser::Logout called on OSS EOS managed VoiceChatUser interface."));
+		checkNoEntry();
+		Delegate.ExecuteIfBound(VoiceChatUser.GetLoggedInPlayerName(), VoiceChat::Errors::NotPermitted());
+	}
+	virtual bool IsLoggingIn() const override { return VoiceChatUser.IsLoggingIn(); }
+	virtual bool IsLoggedIn() const override { return VoiceChatUser.IsLoggedIn(); }
+	virtual FOnVoiceChatLoggedInDelegate& OnVoiceChatLoggedIn() override { return VoiceChatUser.OnVoiceChatLoggedIn(); }
+	virtual FOnVoiceChatLoggedOutDelegate& OnVoiceChatLoggedOut() override { return VoiceChatUser.OnVoiceChatLoggedOut(); }
+	virtual FString GetLoggedInPlayerName() const override { return VoiceChatUser.GetLoggedInPlayerName(); }
+	virtual void BlockPlayers(const TArray<FString>& PlayerNames) override { VoiceChatUser.BlockPlayers(PlayerNames); }
+	virtual void UnblockPlayers(const TArray<FString>& PlayerNames) override { return VoiceChatUser.UnblockPlayers(PlayerNames); }
+	virtual void JoinChannel(const FString& ChannelName, const FString& ChannelCredentials, EVoiceChatChannelType ChannelType, const FOnVoiceChatChannelJoinCompleteDelegate& Delegate, TOptional<FVoiceChatChannel3dProperties> Channel3dProperties = TOptional<FVoiceChatChannel3dProperties>()) override { VoiceChatUser.JoinChannel(ChannelName, ChannelCredentials, ChannelType, Delegate, Channel3dProperties); }
+	virtual void LeaveChannel(const FString& ChannelName, const FOnVoiceChatChannelLeaveCompleteDelegate& Delegate) override { VoiceChatUser.LeaveChannel(ChannelName, Delegate); }
+	virtual FOnVoiceChatChannelJoinedDelegate& OnVoiceChatChannelJoined() override { return VoiceChatUser.OnVoiceChatChannelJoined(); }
+	virtual FOnVoiceChatChannelExitedDelegate& OnVoiceChatChannelExited() override { return VoiceChatUser.OnVoiceChatChannelExited(); }
+	virtual FOnVoiceChatCallStatsUpdatedDelegate& OnVoiceChatCallStatsUpdated() override { return VoiceChatUser.OnVoiceChatCallStatsUpdated(); }
+	virtual void Set3DPosition(const FString& ChannelName, const FVector& SpeakerPosition, const FVector& ListenerPosition, const FVector& ListenerForwardDirection, const FVector& ListenerUpDirection) override { VoiceChatUser.Set3DPosition(ChannelName, SpeakerPosition, ListenerPosition, ListenerForwardDirection, ListenerUpDirection); }
+	virtual TArray<FString> GetChannels() const override { return VoiceChatUser.GetChannels(); }
+	virtual TArray<FString> GetPlayersInChannel(const FString& ChannelName) const override { return VoiceChatUser.GetPlayersInChannel(ChannelName); }
+	virtual EVoiceChatChannelType GetChannelType(const FString& ChannelName) const override { return VoiceChatUser.GetChannelType(ChannelName); }
+	virtual FOnVoiceChatPlayerAddedDelegate& OnVoiceChatPlayerAdded() override { return VoiceChatUser.OnVoiceChatPlayerAdded(); }
+	virtual FOnVoiceChatPlayerRemovedDelegate& OnVoiceChatPlayerRemoved() override { return VoiceChatUser.OnVoiceChatPlayerRemoved(); }
+	virtual bool IsPlayerTalking(const FString& PlayerName) const override { return VoiceChatUser.IsPlayerTalking(PlayerName); }
+	virtual FOnVoiceChatPlayerTalkingUpdatedDelegate& OnVoiceChatPlayerTalkingUpdated() override { return VoiceChatUser.OnVoiceChatPlayerTalkingUpdated(); }
+	virtual void SetPlayerMuted(const FString& PlayerName, bool bMuted) override { VoiceChatUser.SetPlayerMuted(PlayerName, bMuted); }
+	virtual bool IsPlayerMuted(const FString& PlayerName) const override { return VoiceChatUser.IsPlayerMuted(PlayerName); }
+	virtual void SetChannelPlayerMuted(const FString& ChannelName, const FString& PlayerName, bool bMuted) override { VoiceChatUser.SetChannelPlayerMuted(ChannelName, PlayerName, bMuted); }
+	virtual bool IsChannelPlayerMuted(const FString& ChannelName, const FString& PlayerName) const override { return VoiceChatUser.IsChannelPlayerMuted(ChannelName, PlayerName); }
+	virtual FOnVoiceChatPlayerMuteUpdatedDelegate& OnVoiceChatPlayerMuteUpdated() override { return VoiceChatUser.OnVoiceChatPlayerMuteUpdated(); }
+	virtual void SetPlayerVolume(const FString& PlayerName, float Volume) override { VoiceChatUser.SetPlayerVolume(PlayerName, Volume); }
+	virtual float GetPlayerVolume(const FString& PlayerName) const override { return VoiceChatUser.GetPlayerVolume(PlayerName); }
+	virtual FOnVoiceChatPlayerVolumeUpdatedDelegate& OnVoiceChatPlayerVolumeUpdated() override { return VoiceChatUser.OnVoiceChatPlayerVolumeUpdated(); }
+	virtual void TransmitToAllChannels() override { VoiceChatUser.TransmitToAllChannels(); }
+	virtual void TransmitToNoChannels() override { VoiceChatUser.TransmitToNoChannels(); }
+	virtual void TransmitToSpecificChannel(const FString& ChannelName) override { VoiceChatUser.TransmitToSpecificChannel(ChannelName); }
+	virtual EVoiceChatTransmitMode GetTransmitMode() const override { return VoiceChatUser.GetTransmitMode(); }
+	virtual FString GetTransmitChannel() const override { return VoiceChatUser.GetTransmitChannel(); }
+	virtual FDelegateHandle StartRecording(const FOnVoiceChatRecordSamplesAvailableDelegate::FDelegate& Delegate) override { return VoiceChatUser.StartRecording(Delegate); }
+	virtual void StopRecording(FDelegateHandle Handle) override { VoiceChatUser.StopRecording(Handle); }
+	virtual FDelegateHandle RegisterOnVoiceChatAfterCaptureAudioReadDelegate(const FOnVoiceChatAfterCaptureAudioReadDelegate::FDelegate& Delegate) override { return VoiceChatUser.RegisterOnVoiceChatAfterCaptureAudioReadDelegate(Delegate); }
+	virtual void UnregisterOnVoiceChatAfterCaptureAudioReadDelegate(FDelegateHandle Handle) override { VoiceChatUser.UnregisterOnVoiceChatAfterCaptureAudioReadDelegate(Handle); }
+	virtual FDelegateHandle RegisterOnVoiceChatBeforeCaptureAudioSentDelegate(const FOnVoiceChatBeforeCaptureAudioSentDelegate::FDelegate& Delegate) override { return VoiceChatUser.RegisterOnVoiceChatBeforeCaptureAudioSentDelegate(Delegate); }
+	virtual void UnregisterOnVoiceChatBeforeCaptureAudioSentDelegate(FDelegateHandle Handle) override { VoiceChatUser.UnregisterOnVoiceChatBeforeCaptureAudioSentDelegate(Handle); }
+	virtual FDelegateHandle RegisterOnVoiceChatBeforeRecvAudioRenderedDelegate(const FOnVoiceChatBeforeRecvAudioRenderedDelegate::FDelegate& Delegate) override { return VoiceChatUser.RegisterOnVoiceChatBeforeRecvAudioRenderedDelegate(Delegate); }
+	virtual void UnregisterOnVoiceChatBeforeRecvAudioRenderedDelegate(FDelegateHandle Handle) override { VoiceChatUser.UnregisterOnVoiceChatBeforeRecvAudioRenderedDelegate(Handle); }
+	virtual FString InsecureGetLoginToken(const FString& PlayerName) override { return VoiceChatUser.InsecureGetLoginToken(PlayerName); }
+	virtual FString InsecureGetJoinToken(const FString& ChannelName, EVoiceChatChannelType ChannelType, TOptional<FVoiceChatChannel3dProperties> Channel3dProperties = TOptional<FVoiceChatChannel3dProperties>()) override { return VoiceChatUser.InsecureGetJoinToken(ChannelName, ChannelType, Channel3dProperties); }
+	// ~End IVoiceChatUser
+
+	FEOSVoiceChatUser& VoiceChatUser;
+};
+
+#endif // WITH_EOS_RTC
+
+/** Class that holds the strings for the call duration */
+struct FEOSPlatformOptions :
+	public EOS_Platform_Options
+{
+	FEOSPlatformOptions() :
+		EOS_Platform_Options()
+	{
+		ApiVersion = EOS_PLATFORM_OPTIONS_API_LATEST;
+		ProductId = ProductIdAnsi;
+		SandboxId = SandboxIdAnsi;
+		DeploymentId = DeploymentIdAnsi;
+		ClientCredentials.ClientId = ClientIdAnsi;
+		ClientCredentials.ClientSecret = ClientSecretAnsi;
+		CacheDirectory = CacheDirectoryAnsi;
+		EncryptionKey = EncryptionKeyAnsi;
+	}
+
+	char ClientIdAnsi[EOS_OSS_STRING_BUFFER_LENGTH];
+	char ClientSecretAnsi[EOS_OSS_STRING_BUFFER_LENGTH];
+	char ProductIdAnsi[EOS_OSS_STRING_BUFFER_LENGTH];
+	char SandboxIdAnsi[EOS_OSS_STRING_BUFFER_LENGTH];
+	char DeploymentIdAnsi[EOS_OSS_STRING_BUFFER_LENGTH];
+	char CacheDirectoryAnsi[EOS_OSS_STRING_BUFFER_LENGTH];
+	char EncryptionKeyAnsi[EOS_ENCRYPTION_KEY_MAX_BUFFER_LEN];
+};
+
+FPlatformEOSHelpersPtr FOnlineSubsystemEOS::EOSHelpersPtr;
+
+bool FCallbackBase::bShouldCancelAllCallbacks = false;
+
+void FOnlineSubsystemEOS::ModuleInit()
+{
+	LLM_SCOPE(ELLMTag::RealTimeCommunications);
+
+	EOSHelpersPtr = MakeShareable(new FPlatformEOSHelpers());
+
+	const FName EOSSharedModuleName = TEXT("EOSShared");
+	if (!FModuleManager::Get().IsModuleLoaded(EOSSharedModuleName))
+	{
+		FModuleManager::Get().LoadModuleChecked(EOSSharedModuleName);
+	}
+	IEOSSDKManager* EOSSDKManager = IEOSSDKManager::Get();
+	if (!EOSSDKManager)
+	{
+		UE_LOG_ONLINE(Error, TEXT("FOnlineSubsystemEOS: Missing IEOSSDKManager modular feature."));
+		return;
+	}
+
+	EOS_EResult InitResult = EOSSDKManager->Initialize();
+	if (InitResult != EOS_EResult::EOS_Success)
+	{
+		UE_LOG_ONLINE(Error, TEXT("FOnlineSubsystemEOS: failed to initialize the EOS SDK with result code (%d)"), InitResult);
+		return;
+	}
+}
+
+void FOnlineSubsystemEOS::ModuleShutdown()
+{
+#define DESTRUCT_INTERFACE(Interface) \
+	if (Interface.IsValid()) \
+	{ \
+		ensure(Interface.IsUnique()); \
+		Interface = nullptr; \
+	}
+
+	DESTRUCT_INTERFACE(EOSHelpersPtr);
+
+#undef DESTRUCT_INTERFACE
+}
+
+/** Common method for creating the EOS platform */
+bool FOnlineSubsystemEOS::PlatformCreate()
+{
+	FString ArtifactName;
+	FParse::Value(FCommandLine::Get(), TEXT("EpicApp="), ArtifactName);
+	// Find the settings for this artifact
+	FEOSArtifactSettings ArtifactSettings;
+	if (!UEOSSettings::GetSettingsForArtifact(ArtifactName, ArtifactSettings))
+	{
+		UE_LOG_ONLINE(Error, TEXT("FOnlineSubsystemEOS::PlatformCreate() failed to find artifact settings object for artifact (%s)"), *ArtifactName);
+		return false;
+	}
+
+	// Create platform instance
+	FEOSPlatformOptions PlatformOptions;
+	FCStringAnsi::Strncpy(PlatformOptions.ClientIdAnsi, TCHAR_TO_UTF8(*ArtifactSettings.ClientId), EOS_OSS_STRING_BUFFER_LENGTH);
+	FCStringAnsi::Strncpy(PlatformOptions.ClientSecretAnsi, TCHAR_TO_UTF8(*ArtifactSettings.ClientSecret), EOS_OSS_STRING_BUFFER_LENGTH);
+	FCStringAnsi::Strncpy(PlatformOptions.ProductIdAnsi, TCHAR_TO_UTF8(*ArtifactSettings.ProductId), EOS_OSS_STRING_BUFFER_LENGTH);
+	FCStringAnsi::Strncpy(PlatformOptions.SandboxIdAnsi, TCHAR_TO_UTF8(*ArtifactSettings.SandboxId), EOS_OSS_STRING_BUFFER_LENGTH);
+	FCStringAnsi::Strncpy(PlatformOptions.DeploymentIdAnsi, TCHAR_TO_UTF8(*ArtifactSettings.DeploymentId), EOS_OSS_STRING_BUFFER_LENGTH);
+	PlatformOptions.bIsServer = IsRunningDedicatedServer() ? EOS_TRUE : EOS_FALSE;
+	PlatformOptions.Reserved = nullptr;
+	FEOSSettings EOSSettings = UEOSSettings::GetSettings();
+	uint64 OverlayFlags = 0;
+	if (!EOSSettings.bEnableOverlay)
+	{
+		OverlayFlags |= EOS_PF_DISABLE_OVERLAY;
+	}
+	if (!EOSSettings.bEnableSocialOverlay)
+	{
+		OverlayFlags |= EOS_PF_DISABLE_SOCIAL_OVERLAY;
+	}
+	PlatformOptions.Flags = IsRunningGame() ? OverlayFlags : EOS_PF_DISABLE_OVERLAY;
+	// Make the cache directory be in the user's writable area
+
+	const FString CacheDir = EOSHelpersPtr->PlatformCreateCacheDir(ArtifactName, EOSSettings.CacheDir);
+	FCStringAnsi::Strncpy(PlatformOptions.CacheDirectoryAnsi, TCHAR_TO_UTF8(*CacheDir), EOS_OSS_STRING_BUFFER_LENGTH);
+	FCStringAnsi::Strncpy(PlatformOptions.EncryptionKeyAnsi, TCHAR_TO_UTF8(*ArtifactSettings.EncryptionKey), EOS_ENCRYPTION_KEY_MAX_BUFFER_LEN);
+
+#if WITH_EOS_RTC
+	EOS_Platform_RTCOptions RtcOptions = { 0 };
+	RtcOptions.ApiVersion = EOS_PLATFORM_RTCOPTIONS_API_LATEST;
+	RtcOptions.PlatformSpecificOptions = nullptr;
+	PlatformOptions.RTCOptions = &RtcOptions;
+#endif
+
+	EOSPlatformHandle = EOSHelpersPtr->CreatePlatform(PlatformOptions);
+	if (EOSPlatformHandle == nullptr)
+	{
+		UE_LOG_ONLINE(Error, TEXT("FOnlineSubsystemEOS::PlatformCreate() failed to init EOS platform"));
+		return false;
+	}
+	
+	return true;
+}
+
+bool FOnlineSubsystemEOS::Init()
+{
+	// Determine if we are the default and if we're the platform OSS
+	FString DefaultOSS;
+	GConfig->GetString(TEXT("OnlineSubsystem"), TEXT("DefaultPlatformService"), DefaultOSS, GEngineIni);
+	FString PlatformOSS;
+	GConfig->GetString(TEXT("OnlineSubsystem"), TEXT("NativePlatformService"), PlatformOSS, GEngineIni);
+	bIsDefaultOSS = DefaultOSS == TEXT("EOS");
+	bIsPlatformOSS = PlatformOSS == TEXT("EOS");
+
+	// Check for being launched by EGS
+	bWasLaunchedByEGS = FParse::Param(FCommandLine::Get(), TEXT("EpicPortal"));
+	FEOSSettings EOSSettings = UEOSSettings::GetSettings();
+	if (!IsRunningDedicatedServer() && IsRunningGame() && !bWasLaunchedByEGS && EOSSettings.bShouldEnforceBeingLaunchedByEGS)
+	{
+		FString ArtifactName;
+		FParse::Value(FCommandLine::Get(), TEXT("EpicApp="), ArtifactName);
+		UE_LOG_ONLINE(Warning, TEXT("FOnlineSubsystemEOS::Init() relaunching artifact (%s) via the store"), *ArtifactName);
+		FPlatformProcess::LaunchURL(*FString::Printf(TEXT("com.epicgames.launcher://store/product/%s?action=launch&silent=true"), *ArtifactName), nullptr, nullptr);
+		FPlatformMisc::RequestExit(false);
+		return false;
+	}
+
+	EOSSDKManager = IEOSSDKManager::Get();
+	if (!EOSSDKManager)
+	{
+		UE_LOG_ONLINE(Error, TEXT("FOnlineSubsystemEOS::Init() failed to get EOSSDKManager interface"));
+		return false;
+	}
+
+	if (!PlatformCreate())
+	{
+		return false;
+	}
+
+	// Get handles for later use
+	AuthHandle = EOS_Platform_GetAuthInterface(*EOSPlatformHandle);
+	if (AuthHandle == nullptr)
+	{
+		UE_LOG_ONLINE(Error, TEXT("FOnlineSubsystemEOS: failed to init EOS platform, couldn't get auth handle"));
+		return false;
+	}
+	UserInfoHandle = EOS_Platform_GetUserInfoInterface(*EOSPlatformHandle);
+	if (UserInfoHandle == nullptr)
+	{
+		UE_LOG_ONLINE(Error, TEXT("FOnlineSubsystemEOS: failed to init EOS platform, couldn't get user info handle"));
+		return false;
+	}
+	UIHandle = EOS_Platform_GetUIInterface(*EOSPlatformHandle);
+	if (UIHandle == nullptr)
+	{
+		UE_LOG_ONLINE(Error, TEXT("FOnlineSubsystemEOS: failed to init EOS platform, couldn't get UI handle"));
+		return false;
+	}
+	FriendsHandle = EOS_Platform_GetFriendsInterface(*EOSPlatformHandle);
+	if (FriendsHandle == nullptr)
+	{
+		UE_LOG_ONLINE(Error, TEXT("FOnlineSubsystemEOS: failed to init EOS platform, couldn't get friends handle"));
+		return false;
+	}
+	PresenceHandle = EOS_Platform_GetPresenceInterface(*EOSPlatformHandle);
+	if (PresenceHandle == nullptr)
+	{
+		UE_LOG_ONLINE(Error, TEXT("FOnlineSubsystemEOS: failed to init EOS platform, couldn't get presence handle"));
+		return false;
+	}
+	ConnectHandle = EOS_Platform_GetConnectInterface(*EOSPlatformHandle);
+	if (ConnectHandle == nullptr)
+	{
+		UE_LOG_ONLINE(Error, TEXT("FOnlineSubsystemEOS: failed to init EOS platform, couldn't get connect handle"));
+		return false;
+	}
+	SessionsHandle = EOS_Platform_GetSessionsInterface(*EOSPlatformHandle);
+	if (SessionsHandle == nullptr)
+	{
+		UE_LOG_ONLINE(Error, TEXT("FOnlineSubsystemEOS: failed to init EOS platform, couldn't get sessions handle"));
+		return false;
+	}
+	StatsHandle = EOS_Platform_GetStatsInterface(*EOSPlatformHandle);
+	if (StatsHandle == nullptr)
+	{
+		UE_LOG_ONLINE(Error, TEXT("FOnlineSubsystemEOS: failed to init EOS platform, couldn't get stats handle"));
+		return false;
+	}
+	LeaderboardsHandle = EOS_Platform_GetLeaderboardsInterface(*EOSPlatformHandle);
+	if (LeaderboardsHandle == nullptr)
+	{
+		UE_LOG_ONLINE(Error, TEXT("FOnlineSubsystemEOS: failed to init EOS platform, couldn't get leaderboards handle"));
+		return false;
+	}
+	MetricsHandle = EOS_Platform_GetMetricsInterface(*EOSPlatformHandle);
+	if (MetricsHandle == nullptr)
+	{
+		UE_LOG_ONLINE(Error, TEXT("FOnlineSubsystemEOS: failed to init EOS platform, couldn't get metrics handle"));
+		return false;
+	}
+	AchievementsHandle = EOS_Platform_GetAchievementsInterface(*EOSPlatformHandle);
+	if (AchievementsHandle == nullptr)
+	{
+		UE_LOG_ONLINE(Error, TEXT("FOnlineSubsystemEOS: failed to init EOS platform, couldn't get achievements handle"));
+		return false;
+	}
+	P2PHandle = EOS_Platform_GetP2PInterface(*EOSPlatformHandle);
+	if (P2PHandle == nullptr)
+	{
+		UE_LOG_ONLINE(Error, TEXT("FOnlineSubsystemEOS: failed to init EOS platform, couldn't get p2p handle"));
+		return false;
+	}
+	// Disable ecom if not part of EGS
+	if (bWasLaunchedByEGS)
+	{
+		EcomHandle = EOS_Platform_GetEcomInterface(*EOSPlatformHandle);
+		if (EcomHandle == nullptr)
+		{
+			UE_LOG_ONLINE(Error, TEXT("FOnlineSubsystemEOS: failed to init EOS platform, couldn't get ecom handle"));
+			return false;
+		}
+		StoreInterfacePtr = MakeShareable(new FOnlineStoreEOS(this));
+	}
+	TitleStorageHandle = EOS_Platform_GetTitleStorageInterface(*EOSPlatformHandle);
+	if (TitleStorageHandle == nullptr)
+	{
+		UE_LOG_ONLINE(Error, TEXT("FOnlineSubsystemEOS: failed to init EOS platform, couldn't get title storage handle"));
+		return false;
+	}
+	PlayerDataStorageHandle = EOS_Platform_GetPlayerDataStorageInterface(*EOSPlatformHandle);
+	if (PlayerDataStorageHandle == nullptr)
+	{
+		UE_LOG_ONLINE(Error, TEXT("FOnlineSubsystemEOS: failed to init EOS platform, couldn't get player data storage handle"));
+		return false;
+	}
+
+	SocketSubsystem = MakeShareable(new FSocketSubsystemEOS(this));
+	FString ErrorMessage;
+	SocketSubsystem->Init(ErrorMessage);
+
+	// We set the product id
+	FString ArtifactName;
+	FParse::Value(FCommandLine::Get(), TEXT("EpicApp="), ArtifactName);
+	FEOSArtifactSettings ArtifactSettings;
+	if (UEOSSettings::GetSettingsForArtifact(ArtifactName, ArtifactSettings))
+	{
+		ProductId = ArtifactSettings.ProductId;
+	}
+	else
+	{
+		UE_LOG_ONLINE(Warning, TEXT("[FOnlineSubsystemEOS::Init] Failed to find artifact settings object for artifact (%s). ProductIdAnsi not set."), *ArtifactName);
+	}
+
+	UserManager = MakeShareable(new FUserManagerEOS(this));
+	SessionInterfacePtr = MakeShareable(new FOnlineSessionEOS(this));
+	// Set the bucket id to use for all sessions based upon the name and version to avoid upgrade issues
+	SessionInterfacePtr->Init(EOSSDKManager->GetProductName() + TEXT("_") + EOSSDKManager->GetProductVersion());
+	StatsInterfacePtr = MakeShareable(new FOnlineStatsEOS(this));
+	LeaderboardsInterfacePtr = MakeShareable(new FOnlineLeaderboardsEOS(this));
+	AchievementsInterfacePtr = MakeShareable(new FOnlineAchievementsEOS(this));
+	TitleFileInterfacePtr = MakeShareable(new FOnlineTitleFileEOS(this));
+	UserCloudInterfacePtr = MakeShareable(new FOnlineUserCloudEOS(this));
+
+	// We initialized ok so we can tick
+	StartTicker();
+
+	return true;
+}
+
+bool FOnlineSubsystemEOS::Shutdown()
+{
+	UE_LOG_ONLINE(VeryVerbose, TEXT("FOnlineSubsystemEOS::Shutdown()"));
+
+	// EOS-22677 workaround: Make sure tick is called at least once before shutting down.
+	if (EOSPlatformHandle)
+	{
+		EOS_Platform_Tick(*EOSPlatformHandle);
+	}
+
+	FCallbackBase::CancelAllCallbacks();
+	StopTicker();
+
+	if (SocketSubsystem)
+	{
+		SocketSubsystem->Shutdown();
+		SocketSubsystem = nullptr;
+	}
+
+	// Release our ref to the interfaces. May still exist since they can be aggregated
+	UserManager = nullptr;
+	SessionInterfacePtr = nullptr;
+	StatsInterfacePtr = nullptr;
+	LeaderboardsInterfacePtr = nullptr;
+	AchievementsInterfacePtr = nullptr;
+	StoreInterfacePtr = nullptr;
+	TitleFileInterfacePtr = nullptr;
+	UserCloudInterfacePtr = nullptr;
+
+#if WITH_EOS_RTC
+	for (TPair<FUniqueNetIdRef, FOnlineSubsystemEOSVoiceChatUserWrapperRef>& Pair : LocalVoiceChatUsers)
+	{
+		FOnlineSubsystemEOSVoiceChatUserWrapperRef& VoiceChatUserWrapper = Pair.Value;
+		VoiceChatInterface->ReleaseUser(&VoiceChatUserWrapper->VoiceChatUser);
+	}
+	LocalVoiceChatUsers.Reset();
+	VoiceChatInterface = nullptr;
+#endif
+
+	EOSPlatformHandle = nullptr;
+
+	return FOnlineSubsystemImpl::Shutdown();
+}
+
+bool FOnlineSubsystemEOS::Tick(float DeltaTime)
+{
+	if (!bTickerStarted)
+	{
+		return true;
+	}
+
+	SessionInterfacePtr->Tick(DeltaTime);
+	FOnlineSubsystemImpl::Tick(DeltaTime);
+
+	return true;
+}
+
+bool FOnlineSubsystemEOS::Exec(UWorld* InWorld, const TCHAR* Cmd, FOutputDevice& Ar)
+{
+	if (FOnlineSubsystemImpl::Exec(InWorld, Cmd, Ar))
+	{
+		return true;
+	}
+
+	bool bWasHandled = false;
+	if (UserManager != nullptr && FParse::Command(&Cmd, TEXT("FRIENDS")))
+	{
+		bWasHandled = UserManager->HandleFriendsExec(InWorld, Cmd, Ar);
+	}
+	else if (StoreInterfacePtr != nullptr && FParse::Command(&Cmd, TEXT("ECOM")))
+	{
+		bWasHandled = StoreInterfacePtr->HandleEcomExec(InWorld, Cmd, Ar);
+	}
+	else if (TitleFileInterfacePtr != nullptr && FParse::Command(&Cmd, TEXT("TITLEFILE")))
+	{
+		bWasHandled = TitleFileInterfacePtr->HandleTitleFileExec(InWorld, Cmd, Ar);
+	}
+	else if (UserCloudInterfacePtr != nullptr && FParse::Command(&Cmd, TEXT("USERCLOUD")))
+	{
+		bWasHandled = UserCloudInterfacePtr->HandleUserCloudExec(InWorld, Cmd, Ar);
+	}
+	else
+	{
+		bWasHandled = false;
+	}
+
+	return bWasHandled;
+}
+
+void FOnlineSubsystemEOS::ReloadConfigs(const TSet<FString>& ConfigSections)
+{
+	UE_LOG_ONLINE(Verbose, TEXT("FOnlineSubsystemEOS::ReloadConfigs"));
+
+	// There is currently no granular reloading, so just restart the subsystem to pick up new config.
+	const bool bWasInitialized = EOSPlatformHandle != nullptr;
+	const bool bConfigChanged = ConfigSections.Find(GetDefault<UEOSSettings>()->GetClass()->GetPathName()) != nullptr;
+	const bool bRestartRequired = bWasInitialized && bConfigChanged;
+
+	if (bRestartRequired)
+	{
+		UE_LOG_ONLINE(Verbose, TEXT("FOnlineSubsystemEOS::ReloadConfigs: Restarting subsystem to pick up changes."));
+		PreUnload();
+		Shutdown();
+	}
+
+	// Notify user code so that overrides may be applied.
+	TriggerOnConfigChangedDelegates(ConfigSections);
+
+	// Reload config objects.
+	if (bConfigChanged)
+	{
+		GetMutableDefault<UEOSSettings>()->ReloadConfig();
+	}
+
+	if (bRestartRequired)
+	{
+		Init();
+	}
+}
+
+FString FOnlineSubsystemEOS::GetAppId() const
+{
+	return TEXT("");
+}
+
+FText FOnlineSubsystemEOS::GetOnlineServiceName() const
+{
+	return NSLOCTEXT("OnlineSubsystemEOS", "OnlineServiceName", "EOS");
+}
+
+FOnlineSubsystemEOS::FOnlineSubsystemEOS(FName InInstanceName) :
+	FOnlineSubsystemImpl(EOS_SUBSYSTEM, InInstanceName)
+	, EOSSDKManager(nullptr)
+	, AuthHandle(nullptr)
+	, UIHandle(nullptr)
+	, FriendsHandle(nullptr)
+	, UserInfoHandle(nullptr)
+	, PresenceHandle(nullptr)
+	, ConnectHandle(nullptr)
+	, SessionsHandle(nullptr)
+	, StatsHandle(nullptr)
+	, LeaderboardsHandle(nullptr)
+	, MetricsHandle(nullptr)
+	, AchievementsHandle(nullptr)
+	, P2PHandle(nullptr)
+	, EcomHandle(nullptr)
+	, TitleStorageHandle(nullptr)
+	, PlayerDataStorageHandle(nullptr)
+	, UserManager(nullptr)
+	, SessionInterfacePtr(nullptr)
+	, LeaderboardsInterfacePtr(nullptr)
+	, AchievementsInterfacePtr(nullptr)
+	, StoreInterfacePtr(nullptr)
+	, TitleFileInterfacePtr(nullptr)
+	, UserCloudInterfacePtr(nullptr)
+	, bWasLaunchedByEGS(false)
+	, bIsDefaultOSS(false)
+	, bIsPlatformOSS(false)
+{
+	StopTicker();
+}
+
+IOnlineSessionPtr FOnlineSubsystemEOS::GetSessionInterface() const
+{
+	return SessionInterfacePtr;
+}
+
+IOnlineFriendsPtr FOnlineSubsystemEOS::GetFriendsInterface() const
+{
+	return UserManager;
+}
+
+IOnlineSharedCloudPtr FOnlineSubsystemEOS::GetSharedCloudInterface() const
+{
+	UE_LOG_ONLINE(Error, TEXT("Shared Cloud Interface Requested"));
+	return nullptr;
+}
+
+IOnlineUserCloudPtr FOnlineSubsystemEOS::GetUserCloudInterface() const
+{
+	return UserCloudInterfacePtr;
+}
+
+IOnlineEntitlementsPtr FOnlineSubsystemEOS::GetEntitlementsInterface() const
+{
+	UE_LOG_ONLINE(Error, TEXT("Entitlements Interface Requested"));
+	return nullptr;
+};
+
+IOnlineLeaderboardsPtr FOnlineSubsystemEOS::GetLeaderboardsInterface() const
+{
+	return LeaderboardsInterfacePtr;
+}
+
+IOnlineVoicePtr FOnlineSubsystemEOS::GetVoiceInterface() const
+{
+	return nullptr;
+}
+
+IOnlineExternalUIPtr FOnlineSubsystemEOS::GetExternalUIInterface() const
+{
+	return UserManager;
+}
+
+IOnlineIdentityPtr FOnlineSubsystemEOS::GetIdentityInterface() const
+{
+	return UserManager;
+}
+
+IOnlineTitleFilePtr FOnlineSubsystemEOS::GetTitleFileInterface() const
+{
+	return TitleFileInterfacePtr;
+}
+
+IOnlineStoreV2Ptr FOnlineSubsystemEOS::GetStoreV2Interface() const
+{
+	return StoreInterfacePtr;
+}
+
+IOnlinePurchasePtr FOnlineSubsystemEOS::GetPurchaseInterface() const
+{
+	return StoreInterfacePtr;
+}
+
+IOnlineAchievementsPtr FOnlineSubsystemEOS::GetAchievementsInterface() const
+{
+	return AchievementsInterfacePtr;
+}
+
+IOnlineUserPtr FOnlineSubsystemEOS::GetUserInterface() const
+{
+	return UserManager;
+}
+
+IOnlinePresencePtr FOnlineSubsystemEOS::GetPresenceInterface() const
+{
+	return UserManager;
+}
+
+IOnlineStatsPtr FOnlineSubsystemEOS::GetStatsInterface() const
+{
+	return StatsInterfacePtr;
+}
+
+IVoiceChatUser* FOnlineSubsystemEOS::GetVoiceChatUserInterface(const FUniqueNetId& LocalUserId)
+{
+	IVoiceChatUser* Result = nullptr;
+
+#if WITH_EOS_RTC
+	if (!VoiceChatInterface)
+	{
+		if (FEOSVoiceChatFactory* EOSVoiceChatFactory = FEOSVoiceChatFactory::Get())
+		{
+			VoiceChatInterface = EOSVoiceChatFactory->CreateInstanceWithPlatform(EOSPlatformHandle);
+		}
+	}
+
+	if(VoiceChatInterface && UserManager->IsLocalUser(LocalUserId))
+	{
+		if (FOnlineSubsystemEOSVoiceChatUserWrapperRef* WrapperPtr = LocalVoiceChatUsers.Find(LocalUserId.AsShared()))
+		{
+			Result = &WrapperPtr->Get();
+		}
+		else
+		{
+			FEOSVoiceChatUser* VoiceChatUser = static_cast<FEOSVoiceChatUser*>(VoiceChatInterface->CreateUser());
+			VoiceChatUser->Login(UserManager->GetPlatformUserIdFromUniqueNetId(LocalUserId), FUniqueNetIdEOS::Cast(LocalUserId).ProductUserIdStr, FString(), FOnVoiceChatLoginCompleteDelegate());
+
+			const FOnlineSubsystemEOSVoiceChatUserWrapperRef& Wrapper = LocalVoiceChatUsers.Emplace(LocalUserId.AsShared(), MakeShared<FOnlineSubsystemEOSVoiceChatUserWrapper, ESPMode::ThreadSafe>(*VoiceChatUser));
+			Result = &Wrapper.Get();
+		}
+	}
+#endif // WITH_EOS_RTC
+
+	return Result;
+}
+
+FEOSVoiceChatUser* FOnlineSubsystemEOS::GetEOSVoiceChatUserInterface(const FUniqueNetId& LocalUserId)
+{
+	FEOSVoiceChatUser* Result = nullptr;
+#if WITH_EOS_RTC
+	if (IVoiceChatUser* Wrapper = GetVoiceChatUserInterface(LocalUserId))
+	{
+		Result = &static_cast<FOnlineSubsystemEOSVoiceChatUserWrapper*>(Wrapper)->VoiceChatUser;
+	}
+#endif
+	return Result;
+}
+
+void FOnlineSubsystemEOS::ReleaseVoiceChatUserInterface(const FUniqueNetId& LocalUserId)
+{
+#if WITH_EOS_RTC
+	if (VoiceChatInterface)
+	{
+		if (FOnlineSubsystemEOSVoiceChatUserWrapperRef* WrapperPtr = LocalVoiceChatUsers.Find(LocalUserId.AsShared()))
+		{
+			VoiceChatInterface->ReleaseUser(&(**WrapperPtr).VoiceChatUser);
+			LocalVoiceChatUsers.Remove(LocalUserId.AsShared());
+		}
+	}
+#endif
+}
+
+#endif // WITH_EOS_SDK
Index: Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Private/IOS/IOSEOSHelpers.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Private/IOS/IOSEOSHelpers.h b/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Private/IOS/IOSEOSHelpers.h
new file mode 100644
--- /dev/null	(date 1641575208000)
+++ b/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Private/IOS/IOSEOSHelpers.h	(date 1641575208000)
@@ -0,0 +1,36 @@
+// Copyright Epic Games, Inc. All Rights Reserved.
+
+#pragma once
+
+#if WITH_EOS_SDK
+
+#include "eos_auth_types.h"
+#include "eos_ios.h"
+#include "Interfaces/OnlineExternalUIInterface.h"
+#include "EOSHelpers.h"
+
+class FOnlineSubsystemEOS;
+
+class FIOSEOSHelpers : FEOSHelpers
+{
+public:
+	virtual ~FIOSEOSHelpers();
+
+	virtual FString PlatformCreateCacheDir(const FString &ArtifactName, const FString &EOSSettingsCacheDir) override;
+	virtual void PlatformAuthCredentials(EOS_Auth_Credentials &Credentials) override;
+	virtual void PlatformTriggerLoginUI(FOnlineSubsystemEOS* EOSSubsystem, const int ControllerIndex, bool bShowOnlineOnly, bool bShowSkipButton, const FOnLoginUIClosedDelegate& Delegate) override;
+
+private:
+	void OnLoginComplete(int ControllerIndex, bool bWasSuccessful, const FUniqueNetId& UserId, const FString& ErrorString);
+
+	EOS_IOS_Auth_CredentialsOptions CredentialsOptions;
+
+	FOnlineSubsystemEOS* EOSSubsystem;
+	FOnLoginUIClosedDelegate LoginUIClosedDelegate;
+	FDelegateHandle LoginCompleteDelegate;
+};
+
+using FPlatformEOSHelpers = FIOSEOSHelpers;
+
+#endif
+
Index: Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Private/IOS/IOSEOSHelpers.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Private/IOS/IOSEOSHelpers.cpp b/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Private/IOS/IOSEOSHelpers.cpp
new file mode 100644
--- /dev/null	(date 1641575208000)
+++ b/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Private/IOS/IOSEOSHelpers.cpp	(date 1641575208000)
@@ -0,0 +1,118 @@
+// Copyright Epic Games, Inc. All Rights Reserved.
+
+#include "IOSEOSHelpers.h"
+
+#if WITH_EOS_SDK
+
+#include "OnlineSubsystemEOS.h"
+#include "UserManagerEOS.h"
+
+#if (defined(__IPHONE_13_0) && __IPHONE_OS_VERSION_MAX_ALLOWED >= __IPHONE_13_0)
+	#define PRESENTATIONCONTEXT_REQUIRED 1
+#else
+	#define PRESENTATIONCONTEXT_REQUIRED 0
+#endif
+
+#if PRESENTATIONCONTEXT_REQUIRED
+#import <Foundation/Foundation.h>
+#import <AuthenticationServices/AuthenticationServices.h>
+#include "IOS/IOSAppDelegate.h"
+#endif
+
+#if PRESENTATIONCONTEXT_REQUIRED
+@interface PresentationContext : NSObject <ASWebAuthenticationPresentationContextProviding>
+{
+}
+@end
+
+
+@implementation PresentationContext
+
+- (ASPresentationAnchor)presentationAnchorForWebAuthenticationSession:(ASWebAuthenticationSession *)session
+{
+	if ([IOSAppDelegate GetDelegate].Window == nullptr)
+	{
+		NSLog(@"authorizationController: presentationAnchorForAuthorizationController: error window is NULL");
+	}
+	return [IOSAppDelegate GetDelegate].Window;
+}
+
+@end
+
+static PresentationContext* PresentationContextProvider = nil;
+#endif
+
+FIOSEOSHelpers::~FIOSEOSHelpers()
+{
+#if PRESENTATIONCONTEXT_REQUIRED
+	if (PresentationContextProvider != nil)
+	{
+		[PresentationContextProvider release];
+		PresentationContextProvider = nil;
+	}
+#endif
+}
+
+FString FIOSEOSHelpers::PlatformCreateCacheDir(const FString &ArtifactName, const FString &EOSSettingsCacheDir)
+{
+	NSString *BundleIdentifier = [[NSBundle mainBundle] bundleIdentifier];
+	NSString *CacheDirectory = NSTemporaryDirectory();									// Potentially use NSCachesDirectory
+	CacheDirectory = [CacheDirectory stringByAppendingPathComponent:BundleIdentifier];
+
+	FTCHARToUTF8 TCArtifactName(*ArtifactName);
+	NSString *NSArtifactName = [NSString stringWithUTF8String:TCArtifactName.Get()];
+	CacheDirectory = [CacheDirectory stringByAppendingPathComponent:NSArtifactName];
+
+	FTCHARToUTF8 TCEOSSettingsCacheDir(*EOSSettingsCacheDir);
+	NSString *NSEOSSettingsCacheDir = [NSString stringWithUTF8String:TCArtifactName.Get()];
+	CacheDirectory = [CacheDirectory stringByAppendingPathComponent:NSEOSSettingsCacheDir];
+
+	const char *CStrCacheDirectory = [CacheDirectory UTF8String];
+	return FString(UTF8_TO_TCHAR(CStrCacheDirectory));
+}
+
+void FIOSEOSHelpers::PlatformAuthCredentials(EOS_Auth_Credentials &Credentials)
+{
+#if PRESENTATIONCONTEXT_REQUIRED
+	if (PresentationContextProvider == nil)
+	{
+		PresentationContextProvider = [PresentationContext new];
+	}
+#endif
+
+	CredentialsOptions.ApiVersion = EOS_IOS_AUTH_CREDENTIALSOPTIONS_API_LATEST;
+#if PRESENTATIONCONTEXT_REQUIRED
+	CredentialsOptions.PresentationContextProviding = (void*)CFBridgingRetain(PresentationContextProvider);		// SDK will release when consumed
+#else
+	CredentialsOptions.PresentationContextProviding = nullptr;
+#endif
+
+	Credentials.SystemAuthCredentialsOptions = (void*)&CredentialsOptions;
+}
+
+void FIOSEOSHelpers::PlatformTriggerLoginUI(FOnlineSubsystemEOS* InEOSSubsystem, const int ControllerIndex, bool bShowOnlineOnly, bool bShowSkipButton, const FOnLoginUIClosedDelegate& Delegate)
+{
+	EOSSubsystem = InEOSSubsystem;
+	check(EOSSubsystem != nullptr);
+
+	LoginUIClosedDelegate = Delegate;
+	LoginCompleteDelegate = EOSSubsystem->UserManager->AddOnLoginCompleteDelegate_Handle(ControllerIndex, FOnLoginCompleteDelegate::CreateRaw(this, &FIOSEOSHelpers::OnLoginComplete));
+
+	FOnlineAccountCredentials *Credentials = new FOnlineAccountCredentials(TEXT("accountportal"), TEXT(""), TEXT(""));
+	EOSSubsystem->UserManager->Login(ControllerIndex, *Credentials);
+}
+
+void FIOSEOSHelpers::OnLoginComplete(int ControllerIndex, bool bWasSuccessful, const FUniqueNetId& UserId, const FString& ErrorString)
+{
+	FOnlineError Error(bWasSuccessful);
+	Error.SetFromErrorCode(ErrorString);
+
+	check(EOSSubsystem != nullptr);
+
+	EOSSubsystem->UserManager->ClearOnLoginCompleteDelegate_Handle(ControllerIndex, LoginCompleteDelegate);
+
+	LoginUIClosedDelegate.ExecuteIfBound(UserId, ControllerIndex, Error);
+}
+
+#endif
+
Index: Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Private/Mac/MacEOSHelpers.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Private/Mac/MacEOSHelpers.h b/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Private/Mac/MacEOSHelpers.h
new file mode 100644
--- /dev/null	(date 1641575208000)
+++ b/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOS/Private/Mac/MacEOSHelpers.h	(date 1641575208000)
@@ -0,0 +1,12 @@
+// Copyright Epic Games, Inc. All Rights Reserved.
+
+#pragma once
+
+#if WITH_EOS_SDK
+
+#include "EOSHelpers.h"
+
+using FPlatformEOSHelpers = FEOSHelpers;
+
+#endif
+
Index: Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOSPlus/Private/OnlineSubsystemEOSPlus.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOSPlus/Private/OnlineSubsystemEOSPlus.cpp b/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOSPlus/Private/OnlineSubsystemEOSPlus.cpp
new file mode 100644
--- /dev/null	(date 1641576012000)
+++ b/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOSPlus/Private/OnlineSubsystemEOSPlus.cpp	(date 1641576012000)
@@ -0,0 +1,275 @@
+// Copyright Epic Games, Inc. All Rights Reserved.
+
+#include "OnlineSubsystemEOSPlus.h"
+
+#include "Misc/ConfigCacheIni.h"
+
+bool FOnlineSubsystemEOSPlus::Exec(UWorld* InWorld, const TCHAR* Cmd, FOutputDevice& Ar)
+{
+	if (FOnlineSubsystemImpl::Exec(InWorld, Cmd, Ar))
+	{
+		return true;
+	}
+
+	bool bWasHandled = false;
+	if (FParse::Command(&Cmd, TEXT("EOS")))
+	{
+		if (EosOSS != nullptr)
+		{
+			bWasHandled = EosOSS->Exec(InWorld, Cmd, Ar);
+		}
+	}
+
+	return bWasHandled;
+}
+
+FString FOnlineSubsystemEOSPlus::GetAppId() const
+{
+	return BaseOSS != nullptr ? BaseOSS->GetAppId() : TEXT("");
+}
+
+FText FOnlineSubsystemEOSPlus::GetOnlineServiceName() const
+{
+	return NSLOCTEXT("OnlineSubsystemEOSPlus", "OnlineServiceName", "EOS_Plus");
+}
+
+bool FOnlineSubsystemEOSPlus::Init()
+{
+	// Get name of Base OSS from config
+	FString BaseOSSName;
+	GConfig->GetString(TEXT("[OnlineSubsystemEOSPlus]"), TEXT("BaseOSSName"), BaseOSSName, GEngineIni);
+	if (BaseOSSName.IsEmpty())
+	{
+		// Load the native platform OSS name
+		GConfig->GetString(TEXT("OnlineSubsystem"), TEXT("NativePlatformService"), BaseOSSName, GEngineIni);
+	}
+	if (BaseOSSName.IsEmpty())
+	{
+		UE_LOG_ONLINE(Error, TEXT("FOnlineSubsystemEOSPlus::Init() failed to find the native OSS!"));
+		return false;
+	}
+
+	BaseOSS = IOnlineSubsystem::Get(FName(*BaseOSSName));
+	if (BaseOSS == nullptr)
+	{
+		UE_LOG_ONLINE(Error, TEXT("FOnlineSubsystemEOSPlus::Init() failed to get the platform OSS"));
+		return false;
+	}
+	if (BaseOSS->GetSubsystemName() == EOS_SUBSYSTEM ||
+		BaseOSS->GetSubsystemName() == EOSPLUS_SUBSYSTEM)
+	{
+		UE_LOG_ONLINE(Error, TEXT("FOnlineSubsystemEOSPlus::Init() failed due to circular configuration"));
+		BaseOSS = nullptr;
+		return false;
+	}
+
+	EosOSS = IOnlineSubsystem::Get(EOS_SUBSYSTEM);
+	if (EosOSS == nullptr)
+	{
+		UE_LOG_ONLINE(Error, TEXT("FOnlineSubsystemEOSPlus::Init() failed to get the EOS OSS"));
+		return false;
+	}
+
+	StatsInterfacePtr = MakeShareable(new FOnlineStatsEOSPlus(this));
+	AchievementsInterfacePtr = MakeShareable(new FOnlineAchievementsEOSPlus(this));
+	UserInterfacePtr = MakeShareable(new FOnlineUserEOSPlus(this));
+	SessionInterfacePtr = MakeShareable(new FOnlineSessionEOSPlus(this));
+	LeaderboardsInterfacePtr = MakeShareable(new FOnlineLeaderboardsEOSPlus(this));
+	StoreInterfacePtr = MakeShareable(new FOnlineStoreEOSPlus(this));
+	ExternalUIInterfacePtr = MakeShareable(new FOnlineExternalUIEOSPlus(this));
+	VoiceInterfacePtr = MakeShareable(new FOnlineVoiceEOSPlus(this));
+	TitleFileInterfacePtr = MakeShareable(new FOnlineTitleFileEOSPlus(this));
+	UserCloudInterfacePtr = MakeShareable(new FOnlineUserCloudEOSPlus(this));
+
+	UserInterfacePtr->Initialize();
+	LeaderboardsInterfacePtr->Initialize();
+	StoreInterfacePtr->Initialize();
+	ExternalUIInterfacePtr->Initialize();
+	VoiceInterfacePtr->Initialize();
+	TitleFileInterfacePtr->Initialize();
+	UserCloudInterfacePtr->Initialize();
+
+	return true;
+}
+
+void FOnlineSubsystemEOSPlus::PreUnload()
+{
+	//EOSPlus will be shutdown after its component subsystems, so we need to delete the references to their interfaces beforehand to avoid errors
+
+#define DESTRUCT_INTERFACE(Interface) \
+	if (Interface.IsValid()) \
+	{ \
+		ensure(Interface.IsUnique()); \
+		Interface = nullptr; \
+	}
+
+	DESTRUCT_INTERFACE(StatsInterfacePtr);
+	DESTRUCT_INTERFACE(AchievementsInterfacePtr);
+	DESTRUCT_INTERFACE(UserInterfacePtr);
+	DESTRUCT_INTERFACE(SessionInterfacePtr);
+	DESTRUCT_INTERFACE(LeaderboardsInterfacePtr);
+	DESTRUCT_INTERFACE(StoreInterfacePtr);
+	DESTRUCT_INTERFACE(ExternalUIInterfacePtr);
+	DESTRUCT_INTERFACE(VoiceInterfacePtr);
+	DESTRUCT_INTERFACE(TitleFileInterfacePtr);
+	DESTRUCT_INTERFACE(UserCloudInterfacePtr);
+
+#undef DESTRUCT_INTERFACE
+}
+
+bool FOnlineSubsystemEOSPlus::Shutdown()
+{
+	BaseOSS = nullptr;
+	EosOSS = nullptr;
+
+	return true;
+}
+
+IOnlineSessionPtr FOnlineSubsystemEOSPlus::GetSessionInterface() const
+{
+	return SessionInterfacePtr;
+}
+
+IOnlineFriendsPtr FOnlineSubsystemEOSPlus::GetFriendsInterface() const
+{
+	return UserInterfacePtr;
+}
+
+IOnlineGroupsPtr FOnlineSubsystemEOSPlus::GetGroupsInterface() const
+{
+	return nullptr;
+}
+
+IOnlinePartyPtr FOnlineSubsystemEOSPlus::GetPartyInterface() const
+{
+	return nullptr;
+}
+
+IOnlineSharedCloudPtr FOnlineSubsystemEOSPlus::GetSharedCloudInterface() const
+{
+	return nullptr;
+}
+
+IOnlineUserCloudPtr FOnlineSubsystemEOSPlus::GetUserCloudInterface() const
+{
+	return UserCloudInterfacePtr;
+}
+
+IOnlineEntitlementsPtr FOnlineSubsystemEOSPlus::GetEntitlementsInterface() const
+{
+	return nullptr;
+}
+
+IOnlineLeaderboardsPtr FOnlineSubsystemEOSPlus::GetLeaderboardsInterface() const
+{
+	return LeaderboardsInterfacePtr;
+}
+
+IOnlineVoicePtr FOnlineSubsystemEOSPlus::GetVoiceInterface() const
+{
+	return VoiceInterfacePtr;
+}
+
+IOnlineExternalUIPtr FOnlineSubsystemEOSPlus::GetExternalUIInterface() const
+{
+	return ExternalUIInterfacePtr;
+}
+
+IOnlineTimePtr FOnlineSubsystemEOSPlus::GetTimeInterface() const
+{
+	return nullptr;
+}
+
+IOnlineIdentityPtr FOnlineSubsystemEOSPlus::GetIdentityInterface() const
+{
+	return UserInterfacePtr;
+}
+
+IOnlineTitleFilePtr FOnlineSubsystemEOSPlus::GetTitleFileInterface() const
+{
+	return TitleFileInterfacePtr;
+}
+
+IOnlineStoreV2Ptr FOnlineSubsystemEOSPlus::GetStoreV2Interface() const
+{
+	return StoreInterfacePtr;
+}
+
+IOnlinePurchasePtr FOnlineSubsystemEOSPlus::GetPurchaseInterface() const
+{
+	return StoreInterfacePtr;
+}
+
+IOnlineEventsPtr FOnlineSubsystemEOSPlus::GetEventsInterface() const
+{
+	return StatsInterfacePtr;
+}
+
+IOnlineAchievementsPtr FOnlineSubsystemEOSPlus::GetAchievementsInterface() const
+{
+	return AchievementsInterfacePtr;
+}
+
+IOnlineSharingPtr FOnlineSubsystemEOSPlus::GetSharingInterface() const
+{
+	return nullptr;
+}
+
+IOnlineUserPtr FOnlineSubsystemEOSPlus::GetUserInterface() const
+{
+	return UserInterfacePtr;
+}
+
+IOnlineMessagePtr FOnlineSubsystemEOSPlus::GetMessageInterface() const
+{
+	return nullptr;
+}
+
+IOnlinePresencePtr FOnlineSubsystemEOSPlus::GetPresenceInterface() const
+{
+	return UserInterfacePtr;
+}
+
+IOnlineChatPtr FOnlineSubsystemEOSPlus::GetChatInterface() const
+{
+	return nullptr;
+}
+
+IOnlineStatsPtr FOnlineSubsystemEOSPlus::GetStatsInterface() const
+{
+	return StatsInterfacePtr;
+}
+
+IOnlineTurnBasedPtr FOnlineSubsystemEOSPlus::GetTurnBasedInterface() const
+{
+	return nullptr;
+}
+
+IOnlineTournamentPtr FOnlineSubsystemEOSPlus::GetTournamentInterface() const
+{
+	return nullptr;
+}
+
+bool FOnlineSubsystemEOSPlus::IsLocalPlayer(const FUniqueNetId& UniqueId) const
+{
+	if (!IsDedicated())
+	{
+		if (UserInterfacePtr.IsValid())
+		{
+			FUniqueNetIdEOSPlusPtr NetIdPlus = UserInterfacePtr->GetNetIdPlus(UniqueId.ToString());
+			if (NetIdPlus.IsValid())
+			{
+				for (int32 LocalUserNum = 0; LocalUserNum < MAX_LOCAL_PLAYERS; LocalUserNum++)
+				{
+					FUniqueNetIdPtr LocalUniqueId = UserInterfacePtr->GetUniquePlayerId(LocalUserNum);
+					if (LocalUniqueId.IsValid() && *NetIdPlus == *LocalUniqueId)
+					{
+						return true;
+					}
+				}
+			}
+		}
+	}
+
+	return false;
+}
Index: Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOSPlus/Private/OnlineStoreEOSPlus.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOSPlus/Private/OnlineStoreEOSPlus.cpp b/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOSPlus/Private/OnlineStoreEOSPlus.cpp
new file mode 100644
--- /dev/null	(date 1641575208000)
+++ b/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOSPlus/Private/OnlineStoreEOSPlus.cpp	(date 1641575208000)
@@ -0,0 +1,388 @@
+// Copyright Epic Games, Inc. All Rights Reserved.
+
+#include "OnlineStoreEOSPlus.h"
+#include "OnlineSubsystemEOSPlus.h"
+#include "OnlineError.h"
+
+FOnlineStoreEOSPlus::FOnlineStoreEOSPlus(FOnlineSubsystemEOSPlus* InSubsystem)
+	: EOSPlus(InSubsystem)
+{
+	BaseStoreInterface = EOSPlus->BaseOSS->GetStoreV2Interface();
+
+	BasePurchaseInterface = EOSPlus->BaseOSS->GetPurchaseInterface();
+}
+
+FOnlineStoreEOSPlus::~FOnlineStoreEOSPlus()
+{
+	if (BaseStoreInterface.IsValid())
+	{
+		BaseStoreInterface->ClearOnQueryForAvailablePurchasesCompleteDelegates(this);
+	}
+
+	if (BasePurchaseInterface.IsValid())
+	{
+		BasePurchaseInterface->ClearOnUnexpectedPurchaseReceiptDelegates(this);
+	}
+}
+
+FUniqueNetIdEOSPlusPtr FOnlineStoreEOSPlus::GetNetIdPlus(const FString& SourceId) const
+{
+	return EOSPlus->UserInterfacePtr->GetNetIdPlus(SourceId);
+}
+
+void FOnlineStoreEOSPlus::Initialize()
+{
+	if (BaseStoreInterface.IsValid())
+	{
+		BaseStoreInterface->AddOnQueryForAvailablePurchasesCompleteDelegate_Handle(FOnQueryForAvailablePurchasesCompleteDelegate::CreateThreadSafeSP(this, &FOnlineStoreEOSPlus::OnQueryForAvailablePurchasesCompleteBase));
+	}
+	else
+	{
+		UE_LOG_ONLINE(Warning, TEXT("[FOnlineStoreEOSPlus::Initialize] BaseStoreInterface delegates not bound. Base interface not valid"));
+	}
+
+	if (BasePurchaseInterface.IsValid())
+	{
+		BasePurchaseInterface->AddOnUnexpectedPurchaseReceiptDelegate_Handle(FOnUnexpectedPurchaseReceiptDelegate::CreateThreadSafeSP(this, &FOnlineStoreEOSPlus::OnUnexpectedPurchaseReceiptBase));
+	}
+	else
+	{
+		UE_LOG_ONLINE(Warning, TEXT("[FOnlineStoreEOSPlus::Initialize] BasePurchaseInterface delegates not bound. Base interface not valid"));
+	}
+}
+
+//~ Begin IOnlineStoreV2 Interface
+
+void FOnlineStoreEOSPlus::QueryCategories(const FUniqueNetId& UserId, const FOnQueryOnlineStoreCategoriesComplete& Delegate)
+{
+	FUniqueNetIdEOSPlusPtr NetIdPlus = GetNetIdPlus(UserId.ToString());
+	if (NetIdPlus.IsValid())
+	{
+		const bool bIsBaseNetIdValid = ensure(NetIdPlus->GetBaseNetId().IsValid());
+		const bool bIsBaseStoreInterfaceValid = BaseStoreInterface.IsValid();
+		if (bIsBaseNetIdValid && bIsBaseStoreInterfaceValid)
+		{
+			BaseStoreInterface->QueryCategories(*NetIdPlus->GetBaseNetId(), Delegate);
+			return;
+		}
+		else
+		{
+			UE_LOG_ONLINE(Warning, TEXT("[FOnlineStoreEOSPlus::QueryCategories] Unable to call method in base interface. IsBaseNetIdValid=%s IsBaseStoreInterfaceValid=%s."), *LexToString(bIsBaseNetIdValid), *LexToString(bIsBaseStoreInterfaceValid));
+		}
+	}
+	else
+	{
+		UE_LOG_ONLINE(Warning, TEXT("[FOnlineStoreEOSPlus::QueryCategories] Unable to call method in base interface. Unknown user (%s)"), *UserId.ToString());
+	}
+
+	EOSPlus->ExecuteNextTick([this, Delegate]() {
+		Delegate.ExecuteIfBound(false, TEXT("Unable to call method in base interface."));
+	});
+}
+
+void FOnlineStoreEOSPlus::GetCategories(TArray<FOnlineStoreCategory>& OutCategories) const
+{
+	if (BaseStoreInterface.IsValid())
+	{
+		BaseStoreInterface->GetCategories(OutCategories);
+	}
+	else
+	{
+		UE_LOG_ONLINE(Warning, TEXT("[FOnlineStoreEOSPlus::GetCategories] Unable to call method in base interface. Base interface not valid."));
+	}
+}
+
+void FOnlineStoreEOSPlus::QueryOffersByFilter(const FUniqueNetId& UserId, const FOnlineStoreFilter& Filter, const FOnQueryOnlineStoreOffersComplete& Delegate)
+{
+	FUniqueNetIdEOSPlusPtr NetIdPlus = GetNetIdPlus(UserId.ToString());
+	if (NetIdPlus.IsValid())
+	{
+		const bool bIsBaseNetIdValid = ensure(NetIdPlus->GetBaseNetId().IsValid());
+		const bool bIsBaseStoreInterfaceValid = BaseStoreInterface.IsValid();
+		if (bIsBaseNetIdValid && bIsBaseStoreInterfaceValid)
+		{
+			BaseStoreInterface->QueryOffersByFilter(*NetIdPlus->GetBaseNetId(), Filter, Delegate);
+			return;
+		}
+		else
+		{
+			UE_LOG_ONLINE(Warning, TEXT("[FOnlineStoreEOSPlus::QueryOffersByFilter] Unable to call method in base interface. IsBaseNetIdValid=%s IsBaseStoreInterfaceValid=%s."), *LexToString(bIsBaseNetIdValid), *LexToString(bIsBaseStoreInterfaceValid));
+		}
+	}
+	else
+	{
+		UE_LOG_ONLINE(Warning, TEXT("[FOnlineStoreEOSPlus::QueryOffersByFilter] Unable to call method in base interface. Unknown user (%s)"), *UserId.ToString());
+	}
+
+	EOSPlus->ExecuteNextTick([this, Delegate]() {
+		TArray<FUniqueOfferId> OfferIds;
+		Delegate.ExecuteIfBound(false, OfferIds, TEXT("Unable to call method in base interface."));
+	});
+}
+
+void FOnlineStoreEOSPlus::QueryOffersById(const FUniqueNetId& UserId, const TArray<FUniqueOfferId>& OfferIds, const FOnQueryOnlineStoreOffersComplete& Delegate)
+{
+	FUniqueNetIdEOSPlusPtr NetIdPlus = GetNetIdPlus(UserId.ToString());
+	if (NetIdPlus.IsValid())
+	{
+		const bool bIsBaseNetIdValid = ensure(NetIdPlus->GetBaseNetId().IsValid());
+		const bool bIsBaseStoreInterfaceValid = BaseStoreInterface.IsValid();
+		if (bIsBaseNetIdValid && bIsBaseStoreInterfaceValid)
+		{
+			BaseStoreInterface->QueryOffersById(*NetIdPlus->GetBaseNetId(), OfferIds, Delegate);
+			return;
+		}
+		else
+		{
+			UE_LOG_ONLINE(Warning, TEXT("[FOnlineStoreEOSPlus::QueryOffersById] Unable to call method in base interface. IsBaseNetIdValid=%s IsBaseStoreInterfaceValid=%s."), *LexToString(bIsBaseNetIdValid), *LexToString(bIsBaseStoreInterfaceValid));
+		}
+	}
+	else
+	{
+		UE_LOG_ONLINE(Warning, TEXT("[FOnlineStoreEOSPlus::QueryOffersById] Unable to call method in base interface. Unknown user (%s)"), *UserId.ToString());
+	}
+
+	EOSPlus->ExecuteNextTick([this, Delegate]() {
+		TArray<FUniqueOfferId> OfferIds;
+		Delegate.ExecuteIfBound(false, OfferIds, TEXT("Unable to call method in base interface."));
+	});
+}
+
+void FOnlineStoreEOSPlus::GetOffers(TArray<FOnlineStoreOfferRef>& OutOffers) const
+{
+	if (BaseStoreInterface.IsValid())
+	{
+		BaseStoreInterface->GetOffers(OutOffers);
+	}
+	else
+	{
+		UE_LOG_ONLINE(Warning, TEXT("[FOnlineStoreEOSPlus::GetOffers] Unable to call method in base interface. Base interface not valid."));
+	}
+}
+
+TSharedPtr<FOnlineStoreOffer> FOnlineStoreEOSPlus::GetOffer(const FUniqueOfferId& OfferId) const
+{
+	TSharedPtr<FOnlineStoreOffer> Result;
+	
+	if(BaseStoreInterface.IsValid())
+	{
+		Result = BaseStoreInterface->GetOffer(OfferId);
+	}
+	else
+	{
+		UE_LOG_ONLINE(Warning, TEXT("[FOnlineStoreEOSPlus::GetOffer] Unable to call method in base interface. Base interface not valid."));
+	}
+	
+	return Result;
+}
+
+void FOnlineStoreEOSPlus::OnQueryForAvailablePurchasesCompleteBase(bool bWasSuccessful)
+{
+	TriggerOnQueryForAvailablePurchasesCompleteDelegates(bWasSuccessful);
+}
+
+//~ End IOnlineStoreV2 Interface
+
+//~ Begin IOnlinePurchase Interface
+
+bool FOnlineStoreEOSPlus::IsAllowedToPurchase(const FUniqueNetId& UserId)
+{
+	bool bResult = false;
+
+	FUniqueNetIdEOSPlusPtr NetIdPlus = GetNetIdPlus(UserId.ToString());
+	if (NetIdPlus.IsValid())
+	{
+		const bool bIsBaseNetIdValid = ensure(NetIdPlus->GetBaseNetId().IsValid());
+		const bool bIsBasePurchaseInterfaceValid = BasePurchaseInterface.IsValid();
+		if (bIsBaseNetIdValid && bIsBasePurchaseInterfaceValid)
+		{
+			bResult = BasePurchaseInterface->IsAllowedToPurchase(*NetIdPlus->GetBaseNetId());
+		}
+		else
+		{
+			UE_LOG_ONLINE(Warning, TEXT("[FOnlineStoreEOSPlus::IsAllowedToPurchase] Unable to call method in base interface. IsBaseNetIdValid=%s IsBasePurchaseInterfaceValid=%s."), *LexToString(bIsBaseNetIdValid), *LexToString(bIsBasePurchaseInterfaceValid));
+		}
+	}
+	else
+	{
+		UE_LOG_ONLINE(Warning, TEXT("[FOnlineStoreEOSPlus::IsAllowedToPurchase] Unable to call method in base interface. Unknown user (%s)"), *UserId.ToString());
+	}
+
+	return bResult;
+}
+
+void FOnlineStoreEOSPlus::Checkout(const FUniqueNetId& UserId, const FPurchaseCheckoutRequest& CheckoutRequest, const FOnPurchaseCheckoutComplete& Delegate)
+{
+	EOnlineErrorResult ErrorResult = EOnlineErrorResult::Unknown;
+	FUniqueNetIdEOSPlusPtr NetIdPlus = GetNetIdPlus(UserId.ToString());
+	if (NetIdPlus.IsValid())
+	{
+		const bool bIsBaseNetIdValid = ensure(NetIdPlus->GetBaseNetId().IsValid());
+		const bool bIsBasePurchaseInterfaceValid = BasePurchaseInterface.IsValid();
+		if (bIsBaseNetIdValid && bIsBasePurchaseInterfaceValid)
+		{
+			BasePurchaseInterface->Checkout(*NetIdPlus->GetBaseNetId(), CheckoutRequest, Delegate);
+			return;
+		}
+		else
+		{
+			UE_LOG_ONLINE(Warning, TEXT("[FOnlineStoreEOSPlus::Checkout] Unable to call method in base interface. IsBaseNetIdValid=%s IsBasePurchaseInterfaceValid=%s."), *LexToString(bIsBaseNetIdValid), *LexToString(bIsBasePurchaseInterfaceValid));
+			ErrorResult = bIsBasePurchaseInterfaceValid ? EOnlineErrorResult::MissingInterface : EOnlineErrorResult::InvalidUser;
+		}
+	}
+	else
+	{
+		UE_LOG_ONLINE(Warning, TEXT("[FOnlineStoreEOSPlus::Checkout] Unable to call method in base interface. Unknown user (%s)"), *UserId.ToString());
+		ErrorResult = EOnlineErrorResult::InvalidUser;
+	}
+
+	EOSPlus->ExecuteNextTick([this, ErrorResult, Delegate]() {
+		TSharedRef<FPurchaseReceipt> Receipt;
+		Delegate.ExecuteIfBound(FOnlineError(ErrorResult), Receipt);
+	});
+}
+
+void FOnlineStoreEOSPlus::FinalizePurchase(const FUniqueNetId& UserId, const FString& ReceiptId)
+{
+	FUniqueNetIdEOSPlusPtr NetIdPlus = GetNetIdPlus(UserId.ToString());
+	if (NetIdPlus.IsValid())
+	{
+		const bool bIsBaseNetIdValid = ensure(NetIdPlus->GetBaseNetId().IsValid());
+		const bool bIsBasePurchaseInterfaceValid = BasePurchaseInterface.IsValid();
+		if (bIsBaseNetIdValid && bIsBasePurchaseInterfaceValid)
+		{
+			BasePurchaseInterface->FinalizePurchase(*NetIdPlus->GetBaseNetId(), ReceiptId);
+		}
+		else
+		{
+			UE_LOG_ONLINE(Warning, TEXT("[FOnlineStoreEOSPlus::FinalizePurchase] Unable to call method in base interface. IsBaseNetIdValid=%s IsBasePurchaseInterfaceValid=%s."), *LexToString(bIsBaseNetIdValid), *LexToString(bIsBasePurchaseInterfaceValid));
+		}
+	}
+	else
+	{
+		UE_LOG_ONLINE(Warning, TEXT("[FOnlineStoreEOSPlus::FinalizePurchase] Unable to call method in base interface. Unknown user (%s)"), *UserId.ToString());
+	}
+}
+
+void FOnlineStoreEOSPlus::RedeemCode(const FUniqueNetId& UserId, const FRedeemCodeRequest& RedeemCodeRequest, const FOnPurchaseRedeemCodeComplete& Delegate)
+{
+	EOnlineErrorResult ErrorResult = EOnlineErrorResult::Unknown;
+	FUniqueNetIdEOSPlusPtr NetIdPlus = GetNetIdPlus(UserId.ToString());
+	if (NetIdPlus.IsValid())
+	{
+		const bool bIsBaseNetIdValid = ensure(NetIdPlus->GetBaseNetId().IsValid());
+		const bool bIsBasePurchaseInterfaceValid = BasePurchaseInterface.IsValid();
+		if (bIsBaseNetIdValid && bIsBasePurchaseInterfaceValid)
+		{
+			BasePurchaseInterface->RedeemCode(*NetIdPlus->GetBaseNetId(), RedeemCodeRequest, Delegate);
+		}
+		else
+		{
+			UE_LOG_ONLINE(Warning, TEXT("[FOnlineStoreEOSPlus::RedeemCode] Unable to call method in base interface. IsBaseNetIdValid=%s IsBasePurchaseInterfaceValid=%s."), *LexToString(bIsBaseNetIdValid), *LexToString(bIsBasePurchaseInterfaceValid));
+			ErrorResult = bIsBasePurchaseInterfaceValid ? EOnlineErrorResult::MissingInterface : EOnlineErrorResult::InvalidUser;
+		}
+	}
+	else
+	{
+		UE_LOG_ONLINE(Warning, TEXT("[FOnlineStoreEOSPlus::RedeemCode] Unable to call method in base interface. Unknown user (%s)"), *UserId.ToString());
+		ErrorResult = EOnlineErrorResult::InvalidUser;
+	}
+
+	EOSPlus->ExecuteNextTick([this, ErrorResult, Delegate]() {
+		TSharedRef<FPurchaseReceipt> Receipt;
+		Delegate.ExecuteIfBound(FOnlineError(ErrorResult), Receipt);
+	});
+}
+
+void FOnlineStoreEOSPlus::QueryReceipts(const FUniqueNetId& UserId, bool bRestoreReceipts, const FOnQueryReceiptsComplete& Delegate)
+{
+	EOnlineErrorResult ErrorResult = EOnlineErrorResult::Unknown;
+	FUniqueNetIdEOSPlusPtr NetIdPlus = GetNetIdPlus(UserId.ToString());
+	if (NetIdPlus.IsValid())
+	{
+		const bool bIsBaseNetIdValid = ensure(NetIdPlus->GetBaseNetId().IsValid());
+		const bool bIsBasePurchaseInterfaceValid = BasePurchaseInterface.IsValid();
+		if (bIsBaseNetIdValid && bIsBasePurchaseInterfaceValid)
+		{
+			BasePurchaseInterface->QueryReceipts(*NetIdPlus->GetBaseNetId(), bRestoreReceipts, Delegate);
+		}
+		else
+		{
+			UE_LOG_ONLINE(Warning, TEXT("[FOnlineStoreEOSPlus::QueryReceipts] Unable to call method in base interface. IsBaseNetIdValid=%s IsBasePurchaseInterfaceValid=%s."), *LexToString(bIsBaseNetIdValid), *LexToString(bIsBasePurchaseInterfaceValid));
+			ErrorResult = bIsBasePurchaseInterfaceValid ? EOnlineErrorResult::MissingInterface : EOnlineErrorResult::InvalidUser;
+		}
+	}
+	else
+	{
+		UE_LOG_ONLINE(Warning, TEXT("[FOnlineStoreEOSPlus::QueryReceipts] Unable to call method in base interface. Unknown user (%s)"), *UserId.ToString());
+		ErrorResult = EOnlineErrorResult::InvalidUser;
+	}
+
+	EOSPlus->ExecuteNextTick([this, ErrorResult, Delegate]() {
+		Delegate.ExecuteIfBound(FOnlineError(ErrorResult));
+	});
+}
+
+void FOnlineStoreEOSPlus::GetReceipts(const FUniqueNetId& UserId, TArray<FPurchaseReceipt>& OutReceipts) const
+{
+	FUniqueNetIdEOSPlusPtr NetIdPlus = GetNetIdPlus(UserId.ToString());
+	if (NetIdPlus.IsValid())
+	{
+		const bool bIsBaseNetIdValid = ensure(NetIdPlus->GetBaseNetId().IsValid());
+		const bool bIsBasePurchaseInterfaceValid = BasePurchaseInterface.IsValid();
+		if (bIsBaseNetIdValid && bIsBasePurchaseInterfaceValid)
+		{
+			BasePurchaseInterface->GetReceipts(*NetIdPlus->GetBaseNetId(), OutReceipts);
+		}
+		else
+		{
+			UE_LOG_ONLINE(Warning, TEXT("[FOnlineStoreEOSPlus::GetReceipts] Unable to call method in base interface. IsBaseNetIdValid=%s IsBasePurchaseInterfaceValid=%s."), *LexToString(bIsBaseNetIdValid), *LexToString(bIsBasePurchaseInterfaceValid));
+		}
+	}
+	else
+	{
+		UE_LOG_ONLINE(Warning, TEXT("[FOnlineStoreEOSPlus::GetReceipts] Unable to call method in base interface. Unknown user (%s)"), *UserId.ToString());
+	}
+}
+
+void FOnlineStoreEOSPlus::FinalizeReceiptValidationInfo(const FUniqueNetId& UserId, FString& InReceiptValidationInfo, const FOnFinalizeReceiptValidationInfoComplete& Delegate)
+{
+	EOnlineErrorResult ErrorResult = EOnlineErrorResult::Unknown;
+	FUniqueNetIdEOSPlusPtr NetIdPlus = GetNetIdPlus(UserId.ToString());
+	if (NetIdPlus.IsValid())
+	{
+		const bool bIsBaseNetIdValid = ensure(NetIdPlus->GetBaseNetId().IsValid());
+		const bool bIsBasePurchaseInterfaceValid = BasePurchaseInterface.IsValid();
+		if (bIsBaseNetIdValid && bIsBasePurchaseInterfaceValid)
+		{
+			BasePurchaseInterface->FinalizeReceiptValidationInfo(*NetIdPlus->GetBaseNetId(), InReceiptValidationInfo, Delegate);
+		}
+		else
+		{
+			UE_LOG_ONLINE(Warning, TEXT("[FOnlineStoreEOSPlus::FinalizeReceiptValidationInfo] Unable to call method in base interface. IsBaseNetIdValid=%s IsBasePurchaseInterfaceValid=%s."), *LexToString(bIsBaseNetIdValid), *LexToString(bIsBasePurchaseInterfaceValid));
+			ErrorResult = bIsBasePurchaseInterfaceValid ? EOnlineErrorResult::MissingInterface : EOnlineErrorResult::InvalidUser;
+		}
+	}
+	else
+	{
+		UE_LOG_ONLINE(Warning, TEXT("[FOnlineStoreEOSPlus::FinalizeReceiptValidationInfo] Unable to call method in base interface. Unknown user (%s)"), *UserId.ToString());
+		ErrorResult = EOnlineErrorResult::InvalidUser;
+	}
+
+	EOSPlus->ExecuteNextTick([this, ErrorResult, Delegate]() {
+		Delegate.ExecuteIfBound(FOnlineError(ErrorResult), TEXT(""));
+	});
+}
+
+void FOnlineStoreEOSPlus::OnUnexpectedPurchaseReceiptBase(const FUniqueNetId& UserId)
+{
+	FUniqueNetIdEOSPlusPtr NetIdPlus = GetNetIdPlus(UserId.ToString());
+	if (!NetIdPlus.IsValid())
+	{
+		UE_LOG_ONLINE(Warning, TEXT("[FOnlineStoreEOSPlus::OnUnexpectedPurchaseReceiptBase] Unknown user (%s)"), *UserId.ToString());
+	}
+
+	TriggerOnUnexpectedPurchaseReceiptDelegates(*NetIdPlus);
+}
+
+//~ End IOnlinePurchase Interface
\ No newline at end of file
Index: Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOSPlus/Private/OnlineLeaderboardsEOSPlus.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOSPlus/Private/OnlineLeaderboardsEOSPlus.cpp b/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOSPlus/Private/OnlineLeaderboardsEOSPlus.cpp
new file mode 100644
--- /dev/null	(date 1641575208000)
+++ b/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOSPlus/Private/OnlineLeaderboardsEOSPlus.cpp	(date 1641575208000)
@@ -0,0 +1,239 @@
+// Copyright Epic Games, Inc. All Rights Reserved.
+
+#include "OnlineLeaderboardsEOSPlus.h"
+#include "OnlineSubsystem.h"
+#include "OnlineSubsystemEOSPlus.h"
+#include "EOSSettings.h"
+
+FOnlineLeaderboardsEOSPlus::FOnlineLeaderboardsEOSPlus(FOnlineSubsystemEOSPlus* InSubsystem)
+	: EOSPlus(InSubsystem)
+{
+	BaseLeaderboardsInterface = EOSPlus->BaseOSS->GetLeaderboardsInterface();
+}
+
+FOnlineLeaderboardsEOSPlus::~FOnlineLeaderboardsEOSPlus()
+{
+	if (BaseLeaderboardsInterface.IsValid())
+	{
+		BaseLeaderboardsInterface->ClearOnLeaderboardReadCompleteDelegates(this);
+		BaseLeaderboardsInterface->ClearOnLeaderboardFlushCompleteDelegates(this);
+	}
+}
+
+FUniqueNetIdEOSPlusPtr FOnlineLeaderboardsEOSPlus::GetNetIdPlus(const FString& SourceId)
+{
+	return EOSPlus->UserInterfacePtr->GetNetIdPlus(SourceId);
+}
+
+void FOnlineLeaderboardsEOSPlus::Initialize()
+{
+	if (BaseLeaderboardsInterface.IsValid())
+	{
+		BaseLeaderboardsInterface->AddOnLeaderboardReadCompleteDelegate_Handle(FOnLeaderboardReadCompleteDelegate::CreateThreadSafeSP(this, &FOnlineLeaderboardsEOSPlus::OnLeaderboardReadComplete));
+		BaseLeaderboardsInterface->AddOnLeaderboardFlushCompleteDelegate_Handle(FOnLeaderboardFlushCompleteDelegate::CreateThreadSafeSP(this, &FOnlineLeaderboardsEOSPlus::OnLeaderboardFlushComplete));
+	}
+}
+
+// IOnlineLeaderboards Interface
+
+bool FOnlineLeaderboardsEOSPlus::ReadLeaderboards(const TArray< FUniqueNetIdRef >& Players, FOnlineLeaderboardReadRef& ReadObject)
+{
+	if (BaseLeaderboardsInterface.IsValid())
+	{
+		bool bArePlayerIdsValid = true;
+		TArray< FUniqueNetIdRef > BasePlayerIds;
+		for (const FUniqueNetIdRef& Player : Players)
+		{
+			FUniqueNetIdEOSPlusPtr NetIdPlus = GetNetIdPlus(Player->ToString());
+			if (NetIdPlus.IsValid())
+			{
+				const bool bIsBaseNetIdValid = ensure(NetIdPlus->GetBaseNetId().IsValid());
+				if (bIsBaseNetIdValid)
+				{
+					BasePlayerIds.Add(NetIdPlus->GetBaseNetId().ToSharedRef());
+				}
+				else
+				{
+					UE_LOG_ONLINE(Warning, TEXT("[FOnlineLeaderboardsEOSPlus::ReadLeaderboards] Unable to call method in base interface. Base id not valid for user (%s)."), *Player->ToDebugString());
+					bArePlayerIdsValid = false;
+					break;
+				}
+			}
+			else
+			{
+				UE_LOG_ONLINE(Warning, TEXT("[FOnlineLeaderboardsEOSPlus::ReadLeaderboards] Unable to call method in base interface. User not found (%s)."), *Player->ToDebugString());
+				bArePlayerIdsValid = false;
+				break;
+			}
+		}
+
+		if (bArePlayerIdsValid)
+		{
+			return BaseLeaderboardsInterface->ReadLeaderboards(BasePlayerIds, ReadObject);
+		}
+	}
+	else
+	{
+		UE_LOG_ONLINE(Warning, TEXT("[FOnlineLeaderboardsEOSPlus::ReadLeaderboards] Unable to call method in base interface. Base interface not valid."));
+	}
+
+	EOSPlus->ExecuteNextTick([this]() {
+		TriggerOnLeaderboardReadCompleteDelegates(false);
+	});
+
+	return true;
+}
+
+bool FOnlineLeaderboardsEOSPlus::ReadLeaderboardsForFriends(int32 LocalUserNum, FOnlineLeaderboardReadRef& ReadObject)
+{
+	bool bResult = true;
+
+	if (BaseLeaderboardsInterface.IsValid())
+	{
+		bResult = BaseLeaderboardsInterface->ReadLeaderboardsForFriends(LocalUserNum, ReadObject);
+	}
+	else
+	{
+		UE_LOG_ONLINE(Warning, TEXT("[FOnlineLeaderboardsEOSPlus::ReadLeaderboardsForFriends] Unable to call method in base interface. Base interface not valid."));
+
+		EOSPlus->ExecuteNextTick([this]() {
+			TriggerOnLeaderboardReadCompleteDelegates(false);
+		});
+	}
+
+	return bResult;
+}
+
+bool FOnlineLeaderboardsEOSPlus::ReadLeaderboardsAroundRank(int32 Rank, uint32 Range, FOnlineLeaderboardReadRef& ReadObject)
+{
+	bool bResult = true;
+
+	if (BaseLeaderboardsInterface.IsValid())
+	{
+		bResult = BaseLeaderboardsInterface->ReadLeaderboardsAroundRank(Rank, Range, ReadObject);
+	}
+	else
+	{
+		UE_LOG_ONLINE(Warning, TEXT("[FOnlineLeaderboardsEOSPlus::ReadLeaderboardsAroundRank] Unable to call method in base interface. Base interface not valid."));
+
+		EOSPlus->ExecuteNextTick([this]() {
+			TriggerOnLeaderboardReadCompleteDelegates(false);
+		});
+	}
+
+	return bResult;
+}
+
+bool FOnlineLeaderboardsEOSPlus::ReadLeaderboardsAroundUser(FUniqueNetIdRef Player, uint32 Range, FOnlineLeaderboardReadRef& ReadObject)
+{
+	FUniqueNetIdEOSPlusPtr NetIdPlus = GetNetIdPlus(Player->ToString());
+	if (NetIdPlus.IsValid())
+	{
+		const bool bIsBaseNetIdValid = ensure(NetIdPlus->GetBaseNetId().IsValid());
+		const bool bIsBaseLeaderboardsInterfaceValid = BaseLeaderboardsInterface.IsValid();
+		if (bIsBaseNetIdValid && bIsBaseLeaderboardsInterfaceValid)
+		{
+			return BaseLeaderboardsInterface->ReadLeaderboardsAroundUser(NetIdPlus->GetBaseNetId().ToSharedRef(), Range, ReadObject);
+		}
+		else
+		{
+			UE_LOG_ONLINE(Warning, TEXT("[FOnlineStoreEOSPlus::ReadLeaderboardsAroundUser] Unable to call method in base interface. IsBaseNetIdValid=%s IsBaseLeaderboardsInterfaceValid=%s."), *LexToString(bIsBaseNetIdValid), *LexToString(bIsBaseLeaderboardsInterfaceValid));
+		}
+	}
+	else
+	{
+		UE_LOG_ONLINE(Warning, TEXT("[FOnlineStoreEOSPlus::ReadLeaderboardsAroundUser] Unable to call method in base interface. Unknown user (%s)"), *Player->ToDebugString());
+	}
+
+	EOSPlus->ExecuteNextTick([this]() {
+		TriggerOnLeaderboardReadCompleteDelegates(false);
+	});
+
+	return true;
+}
+
+void FOnlineLeaderboardsEOSPlus::FreeStats(FOnlineLeaderboardRead& ReadObject)
+{
+	if (BaseLeaderboardsInterface.IsValid())
+	{
+		BaseLeaderboardsInterface->FreeStats(ReadObject);
+	}
+	else
+	{
+		UE_LOG_ONLINE(Warning, TEXT("[FOnlineLeaderboardsEOSPlus::FreeStats] Unable to call method in base interface. Base interface not valid."));
+	}
+}
+
+bool FOnlineLeaderboardsEOSPlus::WriteLeaderboards(const FName& SessionName, const FUniqueNetId& Player, FOnlineLeaderboardWrite& WriteObject)
+{
+	bool bResult = false;
+
+	FUniqueNetIdEOSPlusPtr NetIdPlus = GetNetIdPlus(Player.ToString());
+	if (NetIdPlus.IsValid())
+	{
+		const bool bIsBaseNetIdValid = ensure(NetIdPlus->GetBaseNetId().IsValid());
+		const bool bIsBaseLeaderboardsInterfaceValid = BaseLeaderboardsInterface.IsValid();
+		if (bIsBaseNetIdValid && bIsBaseLeaderboardsInterfaceValid)
+		{
+			bResult = BaseLeaderboardsInterface->WriteLeaderboards(SessionName, *NetIdPlus->GetBaseNetId(), WriteObject);
+		}
+		else
+		{
+			UE_LOG_ONLINE(Warning, TEXT("[FOnlineStoreEOSPlus::WriteLeaderboards] Unable to call method in base interface. IsBaseNetIdValid=%s IsBaseLeaderboardsInterfaceValid=%s."), *LexToString(bIsBaseNetIdValid), *LexToString(bIsBaseLeaderboardsInterfaceValid));
+		}
+	}
+	else
+	{
+		UE_LOG_ONLINE(Warning, TEXT("[FOnlineStoreEOSPlus::WriteLeaderboards] Unable to call method in base interface. Unknown user (%s)"), *Player.ToString());
+	}
+
+	return bResult;
+}
+
+bool FOnlineLeaderboardsEOSPlus::FlushLeaderboards(const FName& SessionName)
+{
+	bool bResult = true;
+
+	if (BaseLeaderboardsInterface.IsValid())
+	{
+		bResult = BaseLeaderboardsInterface->FlushLeaderboards(SessionName);
+	}
+	else
+	{
+		UE_LOG_ONLINE(Warning, TEXT("[FOnlineLeaderboardsEOSPlus::FlushLeaderboards] Unable to call method in base interface. Base interface not valid."));
+
+		EOSPlus->ExecuteNextTick([this, SessionName]() {
+			TriggerOnLeaderboardFlushCompleteDelegates(SessionName, false);
+		});
+	}
+
+	return bResult;
+}
+
+bool FOnlineLeaderboardsEOSPlus::WriteOnlinePlayerRatings(const FName& SessionName, int32 LeaderboardId, const TArray<FOnlinePlayerScore>& PlayerScores)
+{
+	bool bResult = false;
+
+	if (BaseLeaderboardsInterface.IsValid())
+	{
+		bResult = BaseLeaderboardsInterface->WriteOnlinePlayerRatings(SessionName, LeaderboardId, PlayerScores);
+	}
+	else
+	{
+		UE_LOG_ONLINE(Warning, TEXT("[FOnlineLeaderboardsEOSPlus::WriteOnlinePlayerRatings] Unable to call method in base interface. Base interface not valid."));
+	}
+
+	return bResult;
+}
+
+void FOnlineLeaderboardsEOSPlus::OnLeaderboardReadComplete(bool bWasSuccessful)
+{
+	TriggerOnLeaderboardReadCompleteDelegates(bWasSuccessful);
+}
+
+void FOnlineLeaderboardsEOSPlus::OnLeaderboardFlushComplete(const FName SessionName, bool bWasSuccessful)
+{
+	TriggerOnLeaderboardFlushCompleteDelegates(SessionName, bWasSuccessful);
+}
+
+// ~IOnlineLeaderboards Interface
\ No newline at end of file
Index: Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOSPlus/Private/OnlineSessionEOSPlus.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOSPlus/Private/OnlineSessionEOSPlus.cpp b/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOSPlus/Private/OnlineSessionEOSPlus.cpp
new file mode 100644
--- /dev/null	(date 1641576012000)
+++ b/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOSPlus/Private/OnlineSessionEOSPlus.cpp	(date 1641576012000)
@@ -0,0 +1,930 @@
+// Copyright Epic Games, Inc. All Rights Reserved.
+
+#include "OnlineSessionEOSPlus.h"
+#include "Misc/Guid.h"
+#include "OnlineSubsystem.h"
+#include "OnlineSubsystemEOSPlus.h"
+#include "OnlineUserEOSPlus.h"
+#include "EOSSettings.h"
+
+FOnlineSessionEOSPlus::FOnlineSessionEOSPlus(FOnlineSubsystemEOSPlus* InSubsystem)
+	: EOSPlus(InSubsystem)
+	, bUseEOSSessions(false)
+{
+	BaseSessionInterface = EOSPlus->BaseOSS->GetSessionInterface();
+	EOSSessionInterface = EOSPlus->EosOSS->GetSessionInterface();
+	check(BaseSessionInterface.IsValid() && EOSSessionInterface.IsValid());
+
+	bUseEOSSessions = UEOSSettings::GetSettings().bUseEOSSessions;
+
+	BaseSessionInterface->AddOnSessionUserInviteAcceptedDelegate_Handle(FOnSessionUserInviteAcceptedDelegate::CreateRaw(this, &FOnlineSessionEOSPlus::OnSessionUserInviteAcceptedBase));
+	BaseSessionInterface->AddOnSessionInviteReceivedDelegate_Handle(FOnSessionInviteReceivedDelegate::CreateRaw(this, &FOnlineSessionEOSPlus::OnSessionInviteReceivedBase));
+	BaseSessionInterface->AddOnCreateSessionCompleteDelegate_Handle(FOnCreateSessionCompleteDelegate::CreateRaw(this, &FOnlineSessionEOSPlus::OnCreateSessionComplete));
+
+	IOnlineSessionPtr PrimaryInterface = BaseSessionInterface;
+	if (bUseEOSSessions)
+	{
+		PrimaryInterface = EOSSessionInterface;
+
+		EOSSessionInterface->AddOnSessionUserInviteAcceptedDelegate_Handle(FOnSessionUserInviteAcceptedDelegate::CreateRaw(this, &FOnlineSessionEOSPlus::OnSessionUserInviteAcceptedEOS));
+		EOSSessionInterface->AddOnSessionInviteReceivedDelegate_Handle(FOnSessionInviteReceivedDelegate::CreateRaw(this, &FOnlineSessionEOSPlus::OnSessionInviteReceivedEOS));
+	}
+
+	// All of these depend upon which is our primary session interface
+	PrimaryInterface->AddOnSessionFailureDelegate_Handle(FOnSessionFailureDelegate::CreateRaw(this, &FOnlineSessionEOSPlus::OnSessionFailure));
+	PrimaryInterface->AddOnStartSessionCompleteDelegate_Handle(FOnUpdateSessionCompleteDelegate::CreateRaw(this, &FOnlineSessionEOSPlus::OnStartSessionComplete));
+	PrimaryInterface->AddOnUpdateSessionCompleteDelegate_Handle(FOnUpdateSessionCompleteDelegate::CreateRaw(this, &FOnlineSessionEOSPlus::OnUpdateSessionComplete));
+	PrimaryInterface->AddOnEndSessionCompleteDelegate_Handle(FOnEndSessionCompleteDelegate::CreateRaw(this, &FOnlineSessionEOSPlus::OnEndSessionComplete));
+	PrimaryInterface->AddOnFindSessionsCompleteDelegate_Handle(FOnFindSessionsCompleteDelegate::CreateRaw(this, &FOnlineSessionEOSPlus::OnFindSessionsComplete));
+	PrimaryInterface->AddOnCancelFindSessionsCompleteDelegate_Handle(FOnCancelFindSessionsCompleteDelegate::CreateRaw(this, &FOnlineSessionEOSPlus::OnCancelFindSessionsComplete));
+	PrimaryInterface->AddOnPingSearchResultsCompleteDelegate_Handle(FOnPingSearchResultsCompleteDelegate::CreateRaw(this, &FOnlineSessionEOSPlus::OnPingSearchResultsComplete));
+	PrimaryInterface->AddOnJoinSessionCompleteDelegate_Handle(FOnJoinSessionCompleteDelegate::CreateRaw(this, &FOnlineSessionEOSPlus::OnJoinSessionComplete));
+
+	for (int32 LocalPlayerNum = 0; LocalPlayerNum < MAX_LOCAL_PLAYERS; LocalPlayerNum++)
+	{
+		PrimaryInterface->AddOnFindFriendSessionCompleteDelegate_Handle(LocalPlayerNum, FOnFindFriendSessionCompleteDelegate::CreateRaw(this, &FOnlineSessionEOSPlus::OnFindFriendSessionComplete));
+	}
+}
+
+FOnlineSessionEOSPlus::~FOnlineSessionEOSPlus()
+{
+	BaseSessionInterface->ClearOnSessionUserInviteAcceptedDelegates(this);
+	EOSSessionInterface->ClearOnSessionUserInviteAcceptedDelegates(this);
+	BaseSessionInterface->ClearOnSessionInviteReceivedDelegates(this);
+	EOSSessionInterface->ClearOnSessionInviteReceivedDelegates(this);
+	BaseSessionInterface->ClearOnSessionFailureDelegates(this);
+	EOSSessionInterface->ClearOnSessionFailureDelegates(this);
+
+	BaseSessionInterface->ClearOnCreateSessionCompleteDelegates(this);
+	BaseSessionInterface->ClearOnSessionFailureDelegates(this);
+	BaseSessionInterface->ClearOnStartSessionCompleteDelegates(this);
+	BaseSessionInterface->ClearOnUpdateSessionCompleteDelegates(this);
+	BaseSessionInterface->ClearOnEndSessionCompleteDelegates(this);
+	BaseSessionInterface->ClearOnFindSessionsCompleteDelegates(this);
+	BaseSessionInterface->ClearOnCancelFindSessionsCompleteDelegates(this);
+	BaseSessionInterface->ClearOnPingSearchResultsCompleteDelegates(this);
+	BaseSessionInterface->ClearOnJoinSessionCompleteDelegates(this);
+
+	EOSSessionInterface->ClearOnCreateSessionCompleteDelegates(this);
+	EOSSessionInterface->ClearOnSessionFailureDelegates(this);
+	EOSSessionInterface->ClearOnStartSessionCompleteDelegates(this);
+	EOSSessionInterface->ClearOnUpdateSessionCompleteDelegates(this);
+	EOSSessionInterface->ClearOnEndSessionCompleteDelegates(this);
+	EOSSessionInterface->ClearOnFindSessionsCompleteDelegates(this);
+	EOSSessionInterface->ClearOnCancelFindSessionsCompleteDelegates(this);
+	EOSSessionInterface->ClearOnPingSearchResultsCompleteDelegates(this);
+	EOSSessionInterface->ClearOnJoinSessionCompleteDelegates(this);
+
+	for (int32 LocalPlayerNum = 0; LocalPlayerNum < MAX_LOCAL_PLAYERS; LocalPlayerNum++)
+	{
+		BaseSessionInterface->ClearOnFindFriendSessionCompleteDelegates(LocalPlayerNum, this);
+		EOSSessionInterface->ClearOnFindFriendSessionCompleteDelegates(LocalPlayerNum, this);
+	}
+}
+
+FUniqueNetIdEOSPlusPtr FOnlineSessionEOSPlus::GetNetIdPlus(const FString& SourceId)
+{
+	return EOSPlus->UserInterfacePtr->GetNetIdPlus(SourceId);
+}
+
+FUniqueNetIdPtr FOnlineSessionEOSPlus::GetBaseNetId(const FString& SourceId)
+{
+	return EOSPlus->UserInterfacePtr->GetBaseNetId(SourceId);
+}
+
+FUniqueNetIdPtr FOnlineSessionEOSPlus::GetEOSNetId(const FString& SourceId)
+{
+	return EOSPlus->UserInterfacePtr->GetEOSNetId(SourceId);
+}
+
+TArray<FUniqueNetIdRef> FOnlineSessionEOSPlus::GetBaseNetIds(const TArray<FUniqueNetIdRef>& Players)
+{
+	TArray<FUniqueNetIdRef> BaseIds;
+	for (FUniqueNetIdRef SourceId : Players)
+	{
+		FUniqueNetIdPtr BaseId = GetBaseNetId(SourceId->ToString());
+		if (BaseId.IsValid())
+		{
+			BaseIds.Add(BaseId.ToSharedRef());
+		}
+	}
+	return BaseIds;
+}
+
+TArray<FUniqueNetIdRef> FOnlineSessionEOSPlus::GetEOSNetIds(const TArray<FUniqueNetIdRef>& Players)
+{
+	TArray<FUniqueNetIdRef> EOSIds;
+	for (FUniqueNetIdRef SourceId : Players)
+	{
+		FUniqueNetIdPtr EOSId = GetEOSNetId(SourceId->ToString());
+		if (EOSId.IsValid())
+		{
+			EOSIds.Add(EOSId.ToSharedRef());
+		}
+	}
+	return EOSIds;
+}
+
+void FOnlineSessionEOSPlus::OnSessionUserInviteAcceptedBase(const bool bWasSuccessful, const int32 ControllerId, FUniqueNetIdPtr UserId, const FOnlineSessionSearchResult& InviteResult)
+{
+	if (!bWasSuccessful || !UserId.IsValid() || !InviteResult.IsValid())
+	{
+		return;
+	}
+
+	if (bUseEOSSessions)
+	{
+		FString SessionIdStr;
+		InviteResult.Session.SessionSettings.Get(TEXT("EOSSessionId"), SessionIdStr);
+		if (SessionIdStr.IsEmpty())
+		{
+			UE_LOG_ONLINE(Error, TEXT("Failed to get EOS session id from base session"));
+			return;
+		}
+		FUniqueNetIdPtr SessionId = EOSSessionInterface->CreateSessionIdFromString(SessionIdStr);
+		if (!SessionId.IsValid())
+		{
+			UE_LOG_ONLINE(Error, TEXT("Failed to get EOS session unique id from EOS session interface"));
+			return;
+		}
+		FUniqueNetIdPtr EOSUserId = EOSPlus->EosOSS->GetIdentityInterface()->GetUniquePlayerId(ControllerId);
+		if (!EOSUserId.IsValid())
+		{
+			UE_LOG_ONLINE(Error, TEXT("Failed to get EOS user id (%d)"), ControllerId);
+			return;
+		}
+		// Do a search for the EOS session
+		EOSSessionInterface->FindSessionById(*EOSUserId, *SessionId, *FUniqueNetIdString::EmptyId(),
+			FOnSingleSessionResultCompleteDelegate::CreateLambda([this, UserId](int32 LocalUserNum, bool bWasSuccessful, const FOnlineSessionSearchResult& EOSResult)
+			{
+				FUniqueNetIdPtr PlusUserId = EOSPlus->UserInterfacePtr->GetUniquePlayerId(LocalUserNum);
+				// Now that we have the proper session trigger the invite
+				TriggerOnSessionUserInviteAcceptedDelegates(bWasSuccessful, LocalUserNum, PlusUserId, EOSResult);
+			}));
+	}
+	else
+	{
+		TriggerOnSessionUserInviteAcceptedDelegates(bWasSuccessful, ControllerId, GetNetIdPlus(UserId->ToString()), InviteResult);
+	}
+}
+
+void FOnlineSessionEOSPlus::OnSessionUserInviteAcceptedEOS(const bool bWasSuccessful, const int32 ControllerId, FUniqueNetIdPtr UserId, const FOnlineSessionSearchResult& InviteResult)
+{
+	if (!bWasSuccessful || !UserId.IsValid() || !InviteResult.IsSessionInfoValid())
+	{
+		return;
+	}
+
+	// We can just forward this
+	TriggerOnSessionUserInviteAcceptedDelegates(bWasSuccessful, ControllerId, GetNetIdPlus(UserId->ToString()), InviteResult);
+}
+
+void FOnlineSessionEOSPlus::OnSessionInviteReceivedBase(const FUniqueNetId& UserId, const FUniqueNetId& FromId, const FString& AppId, const FOnlineSessionSearchResult& InviteResult)
+{
+	FUniqueNetIdEOSPlusPtr Id = GetNetIdPlus(UserId.ToString());
+	FUniqueNetIdEOSPlusPtr FriendId = GetNetIdPlus(FromId.ToString());
+	if (!Id.IsValid() || !Id->GetEOSNetId().IsValid() || !FriendId.IsValid() || !InviteResult.IsValid())
+	{
+		return;
+	}
+
+	if (bUseEOSSessions)
+	{
+		FString SessionIdStr;
+		InviteResult.Session.SessionSettings.Get(TEXT("EOSSessionId"), SessionIdStr);
+		if (SessionIdStr.IsEmpty())
+		{
+			UE_LOG_ONLINE(Error, TEXT("Failed to get EOS session id from base session"));
+			return;
+		}
+		FUniqueNetIdPtr SessionId = EOSSessionInterface->CreateSessionIdFromString(SessionIdStr);
+		if (!SessionId.IsValid())
+		{
+			UE_LOG_ONLINE(Error, TEXT("Failed to get EOS session unique id from EOS session interface"));
+			return;
+		}
+		// Do a search for the EOS session
+		EOSSessionInterface->FindSessionById(*Id->GetEOSNetId(), *SessionId, *FUniqueNetIdString::EmptyId(),
+			FOnSingleSessionResultCompleteDelegate::CreateLambda([this, Id, FriendId, AppStr = FString(AppId)](int32 LocalUserNum, bool bWasSuccessful, const FOnlineSessionSearchResult& EOSResult)
+			{
+				// Now that we have the proper session trigger the invite
+				TriggerOnSessionInviteReceivedDelegates(*Id, *FriendId, AppStr, EOSResult);
+			}));
+	}
+	else
+	{
+		TriggerOnSessionInviteReceivedDelegates(*Id, *FriendId, AppId, InviteResult);
+	}
+}
+
+void FOnlineSessionEOSPlus::OnSessionInviteReceivedEOS(const FUniqueNetId& UserId, const FUniqueNetId& FromId, const FString& AppId, const FOnlineSessionSearchResult& InviteResult)
+{
+	FUniqueNetIdPtr Id = GetNetIdPlus(UserId.ToString());
+	FUniqueNetIdPtr FriendId = GetNetIdPlus(FromId.ToString());
+	if (!Id.IsValid() || !FriendId.IsValid() || !InviteResult.IsValid())
+	{
+		return;
+	}
+
+	// We can just forward this
+	TriggerOnSessionInviteReceivedDelegates(*Id, *FriendId, AppId, InviteResult);
+}
+
+void FOnlineSessionEOSPlus::OnSessionFailure(const FUniqueNetId& Player, ESessionFailure::Type Failure)
+{
+	FUniqueNetIdEOSPlusPtr PlusId = GetNetIdPlus(Player.ToString());
+	if (!PlusId.IsValid())
+	{
+		return;
+	}
+	TriggerOnSessionFailureDelegates(*PlusId, Failure);
+}
+
+void FOnlineSessionEOSPlus::OnCreateSessionComplete(FName SessionName, bool bWasSuccessful)
+{
+	// If this gets called after a successful base interface session creation, we'll set the LobbyId as a custom parameter and update the session
+	FNamedOnlineSession* BaseSession = BaseSessionInterface->GetNamedSession(SessionName);
+	if (BaseSession != nullptr)
+	{
+		FNamedOnlineSession* EOSSession = EOSSessionInterface->GetNamedSession(SessionName);
+
+		BaseSession->SessionSettings.Set(TEXT("EOSSessionId"), EOSSession->SessionInfo->GetSessionId().ToString(), EOnlineDataAdvertisementType::ViaOnlineService);
+		BaseSessionInterface->UpdateSession(SessionName, BaseSession->SessionSettings, true);
+	}
+
+	TriggerOnCreateSessionCompleteDelegates(SessionName, bWasSuccessful);
+}
+
+void FOnlineSessionEOSPlus::OnStartSessionComplete(FName SessionName, bool bWasSuccessful)
+{
+	TriggerOnStartSessionCompleteDelegates(SessionName, bWasSuccessful);
+}
+
+void FOnlineSessionEOSPlus::OnUpdateSessionComplete(FName SessionName, bool bWasSuccessful)
+{
+	TriggerOnUpdateSessionCompleteDelegates(SessionName, bWasSuccessful);
+}
+
+void FOnlineSessionEOSPlus::OnEndSessionComplete(FName SessionName, bool bWasSuccessful)
+{
+	TriggerOnEndSessionCompleteDelegates(SessionName, bWasSuccessful);
+}
+
+void FOnlineSessionEOSPlus::OnFindSessionsComplete(bool bWasSuccessful)
+{
+	TriggerOnFindSessionsCompleteDelegates(bWasSuccessful);
+}
+
+void FOnlineSessionEOSPlus::OnCancelFindSessionsComplete(bool bWasSuccessful)
+{
+	TriggerOnCancelFindSessionsCompleteDelegates(bWasSuccessful);
+}
+
+void FOnlineSessionEOSPlus::OnPingSearchResultsComplete(bool bWasSuccessful)
+{
+	TriggerOnPingSearchResultsCompleteDelegates(bWasSuccessful);
+}
+
+void FOnlineSessionEOSPlus::OnJoinSessionComplete(FName SessionName, EOnJoinSessionCompleteResult::Type JoinResult)
+{
+	TriggerOnJoinSessionCompleteDelegates(SessionName, JoinResult);
+}
+
+void FOnlineSessionEOSPlus::OnFindFriendSessionComplete(int32 LocalPlayerNum, bool bWasSuccessful, const TArray<FOnlineSessionSearchResult>& Results)
+{
+	TriggerOnFindFriendSessionCompleteDelegates(LocalPlayerNum, bWasSuccessful, Results);
+}
+
+FNamedOnlineSession* FOnlineSessionEOSPlus::AddNamedSession(FName SessionName, const FOnlineSessionSettings& SessionSettings)
+{
+	FScopeLock ScopeLock(&SessionLock);
+	return new(Sessions) FNamedOnlineSession(SessionName, SessionSettings);
+}
+
+FNamedOnlineSession* FOnlineSessionEOSPlus::AddNamedSession(FName SessionName, const FOnlineSession& Session)
+{
+	FScopeLock ScopeLock(&SessionLock);
+	return new(Sessions) FNamedOnlineSession(SessionName, Session);
+}
+
+bool FOnlineSessionEOSPlus::CreateSession(int32 HostingPlayerNum, FName SessionName, const FOnlineSessionSettings& NewSessionSettings)
+{
+	// If EOS is enabled, create there and mirror on platform and include EOS session info
+	if (bUseEOSSessions)
+	{
+		OnCreateSessionCompleteDelegateHandleEOS = EOSSessionInterface->AddOnCreateSessionCompleteDelegate_Handle(
+			FOnCreateSessionCompleteDelegate::CreateLambda([this, HostingPlayerNum](FName SessionName, bool bWasSuccessful)
+		{
+#if CREATE_MIRROR_PLATFORM_SESSION
+			if (bWasSuccessful)
+			{
+				// We need the session settings & session id from EOS
+				FOnlineSessionSettings* Settings = EOSSessionInterface->GetSessionSettings(SessionName);
+				if (Settings != nullptr)
+				{
+					// Mirror in the base interface
+					BaseSessionInterface->CreateSession(HostingPlayerNum, SessionName, *Settings);
+
+					EOSSessionInterface->ClearOnCreateSessionCompleteDelegate_Handle(OnCreateSessionCompleteDelegateHandleEOS);
+
+					return;
+				}
+				bWasSuccessful = false;
+			}
+#endif
+
+			OnCreateSessionComplete(SessionName, bWasSuccessful);
+
+			EOSSessionInterface->ClearOnCreateSessionCompleteDelegate_Handle(OnCreateSessionCompleteDelegateHandleEOS);
+		}));
+		return EOSSessionInterface->CreateSession(HostingPlayerNum, SessionName, NewSessionSettings);
+	}
+	// Otherwise create the platform version
+	return BaseSessionInterface->CreateSession(HostingPlayerNum, SessionName, NewSessionSettings);;
+}
+
+bool FOnlineSessionEOSPlus::CreateSession(const FUniqueNetId& HostingPlayerId, FName SessionName, const FOnlineSessionSettings& NewSessionSettings)
+{
+	FString HostingPlayerIdStr = HostingPlayerId.ToString();
+	FUniqueNetIdEOSPlusPtr Id = GetNetIdPlus(HostingPlayerIdStr);
+	if (!Id.IsValid() || !Id->GetEOSNetId().IsValid())
+	{
+		OnCreateSessionComplete(SessionName, false);
+		return false;
+	}
+
+	// If EOS is enabled, create there and mirror on platform and include EOS session info
+	if (bUseEOSSessions)
+	{
+		OnCreateSessionCompleteDelegateHandleEOS = EOSSessionInterface->AddOnCreateSessionCompleteDelegate_Handle(
+			FOnCreateSessionCompleteDelegate::CreateLambda([this, HostingPlayerIdStr](FName SessionName, bool bWasSuccessful)
+				{
+#if CREATE_MIRROR_PLATFORM_SESSION
+					if (bWasSuccessful)
+					{
+						// We need the session settings & session id from EOS
+						FOnlineSessionSettings* Settings = EOSSessionInterface->GetSessionSettings(SessionName);
+						if (Settings != nullptr)
+						{
+							FUniqueNetIdEOSPlusPtr Id = GetNetIdPlus(HostingPlayerIdStr);
+
+							// Mirror in the base interface
+							BaseSessionInterface->CreateSession(*Id->GetBaseNetId(), SessionName, *Settings);
+
+							EOSSessionInterface->ClearOnCreateSessionCompleteDelegate_Handle(OnCreateSessionCompleteDelegateHandleEOS);
+
+							return;
+						}
+
+						bWasSuccessful = false;
+					}
+#endif
+
+					OnCreateSessionComplete(SessionName, bWasSuccessful);
+
+					EOSSessionInterface->ClearOnCreateSessionCompleteDelegate_Handle(OnCreateSessionCompleteDelegateHandleEOS);
+				}));
+		return EOSSessionInterface->CreateSession(*Id->GetEOSNetId(), SessionName, NewSessionSettings);
+	}
+	// Otherwise create the platform version
+	return EOSSessionInterface->CreateSession(*Id->GetBaseNetId(), SessionName, NewSessionSettings);;
+}
+
+bool FOnlineSessionEOSPlus::StartSession(FName SessionName)
+{
+	if (bUseEOSSessions)
+	{
+		if (!EOSSessionInterface->StartSession(SessionName))
+		{
+			return false;
+		}
+	}
+	return BaseSessionInterface->StartSession(SessionName);
+}
+
+bool FOnlineSessionEOSPlus::UpdateSession(FName SessionName, FOnlineSessionSettings& UpdatedSessionSettings, bool bShouldRefreshOnlineData)
+{
+	if (bUseEOSSessions)
+	{
+		if (!EOSSessionInterface->UpdateSession(SessionName, UpdatedSessionSettings, bShouldRefreshOnlineData))
+		{
+			return false;
+		}
+	}
+	return BaseSessionInterface->UpdateSession(SessionName, UpdatedSessionSettings, bShouldRefreshOnlineData);
+}
+
+bool FOnlineSessionEOSPlus::EndSession(FName SessionName)
+{
+	if (bUseEOSSessions)
+	{
+		if (!EOSSessionInterface->EndSession(SessionName))
+		{
+			return false;
+		}
+	}
+	return BaseSessionInterface->EndSession(SessionName);
+}
+
+FOnDestroySessionCompleteDelegate IgnoredDestroySessionDelegate;
+
+bool FOnlineSessionEOSPlus::DestroySession(FName SessionName, const FOnDestroySessionCompleteDelegate& CompletionDelegate)
+{
+	if (bUseEOSSessions)
+	{
+		if (!EOSSessionInterface->DestroySession(SessionName, CompletionDelegate))
+		{
+			return false;
+		}
+	}
+	return BaseSessionInterface->DestroySession(SessionName, IgnoredDestroySessionDelegate);
+}
+
+bool FOnlineSessionEOSPlus::IsPlayerInSession(FName SessionName, const FUniqueNetId& UniqueId)
+{
+	if (bUseEOSSessions)
+	{
+		FUniqueNetIdPtr Id = GetEOSNetId(UniqueId.ToString());
+		if (!Id.IsValid())
+		{
+			return false;
+		}
+		return EOSSessionInterface->IsPlayerInSession(SessionName, *Id);
+	}
+	FUniqueNetIdPtr Id = GetBaseNetId(UniqueId.ToString());
+	if (!Id.IsValid())
+	{
+		return false;
+	}
+	return BaseSessionInterface->IsPlayerInSession(SessionName, *Id);
+}
+
+bool FOnlineSessionEOSPlus::StartMatchmaking(const TArray<FUniqueNetIdRef>& LocalPlayers, FName SessionName, const FOnlineSessionSettings& NewSessionSettings, TSharedRef<FOnlineSessionSearch>& SearchSettings)
+{
+	UE_LOG_ONLINE(Warning, TEXT("[FOnlineSessionEOSPlus::StartMatchmaking] Matchmaking is not supported in EOSPlus or EOS"));
+
+	TriggerOnMatchmakingCompleteDelegates(SessionName, false);
+
+	return true;
+}
+
+bool FOnlineSessionEOSPlus::CancelMatchmaking(int32 SearchingPlayerNum, FName SessionName)
+{
+	UE_LOG_ONLINE(Warning, TEXT("[FOnlineSessionEOSPlus::CancelMatchmaking] Matchmaking is not supported in EOSPlus or EOS"));
+
+	TriggerOnCancelMatchmakingCompleteDelegates(SessionName, false);
+
+	return true;
+}
+
+bool FOnlineSessionEOSPlus::CancelMatchmaking(const FUniqueNetId& SearchingPlayerId, FName SessionName)
+{
+	UE_LOG_ONLINE(Warning, TEXT("[FOnlineSessionEOSPlus::CancelMatchmaking] Matchmaking is not supported in EOSPlus or EOS"));
+
+	TriggerOnCancelMatchmakingCompleteDelegates(SessionName, false);
+
+	return true;
+}
+
+bool FOnlineSessionEOSPlus::FindSessions(int32 SearchingPlayerNum, const TSharedRef<FOnlineSessionSearch>& SearchSettings)
+{
+	if (bUseEOSSessions)
+	{
+		return EOSSessionInterface->FindSessions(SearchingPlayerNum, SearchSettings);
+	}
+	return BaseSessionInterface->FindSessions(SearchingPlayerNum, SearchSettings);
+}
+
+bool FOnlineSessionEOSPlus::FindSessions(const FUniqueNetId& SearchingPlayerId, const TSharedRef<FOnlineSessionSearch>& SearchSettings)
+{
+	if (bUseEOSSessions)
+	{
+		FUniqueNetIdPtr Id = GetEOSNetId(SearchingPlayerId.ToString());
+		if (!Id.IsValid())
+		{
+			return false;
+		}
+		return EOSSessionInterface->FindSessions(*Id, SearchSettings);
+	}
+	FUniqueNetIdPtr Id = GetBaseNetId(SearchingPlayerId.ToString());
+	if (!Id.IsValid())
+	{
+		return false;
+	}
+	return BaseSessionInterface->FindSessions(*Id, SearchSettings);
+}
+
+bool FOnlineSessionEOSPlus::FindSessionById(const FUniqueNetId& SearchingUserId, const FUniqueNetId& SessionId, const FUniqueNetId& FriendId, const FOnSingleSessionResultCompleteDelegate& CompletionDelegate)
+{
+	if (bUseEOSSessions)
+	{
+		FUniqueNetIdPtr Id = GetEOSNetId(SearchingUserId.ToString());
+		if (!Id.IsValid())
+		{
+			return false;
+		}
+		FUniqueNetIdPtr Friend = GetEOSNetId(FriendId.ToString());
+		if (!Friend.IsValid())
+		{
+			return false;
+		}
+		return EOSSessionInterface->FindSessionById(*Id, SessionId, *Friend, CompletionDelegate);
+	}
+	FUniqueNetIdPtr Id = GetBaseNetId(SearchingUserId.ToString());
+	if (!Id.IsValid())
+	{
+		return false;
+	}
+	FUniqueNetIdPtr Friend = GetBaseNetId(FriendId.ToString());
+	if (!Friend.IsValid())
+	{
+		return false;
+	}
+	return BaseSessionInterface->FindSessionById(*Id, SessionId, *Friend, CompletionDelegate);
+}
+
+bool FOnlineSessionEOSPlus::CancelFindSessions()
+{
+	if (bUseEOSSessions)
+	{
+		return EOSSessionInterface->CancelFindSessions();
+	}
+	return BaseSessionInterface->CancelFindSessions();
+}
+
+bool FOnlineSessionEOSPlus::PingSearchResults(const FOnlineSessionSearchResult& SearchResult)
+{
+	if (bUseEOSSessions)
+	{
+		return EOSSessionInterface->PingSearchResults(SearchResult);
+	}
+	return BaseSessionInterface->PingSearchResults(SearchResult);
+}
+
+bool FOnlineSessionEOSPlus::JoinSession(int32 PlayerNum, FName SessionName, const FOnlineSessionSearchResult& DesiredSession)
+{
+	if (bUseEOSSessions)
+	{
+		return EOSSessionInterface->JoinSession(PlayerNum, SessionName, DesiredSession);
+	}
+	return BaseSessionInterface->JoinSession(PlayerNum, SessionName, DesiredSession);
+}
+
+bool FOnlineSessionEOSPlus::JoinSession(const FUniqueNetId& PlayerId, FName SessionName, const FOnlineSessionSearchResult& DesiredSession)
+{
+	if (bUseEOSSessions)
+	{
+		FUniqueNetIdPtr Id = GetEOSNetId(PlayerId.ToString());
+		if (!Id.IsValid())
+		{
+			return false;
+		}
+		return EOSSessionInterface->JoinSession(*Id, SessionName, DesiredSession);
+	}
+	FUniqueNetIdPtr Id = GetBaseNetId(PlayerId.ToString());
+	if (!Id.IsValid())
+	{
+		return false;
+	}
+	return BaseSessionInterface->JoinSession(*Id, SessionName, DesiredSession);
+}
+
+bool FOnlineSessionEOSPlus::FindFriendSession(int32 LocalUserNum, const FUniqueNetId& Friend)
+{
+	if (bUseEOSSessions)
+	{
+		return EOSSessionInterface->FindFriendSession(LocalUserNum, Friend);
+	}
+	return BaseSessionInterface->FindFriendSession(LocalUserNum, Friend);
+}
+
+bool FOnlineSessionEOSPlus::FindFriendSession(const FUniqueNetId& LocalUserId, const FUniqueNetId& Friend)
+{
+	if (bUseEOSSessions)
+	{
+		FUniqueNetIdPtr Id = GetEOSNetId(LocalUserId.ToString());
+		if (!Id.IsValid())
+		{
+			return false;
+		}
+		FUniqueNetIdPtr FriendId = GetEOSNetId(Friend.ToString());
+		if (!FriendId.IsValid())
+		{
+			return false;
+		}
+		return EOSSessionInterface->FindFriendSession(*Id, *FriendId);
+	}
+	FUniqueNetIdPtr Id = GetBaseNetId(LocalUserId.ToString());
+	if (!Id.IsValid())
+	{
+		return false;
+	}
+	FUniqueNetIdPtr FriendId = GetBaseNetId(Friend.ToString());
+	if (!FriendId.IsValid())
+	{
+		return false;
+	}
+	return BaseSessionInterface->FindFriendSession(*Id, *FriendId);
+}
+
+bool FOnlineSessionEOSPlus::FindFriendSession(const FUniqueNetId& LocalUserId, const TArray<FUniqueNetIdRef>& FriendList)
+{
+	if (bUseEOSSessions)
+	{
+		FUniqueNetIdPtr Id = GetEOSNetId(LocalUserId.ToString());
+		if (!Id.IsValid())
+		{
+			return false;
+		}
+		return EOSSessionInterface->FindFriendSession(*Id, GetEOSNetIds(FriendList));
+	}
+	FUniqueNetIdPtr Id = GetBaseNetId(LocalUserId.ToString());
+	if (!Id.IsValid())
+	{
+		return false;
+	}
+	return BaseSessionInterface->FindFriendSession(*Id, GetBaseNetIds(FriendList));
+}
+
+bool FOnlineSessionEOSPlus::SendSessionInviteToFriend(int32 LocalUserNum, FName SessionName, const FUniqueNetId& Friend)
+{
+	if (bUseEOSSessions)
+	{
+		FUniqueNetIdPtr FriendId = GetEOSNetId(Friend.ToString());
+		if (!FriendId.IsValid())
+		{
+			return false;
+		}
+		return EOSSessionInterface->SendSessionInviteToFriend(LocalUserNum, SessionName, *FriendId);
+	}
+	FUniqueNetIdPtr FriendId = GetBaseNetId(Friend.ToString());
+	if (!FriendId.IsValid())
+	{
+		return false;
+	}
+	return BaseSessionInterface->SendSessionInviteToFriend(LocalUserNum, SessionName, *FriendId);
+}
+
+bool FOnlineSessionEOSPlus::SendSessionInviteToFriend(const FUniqueNetId& LocalUserId, FName SessionName, const FUniqueNetId& Friend)
+{
+	if (bUseEOSSessions)
+	{
+		FUniqueNetIdPtr Id = GetEOSNetId(LocalUserId.ToString());
+		if (!Id.IsValid())
+		{
+			return false;
+		}
+		FUniqueNetIdPtr FriendId = GetEOSNetId(Friend.ToString());
+		if (!FriendId.IsValid())
+		{
+			return false;
+		}
+		return EOSSessionInterface->SendSessionInviteToFriend(*Id, SessionName, *FriendId);
+	}
+	FUniqueNetIdPtr Id = GetBaseNetId(LocalUserId.ToString());
+	if (!Id.IsValid())
+	{
+		return false;
+	}
+	FUniqueNetIdPtr FriendId = GetBaseNetId(Friend.ToString());
+	if (!FriendId.IsValid())
+	{
+		return false;
+	}
+	return BaseSessionInterface->SendSessionInviteToFriend(*Id, SessionName, *FriendId);
+}
+
+bool FOnlineSessionEOSPlus::SendSessionInviteToFriends(int32 LocalUserNum, FName SessionName, const TArray<FUniqueNetIdRef>& Friends)
+{
+	if (bUseEOSSessions)
+	{
+		return EOSSessionInterface->SendSessionInviteToFriends(LocalUserNum, SessionName, GetEOSNetIds(Friends));
+	}
+	return BaseSessionInterface->SendSessionInviteToFriends(LocalUserNum, SessionName, GetBaseNetIds(Friends));
+}
+
+bool FOnlineSessionEOSPlus::SendSessionInviteToFriends(const FUniqueNetId& LocalUserId, FName SessionName, const TArray<FUniqueNetIdRef>& Friends)
+{
+	if (bUseEOSSessions)
+	{
+		FUniqueNetIdPtr Id = GetEOSNetId(LocalUserId.ToString());
+		if (!Id.IsValid())
+		{
+			return false;
+		}
+		return EOSSessionInterface->SendSessionInviteToFriends(*Id, SessionName, GetEOSNetIds(Friends));
+	}
+	FUniqueNetIdPtr Id = GetBaseNetId(LocalUserId.ToString());
+	if (!Id.IsValid())
+	{
+		return false;
+	}
+	return BaseSessionInterface->SendSessionInviteToFriends(*Id, SessionName, GetBaseNetIds(Friends));
+}
+
+bool FOnlineSessionEOSPlus::GetResolvedConnectString(FName SessionName, FString& ConnectInfo, FName PortType)
+{
+	if (bUseEOSSessions)
+	{
+		return EOSSessionInterface->GetResolvedConnectString(SessionName, ConnectInfo, PortType);
+	}
+	return BaseSessionInterface->GetResolvedConnectString(SessionName, ConnectInfo, PortType);
+}
+
+bool FOnlineSessionEOSPlus::GetResolvedConnectString(const FOnlineSessionSearchResult& SearchResult, FName PortType, FString& ConnectInfo)
+{
+	if (bUseEOSSessions)
+	{
+		return EOSSessionInterface->GetResolvedConnectString(SearchResult, PortType, ConnectInfo);
+	}
+	return BaseSessionInterface->GetResolvedConnectString(SearchResult, PortType, ConnectInfo);
+}
+
+FOnlineSessionSettings* FOnlineSessionEOSPlus::GetSessionSettings(FName SessionName)
+{
+	if (bUseEOSSessions)
+	{
+		return EOSSessionInterface->GetSessionSettings(SessionName);
+	}
+	return BaseSessionInterface->GetSessionSettings(SessionName);
+}
+
+bool FOnlineSessionEOSPlus::RegisterPlayer(FName SessionName, const FUniqueNetId& PlayerId, bool bWasInvited)
+{
+	if (bUseEOSSessions)
+	{
+		FUniqueNetIdPtr Id = GetEOSNetId(PlayerId.ToString());
+		if (!Id.IsValid())
+		{
+			return false;
+		}
+		if (!EOSSessionInterface->RegisterPlayer(SessionName, *Id, bWasInvited))
+		{
+			return false;
+		}
+	}
+	FUniqueNetIdPtr Id = GetBaseNetId(PlayerId.ToString());
+	if (!Id.IsValid())
+	{
+		return false;
+	}
+	return BaseSessionInterface->RegisterPlayer(SessionName, *Id, bWasInvited);
+}
+
+bool FOnlineSessionEOSPlus::RegisterPlayers(FName SessionName, const TArray<FUniqueNetIdRef>& Players, bool bWasInvited)
+{
+	if (bUseEOSSessions)
+	{
+		if (!EOSSessionInterface->RegisterPlayers(SessionName, GetEOSNetIds(Players), bWasInvited))
+		{
+			return false;
+		}
+	}
+	return BaseSessionInterface->RegisterPlayers(SessionName, GetBaseNetIds(Players), bWasInvited);
+}
+
+bool FOnlineSessionEOSPlus::UnregisterPlayer(FName SessionName, const FUniqueNetId& PlayerId)
+{
+	if (bUseEOSSessions)
+	{
+		FUniqueNetIdPtr Id = GetEOSNetId(PlayerId.ToString());
+		if (!Id.IsValid())
+		{
+			return false;
+		}
+		if (!EOSSessionInterface->UnregisterPlayer(SessionName, *Id))
+		{
+			return false;
+		}
+	}
+	FUniqueNetIdPtr Id = GetBaseNetId(PlayerId.ToString());
+	if (!Id.IsValid())
+	{
+		return false;
+	}
+	return BaseSessionInterface->UnregisterPlayer(SessionName, *Id);
+}
+
+bool FOnlineSessionEOSPlus::UnregisterPlayers(FName SessionName, const TArray<FUniqueNetIdRef>& Players)
+{
+	if (bUseEOSSessions)
+	{
+		if (!EOSSessionInterface->UnregisterPlayers(SessionName, GetEOSNetIds(Players)))
+		{
+			return false;
+		}
+	}
+	return BaseSessionInterface->UnregisterPlayers(SessionName, GetBaseNetIds(Players));
+}
+
+FOnRegisterLocalPlayerCompleteDelegate IgnoredRegisterLocalPlayerDelegate;
+
+void FOnlineSessionEOSPlus:: RegisterLocalPlayer(const FUniqueNetId& PlayerId, FName SessionName, const FOnRegisterLocalPlayerCompleteDelegate& Delegate)
+{
+	if (bUseEOSSessions)
+	{
+		FUniqueNetIdPtr Id = GetEOSNetId(PlayerId.ToString());
+		if (Id.IsValid())
+		{
+			EOSSessionInterface->RegisterLocalPlayer(*Id, SessionName, Delegate);
+		}
+		else
+		{
+			Delegate.ExecuteIfBound(PlayerId, EOnJoinSessionCompleteResult::UnknownError);
+		}
+	}
+	FUniqueNetIdPtr Id = GetBaseNetId(PlayerId.ToString());
+	if (!Id.IsValid())
+	{
+		return;
+	}
+	BaseSessionInterface->RegisterLocalPlayer(*Id, SessionName, IgnoredRegisterLocalPlayerDelegate);
+}
+
+FOnUnregisterLocalPlayerCompleteDelegate IgnoredUnregisterLocalPlayerDelegate;
+
+void FOnlineSessionEOSPlus:: UnregisterLocalPlayer(const FUniqueNetId& PlayerId, FName SessionName, const FOnUnregisterLocalPlayerCompleteDelegate& Delegate)
+{
+	if (bUseEOSSessions)
+	{
+		FUniqueNetIdPtr Id = GetEOSNetId(PlayerId.ToString());
+		if (Id.IsValid())
+		{
+			EOSSessionInterface->UnregisterLocalPlayer(*Id, SessionName, Delegate);
+		}
+		else
+		{
+			Delegate.ExecuteIfBound(PlayerId, false);
+		}
+	}
+	FUniqueNetIdPtr Id = GetBaseNetId(PlayerId.ToString());
+	if (!Id.IsValid())
+	{
+		return;
+	}
+	BaseSessionInterface->UnregisterLocalPlayer(*Id, SessionName, IgnoredUnregisterLocalPlayerDelegate);
+}
+
+int32 FOnlineSessionEOSPlus::GetNumSessions()
+{
+	if (bUseEOSSessions)
+	{
+		return EOSSessionInterface->GetNumSessions();
+	}
+	return BaseSessionInterface->GetNumSessions();
+}
+
+void FOnlineSessionEOSPlus:: DumpSessionState()
+{
+	if (bUseEOSSessions)
+	{
+		EOSSessionInterface->GetNumSessions();
+	}
+	BaseSessionInterface->GetNumSessions();
+}
+
+FNamedOnlineSession* FOnlineSessionEOSPlus::GetNamedSession(FName SessionName)
+{
+	if (bUseEOSSessions)
+	{
+		return EOSSessionInterface->GetNamedSession(SessionName);
+	}
+	return BaseSessionInterface->GetNamedSession(SessionName);
+}
+
+void FOnlineSessionEOSPlus:: RemoveNamedSession(FName SessionName)
+{
+	if (bUseEOSSessions)
+	{
+		EOSSessionInterface->RemoveNamedSession(SessionName);
+		return;
+	}
+	BaseSessionInterface->RemoveNamedSession(SessionName);
+}
+
+EOnlineSessionState::Type FOnlineSessionEOSPlus::GetSessionState(FName SessionName) const
+{
+	if (bUseEOSSessions)
+	{
+		return EOSSessionInterface->GetSessionState(SessionName);
+	}
+	return BaseSessionInterface->GetSessionState(SessionName);
+}
+
+bool FOnlineSessionEOSPlus::HasPresenceSession()
+{
+	if (bUseEOSSessions)
+	{
+		return EOSSessionInterface->HasPresenceSession();
+	}
+	return BaseSessionInterface->HasPresenceSession();
+}
+
+FUniqueNetIdPtr FOnlineSessionEOSPlus::CreateSessionIdFromString(const FString& SessionIdStr)
+{
+	if (bUseEOSSessions)
+	{
+		return EOSSessionInterface->CreateSessionIdFromString(SessionIdStr);
+	}
+	return BaseSessionInterface->CreateSessionIdFromString(SessionIdStr);
+}
Index: Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOSPlus/OnlineSubsystemEOSPlus.Build.cs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOSPlus/OnlineSubsystemEOSPlus.Build.cs b/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOSPlus/OnlineSubsystemEOSPlus.Build.cs
new file mode 100644
--- /dev/null	(date 1641575208000)
+++ b/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOSPlus/OnlineSubsystemEOSPlus.Build.cs	(date 1641575208000)
@@ -0,0 +1,33 @@
+// Copyright Epic Games, Inc. All Rights Reserved.
+
+using UnrealBuildTool;
+
+public class OnlineSubsystemEOSPlus : ModuleRules
+{
+	public OnlineSubsystemEOSPlus(ReadOnlyTargetRules Target) : base(Target)
+	{
+		PrivateDefinitions.Add("ONLINESUBSYSTEMEOSPLUS_PACKAGE=1");
+
+		PublicDependencyModuleNames.AddRange(
+			new string[] {
+				"OnlineSubsystemUtils"
+			}
+		);
+
+		PrivateDependencyModuleNames.AddRange(
+			new string[] {
+				"Core",
+				"CoreUObject",
+				"Engine",
+				"Sockets",
+				"OnlineSubsystem",
+				"Json",
+				"OnlineSubsystemEOS"
+			}
+		);
+
+		PrivateDefinitions.Add("CREATE_MIRROR_PLATFORM_SESSION=" + (bCreateMirrorPlatformSession ? "1" : "0"));
+	}
+
+	protected virtual bool bCreateMirrorPlatformSession { get { return true; } }
+}
Index: Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOSPlus/Public/OnlineSubsystemEOSPlusModule.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOSPlus/Public/OnlineSubsystemEOSPlusModule.h b/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOSPlus/Public/OnlineSubsystemEOSPlusModule.h
new file mode 100644
--- /dev/null	(date 1641575208000)
+++ b/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOSPlus/Public/OnlineSubsystemEOSPlusModule.h	(date 1641575208000)
@@ -0,0 +1,41 @@
+// Copyright Epic Games, Inc. All Rights Reserved.
+
+#pragma once
+
+#include "CoreMinimal.h"
+#include "Modules/ModuleInterface.h"
+
+/**
+ * OSS that aggregates EOS plus the platform OSS
+ */
+class FOnlineSubsystemEOSPlusModule : public IModuleInterface
+{
+public:
+
+	FOnlineSubsystemEOSPlusModule() :
+		PlusFactory(nullptr)
+	{}
+
+	virtual ~FOnlineSubsystemEOSPlusModule() {}
+
+
+// IModuleInterface
+	virtual void StartupModule() override;
+	virtual void ShutdownModule() override;
+	virtual bool SupportsDynamicReloading() override
+	{
+		return false;
+	}
+
+	virtual bool SupportsAutomaticShutdown() override
+	{
+		return false;
+	}
+// ~IModuleInterface
+
+private:
+	void LoadBaseOSS();
+
+	/** Class responsible for creating instance(s) of the subsystem */
+	class FOnlineFactoryEOSPlus* PlusFactory;
+};
Index: Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOSPlus/Public/OnlineSubsystemEOSPlusPackage.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOSPlus/Public/OnlineSubsystemEOSPlusPackage.h b/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOSPlus/Public/OnlineSubsystemEOSPlusPackage.h
new file mode 100644
--- /dev/null	(date 1641575208000)
+++ b/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOSPlus/Public/OnlineSubsystemEOSPlusPackage.h	(date 1641575208000)
@@ -0,0 +1,15 @@
+// Copyright Epic Games, Inc. All Rights Reserved.
+
+// Can't be #pragma once because other modules may define PACKAGE_SCOPE
+
+// Intended to be the last include in an exported class definition
+// Properly defines some members as "public to the module" vs "private to the consumer/user"
+
+// [[ IncludeTool: Inline ]] // Markup to tell IncludeTool that this file is state changing and cannot be optimized out.
+
+#undef PACKAGE_SCOPE
+#if ONLINESUBSYSTEMEOSPLUS_PACKAGE
+	#define PACKAGE_SCOPE public
+#else
+	#define PACKAGE_SCOPE protected
+#endif
Index: Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOSPlus/Private/OnlineVoiceEOSPlus.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOSPlus/Private/OnlineVoiceEOSPlus.h b/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOSPlus/Private/OnlineVoiceEOSPlus.h
new file mode 100644
--- /dev/null	(date 1641576012000)
+++ b/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOSPlus/Private/OnlineVoiceEOSPlus.h	(date 1641576012000)
@@ -0,0 +1,68 @@
+// Copyright Epic Games, Inc. All Rights Reserved.
+
+#pragma once
+
+#include "CoreMinimal.h"
+#include "Online/CoreOnline.h"
+#include "OnlineSubsystem.h"
+#include "Interfaces/VoiceInterface.h"
+#include "OnlineUserEOSPlus.h"
+
+class FOnlineSubsystemEOSPlus;
+
+/**
+ * Interface for encapsulating the platform voice interface
+ */
+class FOnlineVoiceEOSPlus :
+	public IOnlineVoice,
+	public TSharedFromThis<FOnlineVoiceEOSPlus, ESPMode::ThreadSafe>
+{
+public:
+	FOnlineVoiceEOSPlus() = delete;
+	virtual ~FOnlineVoiceEOSPlus();
+
+	void Initialize();
+
+	//~ Begin IOnlineVoice Interface
+	virtual void StartNetworkedVoice(uint8 LocalUserNum) override;
+	virtual void StopNetworkedVoice(uint8 LocalUserNum) override;
+	virtual bool RegisterLocalTalker(uint32 LocalUserNum) override;
+	virtual void RegisterLocalTalkers() override;
+	virtual bool UnregisterLocalTalker(uint32 LocalUserNum) override;
+	virtual void UnregisterLocalTalkers() override;
+	virtual bool RegisterRemoteTalker(const FUniqueNetId& UniqueId) override;
+	virtual bool UnregisterRemoteTalker(const FUniqueNetId& UniqueId) override;
+	virtual void RemoveAllRemoteTalkers() override;
+	virtual bool IsHeadsetPresent(uint32 LocalUserNum) override;
+	virtual bool IsLocalPlayerTalking(uint32 LocalUserNum) override;
+	virtual bool IsRemotePlayerTalking(const FUniqueNetId& UniqueId) override;
+	virtual bool IsMuted(uint32 LocalUserNum, const FUniqueNetId& UniqueId) const override;
+	virtual bool MuteRemoteTalker(uint8 LocalUserNum, const FUniqueNetId& PlayerId, bool bIsSystemWide) override;
+	virtual bool UnmuteRemoteTalker(uint8 LocalUserNum, const FUniqueNetId& PlayerId, bool bIsSystemWide) override;
+	virtual TSharedPtr<FVoicePacket> SerializeRemotePacket(FArchive& Ar) override;
+	virtual TSharedPtr<FVoicePacket> GetLocalPacket(uint32 LocalUserNum) override;
+	virtual int32 GetNumLocalTalkers() override;
+	virtual void ClearVoicePackets() override;
+	virtual void Tick(float DeltaTime) override;
+	virtual FString GetVoiceDebugState() const override;
+	//~ End IOnlineVoice Interface
+
+PACKAGE_SCOPE:
+	FOnlineVoiceEOSPlus(FOnlineSubsystemEOSPlus* InSubsystem);
+
+	virtual IVoiceEnginePtr CreateVoiceEngine() override;
+	virtual void ProcessMuteChangeNotification() override;
+	
+	void OnPlayerTalkingStateChanged(FUniqueNetIdRef TalkerId, bool bIsTalking);
+
+private:
+	FUniqueNetIdEOSPlusPtr GetNetIdPlus(const FString& SourceId) const;
+
+	/** Reference to the owning EOS plus subsystem */
+	FOnlineSubsystemEOSPlus* EOSPlus;
+	
+	// We don't support EOS mirroring yet
+	IOnlineVoicePtr BaseVoiceInterface;
+};
+
+typedef TSharedPtr<FOnlineVoiceEOSPlus, ESPMode::ThreadSafe> FOnlineVoiceEOSPlusPtr;
Index: Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOSPlus/Private/OnlineUserEOSPlus.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOSPlus/Private/OnlineUserEOSPlus.cpp b/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOSPlus/Private/OnlineUserEOSPlus.cpp
new file mode 100644
--- /dev/null	(date 1641576012000)
+++ b/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOSPlus/Private/OnlineUserEOSPlus.cpp	(date 1641576012000)
@@ -0,0 +1,1374 @@
+// Copyright Epic Games, Inc. All Rights Reserved.
+
+#include "OnlineUserEOSPlus.h"
+#include "OnlineSubsystem.h"
+#include "OnlineSubsystemEOSPlus.h"
+#include "EOSSettings.h"
+
+enum class EOSSValue : uint8
+{
+	Null,
+	Steam,
+	PS4,
+	XboxLive,
+	Switch,
+	Apple
+};
+
+static inline EOSSValue ToEOSSValue(FName OSSName)
+{
+	if (OSSName == STEAM_SUBSYSTEM)
+	{
+		return EOSSValue::Steam;
+	}
+	else if (OSSName == PS4_SUBSYSTEM)
+	{
+		return EOSSValue::PS4;
+	}
+PRAGMA_DISABLE_DEPRECATION_WARNINGS
+	else if (OSSName == LIVE_SUBSYSTEM)
+	{
+		return EOSSValue::XboxLive;
+	}
+PRAGMA_ENABLE_DEPRECATION_WARNINGS
+	else if (OSSName == SWITCH_SUBSYSTEM)
+	{
+		return EOSSValue::Switch;
+	}
+	else if (OSSName == APPLE_SUBSYSTEM)
+	{
+		return EOSSValue::Apple;
+	}
+	return EOSSValue::Null;
+}
+
+static inline FName ToOSSName(EOSSValue OSSValue)
+{
+	if (OSSValue == EOSSValue::Steam)
+	{
+		return STEAM_SUBSYSTEM;
+	}
+	else if (OSSValue == EOSSValue::PS4)
+	{
+		return PS4_SUBSYSTEM;
+	}
+PRAGMA_DISABLE_DEPRECATION_WARNINGS
+	else if (OSSValue == EOSSValue::XboxLive)
+	{
+		return LIVE_SUBSYSTEM;
+	}
+PRAGMA_ENABLE_DEPRECATION_WARNINGS
+	else if (OSSValue == EOSSValue::Switch)
+	{
+		return SWITCH_SUBSYSTEM;
+	}
+	else if (OSSValue == EOSSValue::Apple)
+	{
+		return APPLE_SUBSYSTEM;
+	}
+	return NULL_SUBSYSTEM;
+}
+
+inline FString BuildEOSPlusStringId(FUniqueNetIdPtr InBaseUniqueNetId, FUniqueNetIdPtr InEOSUniqueNetId)
+{
+	FString StrId = InBaseUniqueNetId.IsValid() ? InBaseUniqueNetId->ToString() : TEXT("");
+	StrId += TEXT("_+_");
+	StrId += InEOSUniqueNetId.IsValid() ? InEOSUniqueNetId->ToString() : TEXT("");
+	return StrId;
+}
+
+FUniqueNetIdEOSPlus::FUniqueNetIdEOSPlus(FUniqueNetIdPtr InBaseUniqueNetId, FUniqueNetIdPtr InEOSUniqueNetId)
+	PRAGMA_DISABLE_DEPRECATION_WARNINGS
+	: FUniqueNetIdString(BuildEOSPlusStringId(InBaseUniqueNetId, InEOSUniqueNetId), FName("EOSPlus"))
+	PRAGMA_ENABLE_DEPRECATION_WARNINGS
+	, BaseUniqueNetId(InBaseUniqueNetId)
+	, EOSUniqueNetId(InEOSUniqueNetId)
+{
+	int32 TotalBytes = GetSize();
+	RawBytes.Empty(TotalBytes);
+	RawBytes.AddZeroed(TotalBytes);
+
+	if (EOSUniqueNetId.IsValid())
+	{
+		int32 EOSSize = EOSUniqueNetId->GetSize();
+		FMemory::Memcpy(RawBytes.GetData(), EOSUniqueNetId->GetBytes(), EOSSize);
+	}
+
+	int32 Offset = EOS_NETID_BYTE_SIZE;
+	// Default to the NULL OSS
+	*(RawBytes.GetData() + Offset) = (uint8)EOSSValue::Null;
+
+	if (BaseUniqueNetId.IsValid())
+	{
+		// For crossplatform support, identify the source
+		*(RawBytes.GetData() + EOS_NETID_BYTE_SIZE) = (uint8)ToEOSSValue(BaseUniqueNetId->GetType());
+		Offset += BASE_NETID_TYPE_SIZE;
+
+		int32 BaseSize = BaseUniqueNetId->GetSize();
+		// Always copy above the EOS ID
+		FMemory::Memcpy(RawBytes.GetData() + Offset, BaseUniqueNetId->GetBytes(), BaseSize);
+	}
+}
+
+const uint8* FUniqueNetIdEOSPlus::GetBytes() const
+{
+	return RawBytes.GetData();
+}
+
+int32 FUniqueNetIdEOSPlus::GetSize() const
+{
+	// Always account for EOS ID
+	int32 Size = EOS_NETID_BYTE_SIZE + BASE_NETID_TYPE_SIZE;
+	if (BaseUniqueNetId.IsValid())
+	{
+		Size += BaseUniqueNetId->GetSize();
+	}
+	return Size;
+}
+
+bool FUniqueNetIdEOSPlus::IsValid() const
+{
+	return BaseUniqueNetId.IsValid() || EOSUniqueNetId.IsValid();
+}
+
+FOnlineUserEOSPlus::FOnlineUserEOSPlus(FOnlineSubsystemEOSPlus* InSubsystem)
+	: EOSPlus(InSubsystem)
+{
+	BaseUserInterface = EOSPlus->BaseOSS->GetUserInterface(); //We don't check it here, since some platforms might not implement it
+
+	BaseIdentityInterface = EOSPlus->BaseOSS->GetIdentityInterface();
+	check(BaseIdentityInterface.IsValid());
+	EOSIdentityInterface = EOSPlus->EosOSS->GetIdentityInterface();
+	check(EOSIdentityInterface.IsValid());
+	BaseFriendsInterface = EOSPlus->BaseOSS->GetFriendsInterface();
+	check(BaseFriendsInterface.IsValid());
+	EOSFriendsInterface = EOSPlus->EosOSS->GetFriendsInterface();
+	check(EOSFriendsInterface.IsValid());
+	BasePresenceInterface = EOSPlus->BaseOSS->GetPresenceInterface();
+	check(BasePresenceInterface.IsValid());
+	EOSPresenceInterface = EOSPlus->EosOSS->GetPresenceInterface();
+	check(EOSPresenceInterface.IsValid());
+
+	BaseFriendsInterface->AddOnInviteReceivedDelegate_Handle(FOnInviteReceivedDelegate::CreateRaw(this, &FOnlineUserEOSPlus::OnInviteReceived));
+	BaseFriendsInterface->AddOnInviteAcceptedDelegate_Handle(FOnInviteAcceptedDelegate::CreateRaw(this, &FOnlineUserEOSPlus::OnInviteAccepted));
+	BaseFriendsInterface->AddOnInviteRejectedDelegate_Handle(FOnInviteRejectedDelegate::CreateRaw(this, &FOnlineUserEOSPlus::OnInviteRejected));
+	BaseFriendsInterface->AddOnInviteAbortedDelegate_Handle(FOnInviteAbortedDelegate::CreateRaw(this, &FOnlineUserEOSPlus::OnInviteAborted));
+	BaseFriendsInterface->AddOnFriendRemovedDelegate_Handle(FOnFriendRemovedDelegate::CreateRaw(this, &FOnlineUserEOSPlus::OnFriendRemoved));
+	EOSFriendsInterface->AddOnInviteReceivedDelegate_Handle(FOnInviteReceivedDelegate::CreateRaw(this, &FOnlineUserEOSPlus::OnInviteReceived));
+	EOSFriendsInterface->AddOnInviteAcceptedDelegate_Handle(FOnInviteAcceptedDelegate::CreateRaw(this, &FOnlineUserEOSPlus::OnInviteAccepted));
+	EOSFriendsInterface->AddOnInviteRejectedDelegate_Handle(FOnInviteRejectedDelegate::CreateRaw(this, &FOnlineUserEOSPlus::OnInviteRejected));
+	EOSFriendsInterface->AddOnInviteAbortedDelegate_Handle(FOnInviteAbortedDelegate::CreateRaw(this, &FOnlineUserEOSPlus::OnInviteAborted));
+	EOSFriendsInterface->AddOnFriendRemovedDelegate_Handle(FOnFriendRemovedDelegate::CreateRaw(this, &FOnlineUserEOSPlus::OnFriendRemoved));
+	// Only rebroadcast the platform notifications
+	BasePresenceInterface->AddOnPresenceReceivedDelegate_Handle(FOnPresenceReceivedDelegate::CreateRaw(this, &FOnlineUserEOSPlus::OnPresenceReceived));
+	BasePresenceInterface->AddOnPresenceArrayUpdatedDelegate_Handle(FOnPresenceArrayUpdatedDelegate::CreateRaw(this, &FOnlineUserEOSPlus::OnPresenceArrayUpdated));
+
+	BaseIdentityInterface->AddOnLoginChangedDelegate_Handle(FOnLoginChangedDelegate::CreateRaw(this, &FOnlineUserEOSPlus::OnLoginChanged));
+	BaseIdentityInterface->AddOnControllerPairingChangedDelegate_Handle(FOnControllerPairingChangedDelegate::CreateRaw(this, &FOnlineUserEOSPlus::OnControllerPairingChanged));
+	for (int32 LocalUserNum = 0; LocalUserNum < MAX_LOCAL_PLAYERS; LocalUserNum++)
+	{
+		BaseIdentityInterface->AddOnLoginStatusChangedDelegate_Handle(LocalUserNum, FOnLoginStatusChangedDelegate::CreateRaw(this, &FOnlineUserEOSPlus::OnLoginStatusChanged));
+		EOSIdentityInterface->AddOnLoginCompleteDelegate_Handle(LocalUserNum, FOnLoginCompleteDelegate::CreateRaw(this, &FOnlineUserEOSPlus::OnLoginComplete));
+		BaseIdentityInterface->AddOnLoginCompleteDelegate_Handle(LocalUserNum, FOnLoginCompleteDelegate::CreateRaw(this, &FOnlineUserEOSPlus::OnBaseLoginComplete));
+		BaseIdentityInterface->AddOnLogoutCompleteDelegate_Handle(LocalUserNum, FOnLogoutCompleteDelegate::CreateRaw(this, &FOnlineUserEOSPlus::OnLogoutComplete));
+
+		BaseFriendsInterface->AddOnFriendsChangeDelegate_Handle(LocalUserNum, FOnFriendsChangeDelegate::CreateRaw(this, &FOnlineUserEOSPlus::OnFriendsChanged));
+		EOSFriendsInterface->AddOnFriendsChangeDelegate_Handle(LocalUserNum, FOnFriendsChangeDelegate::CreateRaw(this, &FOnlineUserEOSPlus::OnFriendsChanged));
+		BaseFriendsInterface->AddOnOutgoingInviteSentDelegate_Handle(LocalUserNum, FOnOutgoingInviteSentDelegate::CreateRaw(this, &FOnlineUserEOSPlus::OnOutgoingInviteSent));
+		EOSFriendsInterface->AddOnOutgoingInviteSentDelegate_Handle(LocalUserNum, FOnOutgoingInviteSentDelegate::CreateRaw(this, &FOnlineUserEOSPlus::OnOutgoingInviteSent));
+	}
+}
+
+FOnlineUserEOSPlus::~FOnlineUserEOSPlus()
+{
+	BaseIdentityInterface->ClearOnLoginChangedDelegates(this);
+	BaseIdentityInterface->ClearOnControllerPairingChangedDelegates(this);
+	BaseFriendsInterface->ClearOnInviteReceivedDelegates(this);
+	BaseFriendsInterface->ClearOnInviteAcceptedDelegates(this);
+	BaseFriendsInterface->ClearOnInviteRejectedDelegates(this);
+	BaseFriendsInterface->ClearOnInviteAbortedDelegates(this);
+	BaseFriendsInterface->ClearOnFriendRemovedDelegates(this);
+	EOSFriendsInterface->ClearOnInviteReceivedDelegates(this);
+	EOSFriendsInterface->ClearOnInviteAcceptedDelegates(this);
+	EOSFriendsInterface->ClearOnInviteRejectedDelegates(this);
+	EOSFriendsInterface->ClearOnInviteAbortedDelegates(this);
+	EOSFriendsInterface->ClearOnFriendRemovedDelegates(this);
+	BasePresenceInterface->ClearOnPresenceReceivedDelegates(this);
+	BasePresenceInterface->ClearOnPresenceArrayUpdatedDelegates(this);
+
+	for (int32 LocalUserNum = 0; LocalUserNum < MAX_LOCAL_PLAYERS; LocalUserNum++)
+	{
+		if (BaseUserInterface.IsValid())
+		{
+			BaseUserInterface->ClearOnQueryUserInfoCompleteDelegates(LocalUserNum, this);
+		}
+
+		BaseIdentityInterface->ClearOnLoginStatusChangedDelegates(LocalUserNum, this);
+		BaseIdentityInterface->ClearOnLoginCompleteDelegates(LocalUserNum, this);
+		BaseIdentityInterface->ClearOnLogoutCompleteDelegates(LocalUserNum, this);
+
+		BaseFriendsInterface->ClearOnFriendsChangeDelegates(LocalUserNum, this);
+		EOSFriendsInterface->ClearOnFriendsChangeDelegates(LocalUserNum, this);
+		BaseFriendsInterface->ClearOnOutgoingInviteSentDelegates(LocalUserNum, this);
+		EOSFriendsInterface->ClearOnOutgoingInviteSentDelegates(LocalUserNum, this);
+	}
+}
+
+FUniqueNetIdEOSPlusPtr FOnlineUserEOSPlus::GetNetIdPlus(const FString& SourceId) const
+{
+	if (NetIdPlusToNetIdPlus.Contains(SourceId))
+	{
+		return NetIdPlusToNetIdPlus[SourceId];
+	}
+	if (BaseNetIdToNetIdPlus.Contains(SourceId))
+	{
+		return BaseNetIdToNetIdPlus[SourceId];
+	}
+	if (EOSNetIdToNetIdPlus.Contains(SourceId))
+	{
+		return EOSNetIdToNetIdPlus[SourceId];
+	}
+	return nullptr;
+}
+
+FUniqueNetIdPtr FOnlineUserEOSPlus::GetBaseNetId(const FString& SourceId) const
+{
+	if (NetIdPlusToBaseNetId.Contains(SourceId))
+	{
+		return NetIdPlusToBaseNetId[SourceId];
+	}
+	return nullptr;
+}
+
+FUniqueNetIdPtr FOnlineUserEOSPlus::GetEOSNetId(const FString& SourceId) const
+{
+	if (NetIdPlusToEOSNetId.Contains(SourceId))
+	{
+		return NetIdPlusToEOSNetId[SourceId];
+	}
+	return nullptr;
+}
+
+void FOnlineUserEOSPlus::Initialize()
+{
+	if (BaseUserInterface.IsValid())
+	{
+		for (int32 LocalUserNum = 0; LocalUserNum < MAX_LOCAL_PLAYERS; LocalUserNum++)
+		{
+			BaseUserInterface->AddOnQueryUserInfoCompleteDelegate_Handle(LocalUserNum, FOnQueryUserInfoCompleteDelegate::CreateThreadSafeSP(this, &FOnlineUserEOSPlus::OnQueryUserInfoCompleteBase));
+		}
+	}
+	else
+	{
+		UE_LOG_ONLINE(Warning, TEXT("[FOnlineUserEOSPlus::Initialize] BaseUserInterface delegates not bound. Base interface not valid"));
+	}
+}
+
+// IOnlineUser Interface
+
+bool FOnlineUserEOSPlus::QueryUserInfo(int32 LocalUserNum, const TArray<FUniqueNetIdRef>& UserIds)
+{
+	TArray< FUniqueNetIdRef > BaseUserIds;
+	if (BaseUserInterface.IsValid())
+	{
+		bool bArePlayerIdsValid = true;
+		for (const FUniqueNetIdRef& UserId : UserIds)
+		{
+			FUniqueNetIdEOSPlusPtr NetIdPlus = GetNetIdPlus(UserId->ToString());
+			if (NetIdPlus.IsValid())
+			{
+				const bool bIsBaseNetIdValid = ensure(NetIdPlus->GetBaseNetId().IsValid());
+				if (bIsBaseNetIdValid)
+				{
+					BaseUserIds.Add(NetIdPlus->GetBaseNetId().ToSharedRef());
+				}
+				else
+				{
+					UE_LOG_ONLINE(Warning, TEXT("[FOnlineUserEOSPlus::QueryUserInfo] Unable to call method in base interface. Base id not valid for user (%s)."), *UserId->ToDebugString());
+					bArePlayerIdsValid = false;
+					break;
+				}
+			}
+			else
+			{
+				UE_LOG_ONLINE(Warning, TEXT("[FOnlineUserEOSPlus::QueryUserInfo] Unable to call method in base interface. User not found (%s)."), *UserId->ToDebugString());
+				bArePlayerIdsValid = false;
+				break;
+			}
+		}
+
+		if (bArePlayerIdsValid)
+		{
+			return BaseUserInterface->QueryUserInfo(LocalUserNum, BaseUserIds);
+		}
+	}
+	else
+	{
+		UE_LOG_ONLINE(Warning, TEXT("[FOnlineUserEOSPlus::QueryUserInfo] Unable to call method in base interface. Base interface not valid."));
+	}
+
+	EOSPlus->ExecuteNextTick([this, LocalUserNum, BaseUserIds]() {
+		TriggerOnQueryUserInfoCompleteDelegates(LocalUserNum, false, BaseUserIds, TEXT("Unable to call method in base interface."));
+		});
+
+	return true;
+}
+
+bool FOnlineUserEOSPlus::GetAllUserInfo(int32 LocalUserNum, TArray<TSharedRef<FOnlineUser>>& OutUsers)
+{
+	bool bResult = false;
+
+	if (BaseUserInterface.IsValid())
+	{
+		TArray<TSharedRef<FOnlineUser>> BaseUsers;
+		bResult = BaseUserInterface->GetAllUserInfo(LocalUserNum, BaseUsers);
+
+		// We construct a list of Plus types to return
+		for (const TSharedRef<FOnlineUser>& BaseUser : BaseUsers)
+		{
+			OutUsers.Add(MakeShareable(new FOnlineUserPlus(BaseUser, nullptr)));
+		}
+	}
+	else
+	{
+		UE_LOG_ONLINE(Warning, TEXT("[FOnlineUserEOSPlus::GetAllUserInfo] Unable to call method in base interface. Base interface not valid."));
+	}
+
+	return bResult;
+}
+
+TSharedPtr<FOnlineUser> FOnlineUserEOSPlus::GetUserInfo(int32 LocalUserNum, const FUniqueNetId& UserId)
+{
+	TSharedPtr<FOnlineUserPlus> Result = nullptr;
+
+	FUniqueNetIdEOSPlusPtr NetIdPlus = GetNetIdPlus(UserId.ToString());
+	if (NetIdPlus.IsValid())
+	{
+		const bool bIsBaseNetIdValid = ensure(NetIdPlus->GetBaseNetId().IsValid());
+		const bool bIsBaseUserInterfaceValid = BaseUserInterface.IsValid();
+		if (bIsBaseNetIdValid && bIsBaseUserInterfaceValid)
+		{
+			// We make sure to always return a Plus type
+			TSharedPtr<FOnlineUser> BaseResult = BaseUserInterface->GetUserInfo(LocalUserNum, *NetIdPlus->GetBaseNetId());
+			if (BaseResult.IsValid())
+			{
+				Result = MakeShareable(new FOnlineUserPlus(BaseResult, nullptr));
+			}
+		}
+		else
+		{
+			UE_LOG_ONLINE(Warning, TEXT("[FOnlineUserEOSPlus::GetUserInfo] Unable to call method in base interface. IsBaseNetIdValid=%s IsBaseUserInterfaceValid=%s."), *LexToString(bIsBaseNetIdValid), *LexToString(bIsBaseUserInterfaceValid));
+		}
+	}
+	else
+	{
+		UE_LOG_ONLINE(Warning, TEXT("[FOnlineUserEOSPlus::GetUserInfo] Unable to call method in base interface. Unknown user (%s)"), *UserId.ToString());
+	}
+
+	return Result;
+}
+
+bool FOnlineUserEOSPlus::QueryUserIdMapping(const FUniqueNetId& UserId, const FString& DisplayNameOrEmail, const FOnQueryUserMappingComplete& Delegate)
+{
+	FUniqueNetIdEOSPlusPtr NetIdPlus = GetNetIdPlus(UserId.ToString());
+	if (NetIdPlus.IsValid())
+	{
+		const bool bIsBaseNetIdValid = ensure(NetIdPlus->GetBaseNetId().IsValid());
+		const bool bIsBaseUserInterfaceValid = BaseUserInterface.IsValid();
+		if (bIsBaseNetIdValid && bIsBaseUserInterfaceValid)
+		{
+			return BaseUserInterface->QueryUserIdMapping(*NetIdPlus->GetBaseNetId(), DisplayNameOrEmail, Delegate);
+		}
+		else
+		{
+			UE_LOG_ONLINE(Warning, TEXT("[FOnlineUserEOSPlus::QueryUserIdMapping] Unable to call method in base interface. IsBaseNetIdValid=%s IsBaseUserInterfaceValid=%s."), *LexToString(bIsBaseNetIdValid), *LexToString(bIsBaseUserInterfaceValid));
+		}
+	}
+	else
+	{
+		UE_LOG_ONLINE(Warning, TEXT("[FOnlineUserEOSPlus::QueryUserIdMapping] Unable to call method in base interface. Unknown user (%s)"), *UserId.ToString());
+	}
+
+	EOSPlus->ExecuteNextTick([this, NetIdPlus, DisplayNameOrEmail, Delegate]() {
+		Delegate.ExecuteIfBound(false, *NetIdPlus, DisplayNameOrEmail, *FUniqueNetIdEOSPlus::EmptyId(), TEXT("Unable to call method in base interface."));
+		});
+
+	return true;
+}
+
+bool FOnlineUserEOSPlus::QueryExternalIdMappings(const FUniqueNetId& UserId, const FExternalIdQueryOptions& QueryOptions, const TArray<FString>& ExternalIds, const FOnQueryExternalIdMappingsComplete& Delegate)
+{
+	FUniqueNetIdEOSPlusPtr NetIdPlus = GetNetIdPlus(UserId.ToString());
+	if (NetIdPlus.IsValid())
+	{
+		const bool bIsBaseNetIdValid = ensure(NetIdPlus->GetBaseNetId().IsValid());
+		const bool bIsBaseUserInterfaceValid = BaseUserInterface.IsValid();
+		if (bIsBaseNetIdValid && bIsBaseUserInterfaceValid)
+		{
+			return BaseUserInterface->QueryExternalIdMappings(*NetIdPlus->GetBaseNetId(), QueryOptions, ExternalIds, Delegate);
+		}
+		else
+		{
+			UE_LOG_ONLINE(Warning, TEXT("[FOnlineUserEOSPlus::QueryExternalIdMappings] Unable to call method in base interface. IsBaseNetIdValid=%s IsBaseUserInterfaceValid=%s."), *LexToString(bIsBaseNetIdValid), *LexToString(bIsBaseUserInterfaceValid));
+		}
+	}
+	else
+	{
+		UE_LOG_ONLINE(Warning, TEXT("[FOnlineUserEOSPlus::QueryExternalIdMappings] Unable to call method in base interface. Unknown user (%s)"), *UserId.ToString());
+	}
+
+	EOSPlus->ExecuteNextTick([this, NetIdPlus, QueryOptions, ExternalIds, Delegate]() {
+		Delegate.ExecuteIfBound(false, *NetIdPlus, QueryOptions, ExternalIds, TEXT("Unable to call method in base interface."));
+	});
+
+	return true;
+}
+
+void FOnlineUserEOSPlus::GetExternalIdMappings(const FExternalIdQueryOptions& QueryOptions, const TArray<FString>& ExternalIds, TArray<FUniqueNetIdPtr>& OutIds)
+{
+	if (BaseUserInterface.IsValid())
+	{
+		// We don't return Plus ids here because we want external id types
+		BaseUserInterface->GetExternalIdMappings(QueryOptions, ExternalIds, OutIds);
+	}
+	else
+	{
+		UE_LOG_ONLINE(Warning, TEXT("[FOnlineUserEOSPlus::GetExternalIdMappings] Unable to call method in base interface. Base interface not valid."));
+	}
+}
+
+FUniqueNetIdPtr FOnlineUserEOSPlus::GetExternalIdMapping(const FExternalIdQueryOptions& QueryOptions, const FString& ExternalId)
+{
+	FUniqueNetIdPtr Result = nullptr;
+
+	if (BaseUserInterface.IsValid())
+	{
+		// We don't return a Plus id here because we want external id types
+		Result = BaseUserInterface->GetExternalIdMapping(QueryOptions, ExternalId);
+	}
+	else
+	{
+		UE_LOG_ONLINE(Warning, TEXT("[FOnlineUserEOSPlus::GetExternalIdMapping] Unable to call method in base interface. Base interface not valid."));
+	}
+
+	return Result;
+}
+
+void FOnlineUserEOSPlus::OnQueryUserInfoCompleteBase(int32 LocalUserNum, bool bWasSuccessful, const TArray< FUniqueNetIdRef >& UserIds, const FString& ErrorStr)
+{
+	TArray< FUniqueNetIdRef > PlusUserIds;
+
+	if (bWasSuccessful)
+	{
+		// We'll build a list of PlusUserIds from the UserIds we can find
+		for (const FUniqueNetIdRef& UserId : UserIds)
+		{
+			FUniqueNetIdEOSPlusPtr NetIdPlus = GetNetIdPlus(UserId->ToString());
+			if (NetIdPlus.IsValid())
+			{
+				PlusUserIds.Add(NetIdPlus.ToSharedRef());
+			}
+			else
+			{
+				UE_LOG_ONLINE(Warning, TEXT("[FOnlineUserEOSPlus::OnQueryUserInfoCompleteBase] User not found (%s)."), *UserId->ToDebugString());
+			}
+		}
+	}
+
+	TriggerOnQueryUserInfoCompleteDelegates(LocalUserNum, bWasSuccessful, PlusUserIds, ErrorStr);
+}
+
+// ~IOnlineUser Interface
+
+bool FOnlineUserEOSPlus::Login(int32 LocalUserNum, const FOnlineAccountCredentials& AccountCredentials)
+{
+	LocalUserNumToLastLoginCredentials.Emplace(LocalUserNum, MakeShared<FOnlineAccountCredentials>(AccountCredentials));
+
+	return BaseIdentityInterface->Login(LocalUserNum, AccountCredentials);
+}
+
+void FOnlineUserEOSPlus::OnLoginChanged(int32 LocalUserNum)
+{
+	TriggerOnLoginChangedDelegates(LocalUserNum);
+}
+
+void FOnlineUserEOSPlus::OnEOSLoginChanged(int32 LocalUserNum)
+{
+	const FEOSSettings& EOSSettings = UEOSSettings::GetSettings();
+
+	if (!EOSSettings.bUseEAS && !EOSSettings.bUseEOSConnect)
+	{
+		return;
+	}
+
+	ELoginStatus::Type LoginStatus = EOSIdentityInterface->GetLoginStatus(LocalUserNum);
+	if (LoginStatus == ELoginStatus::LoggedIn)
+	{
+		TriggerOnLoginChangedDelegates(LocalUserNum);
+	}
+	else if (LoginStatus == ELoginStatus::NotLoggedIn)
+	{
+		// @todo joeg - should we force a logout of the platform? Things will be broken either way...
+		//		Logout(LocalUserNum);
+	}
+}
+
+void FOnlineUserEOSPlus::OnLoginStatusChanged(int32 LocalUserNum, ELoginStatus::Type OldStatus, ELoginStatus::Type NewStatus, const FUniqueNetId& NewId)
+{
+	TriggerOnLoginStatusChangedDelegates(LocalUserNum, OldStatus, NewStatus, NewId);
+}
+
+void FOnlineUserEOSPlus::OnControllerPairingChanged(int32 LocalUserNum, FControllerPairingChangedUserInfo PreviousUser, FControllerPairingChangedUserInfo NewUser)
+{
+	// @todo joeg - probably needs special handling here, though I think it should be covered by login change
+	TriggerOnControllerPairingChangedDelegates(LocalUserNum, PreviousUser, NewUser);
+}
+
+void FOnlineUserEOSPlus::OnLoginComplete(int32 LocalUserNum, bool bWasSuccessful, const FUniqueNetId& UserId, const FString& Error)
+{
+	if (!bWasSuccessful)
+	{
+		TriggerOnLoginCompleteDelegates(LocalUserNum, bWasSuccessful, UserId, Error);
+		return;
+	}
+
+	AddPlayer(LocalUserNum);
+	FUniqueNetIdEOSPlusPtr NetIdPlus = LocalUserNumToNetIdPlus[LocalUserNum];
+	check(NetIdPlus.IsValid());
+
+	TriggerOnLoginCompleteDelegates(LocalUserNum, bWasSuccessful, *NetIdPlus, Error);
+}
+
+void FOnlineUserEOSPlus::OnBaseLoginComplete(int32 LocalUserNum, bool bWasSuccessful, const FUniqueNetId& UserId, const FString& ErrorStr)
+{
+	if (!bWasSuccessful)
+	{
+		TriggerOnLoginCompleteDelegates(LocalUserNum, bWasSuccessful, UserId, ErrorStr);
+		return;
+	}
+
+	const FEOSSettings& EOSSettings = UEOSSettings::GetSettings();
+	const bool bForward = EOSSettings.bUseEAS || EOSSettings.bUseEOSConnect;
+	if (bForward)
+	{
+		check(LocalUserNumToLastLoginCredentials.Contains(LocalUserNum));
+		EOSIdentityInterface->Login(LocalUserNum, *LocalUserNumToLastLoginCredentials[LocalUserNum]);
+	}
+	else
+	{
+		AddPlayer(LocalUserNum);
+		TriggerOnLoginCompleteDelegates(LocalUserNum, bWasSuccessful, UserId, ErrorStr);
+	}
+}
+
+void FOnlineUserEOSPlus::OnLogoutComplete(int32 LocalUserNum, bool bWasSuccessful)
+{
+	// TODO: Make logout work the same way login does, triggering EOS after completion of Base
+	TriggerOnLogoutCompleteDelegates(LocalUserNum, bWasSuccessful);
+}
+
+void FOnlineUserEOSPlus::AddPlayer(int32 LocalUserNum)
+{
+	if (LocalUserNumToNetIdPlus.Contains(LocalUserNum))
+	{
+		RemovePlayer(LocalUserNum);
+	}
+
+	FUniqueNetIdPtr BaseNetId = BaseIdentityInterface->GetUniquePlayerId(LocalUserNum);
+	FUniqueNetIdPtr EOSNetId = EOSIdentityInterface->GetUniquePlayerId(LocalUserNum);
+	FUniqueNetIdEOSPlusPtr PlusNetId = FUniqueNetIdEOSPlus::Create(BaseNetId, EOSNetId);
+
+	BaseNetIdToNetIdPlus.Add(BaseNetId->ToString(), PlusNetId);
+	EOSNetIdToNetIdPlus.Add(EOSNetId->ToString(), PlusNetId);
+	NetIdPlusToBaseNetId.Add(PlusNetId->ToString(), BaseNetId);
+	NetIdPlusToEOSNetId.Add(PlusNetId->ToString(), EOSNetId);
+	NetIdPlusToNetIdPlus.Add(PlusNetId->ToString(), PlusNetId);
+	LocalUserNumToNetIdPlus.Add(LocalUserNum, PlusNetId);
+
+	// Add the local account
+	TSharedPtr<FUserOnlineAccount> BaseAccount = BaseIdentityInterface->GetUserAccount(*BaseNetId);
+	TSharedPtr<FUserOnlineAccount> EOSAccount = EOSIdentityInterface->GetUserAccount(*EOSNetId);
+	TSharedRef<FOnlineUserAccountPlus> PlusAccount = MakeShared<FOnlineUserAccountPlus>(BaseAccount, EOSAccount);
+	NetIdPlusToUserAccountMap.Add(PlusNetId->ToString(), PlusAccount);
+}
+
+FUniqueNetIdEOSPlusPtr FOnlineUserEOSPlus::AddRemotePlayer(FUniqueNetIdPtr BaseNetId, FUniqueNetIdPtr EOSNetId)
+{
+	FUniqueNetIdEOSPlusPtr PlusNetId = FUniqueNetIdEOSPlus::Create(BaseNetId, EOSNetId);
+
+	BaseNetIdToNetIdPlus.Add(BaseNetId->ToString(), PlusNetId);
+	EOSNetIdToNetIdPlus.Add(EOSNetId->ToString(), PlusNetId);
+	NetIdPlusToBaseNetId.Add(PlusNetId->ToString(), BaseNetId);
+	NetIdPlusToEOSNetId.Add(PlusNetId->ToString(), EOSNetId);
+	NetIdPlusToNetIdPlus.Add(PlusNetId->ToString(), PlusNetId);
+
+	return PlusNetId;
+}
+
+void FOnlineUserEOSPlus::RemovePlayer(int32 LocalUserNum)
+{
+	if (!LocalUserNumToNetIdPlus.Contains(LocalUserNum))
+	{
+		// We don't know about this user
+		return;
+	}
+
+	FUniqueNetIdPtr BaseNetId = BaseIdentityInterface->GetUniquePlayerId(LocalUserNum);
+	FUniqueNetIdPtr EOSNetId = EOSIdentityInterface->GetUniquePlayerId(LocalUserNum);
+	FUniqueNetIdEOSPlusPtr PlusNetId = LocalUserNumToNetIdPlus[LocalUserNum];
+
+	// Remove the user account first
+	TSharedPtr<FOnlineUserAccountPlus> PlusAccount = NetIdPlusToUserAccountMap[PlusNetId->ToString()];
+	NetIdPlusToUserAccountMap.Remove(PlusNetId->ToString());
+
+	// Clean up the net id caches
+	BaseNetIdToNetIdPlus.Remove(BaseNetId->ToString());
+	NetIdPlusToBaseNetId.Remove(PlusNetId->ToString());
+	EOSNetIdToNetIdPlus.Remove(EOSNetId->ToString());
+	NetIdPlusToEOSNetId.Remove(PlusNetId->ToString());
+	LocalUserNumToNetIdPlus.Remove(LocalUserNum);
+}
+
+bool FOnlineUserEOSPlus::Logout(int32 LocalUserNum)
+{
+	// Clean up the cached data for this user
+	RemovePlayer(LocalUserNum);
+
+	LocalUserNumToLastLoginCredentials.Remove(LocalUserNum);
+
+	EOSIdentityInterface->Logout(LocalUserNum);
+	return BaseIdentityInterface->Logout(LocalUserNum);
+}
+
+bool FOnlineUserEOSPlus::AutoLogin(int32 LocalUserNum)
+{
+	LocalUserNumToLastLoginCredentials.Emplace(LocalUserNum, MakeShared<FOnlineAccountCredentials>(FOnlineAccountCredentials()));
+
+	return BaseIdentityInterface->AutoLogin(LocalUserNum);
+}
+
+TSharedPtr<FUserOnlineAccount> FOnlineUserEOSPlus::GetUserAccount(const FUniqueNetId& UserId) const
+{
+	if (NetIdPlusToUserAccountMap.Contains(UserId.ToString()))
+	{
+		return NetIdPlusToUserAccountMap[UserId.ToString()];
+	}
+	return nullptr;
+}
+
+TArray<TSharedPtr<FUserOnlineAccount>> FOnlineUserEOSPlus::GetAllUserAccounts() const
+{
+	TArray<TSharedPtr<FUserOnlineAccount>> Result;
+
+	for (TMap<FString, TSharedRef<FOnlineUserAccountPlus>>::TConstIterator It(NetIdPlusToUserAccountMap); It; ++It)
+	{
+		Result.Add(It.Value());
+	}
+	return Result;
+}
+
+FUniqueNetIdPtr FOnlineUserEOSPlus::GetUniquePlayerId(int32 LocalUserNum) const
+{
+	if (LocalUserNumToNetIdPlus.Contains(LocalUserNum))
+	{
+		return LocalUserNumToNetIdPlus[LocalUserNum];
+	}
+	return nullptr;
+}
+
+FUniqueNetIdPtr FOnlineUserEOSPlus::CreateUniquePlayerId(uint8* Bytes, int32 Size)
+{
+	if (Size < EOS_NETID_BYTE_SIZE)
+	{
+		UE_LOG_ONLINE(Error, TEXT("Invalid size (%d) passed to FOnlineUserEOSPlus::CreateUniquePlayerId()"), Size);
+		return nullptr;
+	}
+	// We know that the first EOS_NETID_BYTE_SIZE bytes are the EOS ids, so the rest is the platform id
+	FUniqueNetIdPtr EOSNetId = EOSIdentityInterface->CreateUniquePlayerId(Bytes, EOS_NETID_BYTE_SIZE);
+	int32 BaseByteOffset = EOS_NETID_BYTE_SIZE;
+	int32 PlatformIdSize = Size - BaseByteOffset - BASE_NETID_TYPE_SIZE;
+	if (PlatformIdSize < 0)
+	{
+		UE_LOG_ONLINE(Error, TEXT("Invalid size (%d) passed to FOnlineUserEOSPlus::CreateUniquePlayerId()"), Size);
+		return nullptr;
+	}
+	uint8 OSSType = *(Bytes + BaseByteOffset);
+	BaseByteOffset += BASE_NETID_TYPE_SIZE;
+	FName OSSName = ToOSSName((EOSSValue)OSSType);
+	FName BaseOSSName = EOSPlus->BaseOSS->GetSubsystemName();
+	FUniqueNetIdPtr BaseNetId = nullptr;
+	if (BaseOSSName == OSSName)
+	{
+		BaseNetId = BaseIdentityInterface->CreateUniquePlayerId(Bytes + BaseByteOffset, PlatformIdSize);
+	}
+	else
+	{
+		// Just create the pass through version that holds the other platform data but doesn't interpret it
+		BaseNetId = FUniqueNetIdBinary::Create(Bytes + BaseByteOffset, PlatformIdSize, OSSName);
+	}
+	
+	return AddRemotePlayer(BaseNetId, EOSNetId);
+}
+
+FUniqueNetIdPtr FOnlineUserEOSPlus::CreateUniquePlayerId(const FString& Str)
+{
+	// Split <id>_+_<id2> into two strings
+	int32 FoundAt = Str.Find(TEXT("_+_"));
+	if (FoundAt == -1)
+	{
+		UE_LOG_ONLINE(Error, TEXT("Couldn't parse string (%s) passed to FOnlineUserEOSPlus::CreateUniquePlayerId()"), *Str);
+		return nullptr;
+	}
+
+	FUniqueNetIdPtr BaseNetId = BaseIdentityInterface->CreateUniquePlayerId(Str.Left(FoundAt));
+	FUniqueNetIdPtr EOSNetId = EOSIdentityInterface->CreateUniquePlayerId(Str.Right(Str.Len() - FoundAt - 3));
+
+	return AddRemotePlayer(BaseNetId, EOSNetId);
+}
+
+ELoginStatus::Type FOnlineUserEOSPlus::GetLoginStatus(int32 LocalUserNum) const
+{
+	return EOSIdentityInterface->GetLoginStatus(LocalUserNum);
+}
+
+ELoginStatus::Type FOnlineUserEOSPlus::GetLoginStatus(const FUniqueNetId& UserId) const
+{
+	FUniqueNetIdEOSPlusPtr NetIdPlus = GetNetIdPlus(UserId.ToString());
+	if (!NetIdPlus.IsValid())
+	{
+		UE_LOG_ONLINE(Error, TEXT("[FOnlineUserEOSPlus::GetLoginStatus] NetIdPlus not found for UserId %s"), *UserId.ToString());
+		return ELoginStatus::NotLoggedIn;
+	}
+
+	return EOSIdentityInterface->GetLoginStatus(*NetIdPlus->GetEOSNetId());
+}
+
+FString FOnlineUserEOSPlus::GetPlayerNickname(int32 LocalUserNum) const
+{
+	return BaseIdentityInterface->GetPlayerNickname(LocalUserNum);
+}
+
+FString FOnlineUserEOSPlus::GetPlayerNickname(const FUniqueNetId& UserId) const
+{
+	FString Result;
+
+	FUniqueNetIdEOSPlusPtr NetIdPlus = GetNetIdPlus(UserId.ToString());
+	if (NetIdPlus.IsValid())
+	{
+		// Do we wrap this and map or pass through or aggregate and pass through?
+		Result = BaseIdentityInterface->GetPlayerNickname(*NetIdPlus->GetBaseNetId());
+	}
+	else
+	{
+		UE_LOG_ONLINE(Warning, TEXT("[FOnlineUserEOSPlus::GetPlayerNickname] User not found (%s)"), *UserId.ToString());
+	}
+
+	return Result;
+}
+
+FString FOnlineUserEOSPlus::GetAuthToken(int32 LocalUserNum) const
+{
+	return BaseIdentityInterface->GetAuthToken(LocalUserNum);
+}
+
+void FOnlineUserEOSPlus::GetUserPrivilege(const FUniqueNetId& UserId, EUserPrivileges::Type Privilege, const FOnGetUserPrivilegeCompleteDelegate& Delegate)
+{
+	FUniqueNetIdEOSPlusPtr NetIdPlus = GetNetIdPlus(UserId.ToString());
+	if (NetIdPlus.IsValid())
+	{
+		FOnGetUserPrivilegeCompleteDelegate IntermediateDelegate = FOnGetUserPrivilegeCompleteDelegate::CreateLambda([this, OriginalDelegate = FOnGetUserPrivilegeCompleteDelegate(Delegate)](const FUniqueNetId& UserId, EUserPrivileges::Type Privilege, uint32 PrivilegeResults)
+		{
+			FUniqueNetIdEOSPlusPtr NetIdPlus = GetNetIdPlus(UserId.ToString());
+			if (!NetIdPlus.IsValid())
+			{
+				UE_LOG_ONLINE(Warning, TEXT("[FOnlineUserEOSPlus::GetUserPrivilege] User not found (%s)"), *UserId.ToString());
+			}
+
+			OriginalDelegate.ExecuteIfBound(*NetIdPlus, Privilege, PrivilegeResults);
+		});
+
+		BaseIdentityInterface->GetUserPrivilege(*NetIdPlus->GetBaseNetId(), Privilege, IntermediateDelegate);
+	}
+	else
+	{
+		UE_LOG_ONLINE(Error, TEXT("[FOnlineUserEOSPlus::GetUserPrivilege] NetIdPlus not found for UserId %s"), *UserId.ToString());
+	}
+}
+
+FString FOnlineUserEOSPlus::GetAuthType() const
+{
+	return BaseIdentityInterface->GetAuthType();
+}
+
+void FOnlineUserEOSPlus::RevokeAuthToken(const FUniqueNetId& LocalUserId, const FOnRevokeAuthTokenCompleteDelegate& Delegate)
+{
+	BaseIdentityInterface->RevokeAuthToken(LocalUserId, Delegate);
+}
+
+FPlatformUserId FOnlineUserEOSPlus::GetPlatformUserIdFromUniqueNetId(const FUniqueNetId& UniqueNetId) const
+{
+	if (BaseNetIdToNetIdPlus.Contains(UniqueNetId.ToString()))
+	{
+		return BaseIdentityInterface->GetPlatformUserIdFromUniqueNetId(UniqueNetId);
+	}
+	if (NetIdPlusToBaseNetId.Contains(UniqueNetId.ToString()))
+	{
+		return BaseIdentityInterface->GetPlatformUserIdFromUniqueNetId(*NetIdPlusToBaseNetId[UniqueNetId.ToString()]);
+	}
+	return FPlatformUserId();
+}
+
+void FOnlineUserEOSPlus::GetLinkedAccountAuthToken(int32 LocalUserNum, const FOnGetLinkedAccountAuthTokenCompleteDelegate& Delegate) const
+{
+	// Pass through to the platform layer
+	BaseIdentityInterface->GetLinkedAccountAuthToken(LocalUserNum, Delegate);
+}
+
+void FOnlineUserEOSPlus::OnFriendsChanged()
+{
+	for (int32 LocalUserNum = 0; LocalUserNum < MAX_LOCAL_PLAYERS; LocalUserNum++)
+	{
+		TriggerOnFriendsChangeDelegates(LocalUserNum);
+	}
+}
+
+void FOnlineUserEOSPlus::OnOutgoingInviteSent()
+{
+	for (int32 LocalUserNum = 0; LocalUserNum < MAX_LOCAL_PLAYERS; LocalUserNum++)
+	{
+		TriggerOnOutgoingInviteSentDelegates(LocalUserNum);
+	}
+}
+
+void FOnlineUserEOSPlus::OnInviteReceived(const FUniqueNetId& UserId, const FUniqueNetId& FriendId)
+{
+	FUniqueNetIdEOSPlusPtr NetIdPlus = GetNetIdPlus(UserId.ToString());
+	if (!NetIdPlus.IsValid())
+	{
+		return;
+	}
+	FUniqueNetIdEOSPlusPtr FriendNetIdPlus = GetNetIdPlus(FriendId.ToString());
+	if (!FriendNetIdPlus.IsValid())
+	{
+		return;
+	}
+	TriggerOnInviteReceivedDelegates(*NetIdPlus, *FriendNetIdPlus);
+}
+
+void FOnlineUserEOSPlus::OnInviteAccepted(const FUniqueNetId& UserId, const FUniqueNetId& FriendId)
+{
+	FUniqueNetIdEOSPlusPtr NetIdPlus = GetNetIdPlus(UserId.ToString());
+	if (!NetIdPlus.IsValid())
+	{
+		return;
+	}
+	FUniqueNetIdEOSPlusPtr FriendNetIdPlus = GetNetIdPlus(FriendId.ToString());
+	if (!FriendNetIdPlus.IsValid())
+	{
+		return;
+	}
+	TriggerOnInviteAcceptedDelegates(UserId, FriendId);
+}
+
+void FOnlineUserEOSPlus::OnInviteRejected(const FUniqueNetId& UserId, const FUniqueNetId& FriendId)
+{
+	FUniqueNetIdEOSPlusPtr NetIdPlus = GetNetIdPlus(UserId.ToString());
+	if (!NetIdPlus.IsValid())
+	{
+		return;
+	}
+	FUniqueNetIdEOSPlusPtr FriendNetIdPlus = GetNetIdPlus(FriendId.ToString());
+	if (!FriendNetIdPlus.IsValid())
+	{
+		return;
+	}
+	TriggerOnInviteRejectedDelegates(*NetIdPlus, *FriendNetIdPlus);
+}
+
+void FOnlineUserEOSPlus::OnInviteAborted(const FUniqueNetId& UserId, const FUniqueNetId& FriendId)
+{
+	FUniqueNetIdEOSPlusPtr NetIdPlus = GetNetIdPlus(UserId.ToString());
+	if (!NetIdPlus.IsValid())
+	{
+		return;
+	}
+	FUniqueNetIdEOSPlusPtr FriendNetIdPlus = GetNetIdPlus(FriendId.ToString());
+	if (!FriendNetIdPlus.IsValid())
+	{
+		return;
+	}
+	TriggerOnInviteAbortedDelegates(*NetIdPlus, *FriendNetIdPlus);
+}
+
+void FOnlineUserEOSPlus::OnFriendRemoved(const FUniqueNetId& UserId, const FUniqueNetId& FriendId)
+{
+	FUniqueNetIdEOSPlusPtr NetIdPlus = GetNetIdPlus(UserId.ToString());
+	if (!NetIdPlus.IsValid())
+	{
+		return;
+	}
+	FUniqueNetIdEOSPlusPtr FriendNetIdPlus = GetNetIdPlus(FriendId.ToString());
+	if (!FriendNetIdPlus.IsValid())
+	{
+		return;
+	}
+	TriggerOnFriendRemovedDelegates(*NetIdPlus, *FriendNetIdPlus);
+}
+
+bool FOnlineUserEOSPlus::ReadFriendsList(int32 LocalUserNum, const FString& ListName, const FOnReadFriendsListComplete& Delegate)
+{
+	return BaseFriendsInterface->ReadFriendsList(LocalUserNum, ListName,
+		FOnReadFriendsListComplete::CreateLambda([this, IntermediateComplete = FOnReadFriendsListComplete(Delegate)](int32 LocalUserNum, bool bWasSuccessful, const FString& ListName, const FString& ErrorStr)
+	{
+		// Skip reading EAS if not in use and if we errored at the platform level
+		if (!UEOSSettings::GetSettings().bUseEAS || !bWasSuccessful)
+		{
+			IntermediateComplete.ExecuteIfBound(LocalUserNum, bWasSuccessful, ListName, ErrorStr);
+			return;
+		}
+		// Read the EAS version too
+		EOSFriendsInterface->ReadFriendsList(LocalUserNum, ListName,
+			FOnReadFriendsListComplete::CreateLambda([this, OnComplete = FOnReadFriendsListComplete(IntermediateComplete)](int32 LocalUserNum, bool bWasSuccessful, const FString& ListName, const FString& ErrorStr)
+		{
+			OnComplete.ExecuteIfBound(LocalUserNum, bWasSuccessful, ListName, ErrorStr);
+		}));
+	}));
+}
+
+bool FOnlineUserEOSPlus::DeleteFriendsList(int32 LocalUserNum, const FString& ListName, const FOnDeleteFriendsListComplete& Delegate)
+{
+	return BaseFriendsInterface->DeleteFriendsList(LocalUserNum, ListName, Delegate);
+}
+
+bool FOnlineUserEOSPlus::SendInvite(int32 LocalUserNum, const FUniqueNetId& FriendId, const FString& ListName, const FOnSendInviteComplete& Delegate)
+{
+	if (!NetIdPlusToBaseNetId.Contains(FriendId.ToString()))
+	{
+		return false;
+	}
+	return BaseFriendsInterface->SendInvite(LocalUserNum, *NetIdPlusToBaseNetId[FriendId.ToString()], ListName, Delegate);
+}
+
+bool FOnlineUserEOSPlus::AcceptInvite(int32 LocalUserNum, const FUniqueNetId& FriendId, const FString& ListName, const FOnAcceptInviteComplete& Delegate)
+{
+	if (!NetIdPlusToBaseNetId.Contains(FriendId.ToString()))
+	{
+		return false;
+	}
+	return BaseFriendsInterface->AcceptInvite(LocalUserNum, *NetIdPlusToBaseNetId[FriendId.ToString()], ListName, Delegate);
+}
+
+bool FOnlineUserEOSPlus::RejectInvite(int32 LocalUserNum, const FUniqueNetId& FriendId, const FString& ListName)
+{
+	if (!NetIdPlusToBaseNetId.Contains(FriendId.ToString()))
+	{
+		return false;
+	}
+	return BaseFriendsInterface->RejectInvite(LocalUserNum, *NetIdPlusToBaseNetId[FriendId.ToString()], ListName);
+}
+
+bool FOnlineUserEOSPlus::DeleteFriend(int32 LocalUserNum, const FUniqueNetId& FriendId, const FString& ListName)
+{
+	if (!NetIdPlusToBaseNetId.Contains(FriendId.ToString()))
+	{
+		return false;
+	}
+	return BaseFriendsInterface->DeleteFriend(LocalUserNum, *NetIdPlusToBaseNetId[FriendId.ToString()], ListName);
+}
+
+TSharedRef<FOnlineFriendPlus> FOnlineUserEOSPlus::AddFriend(TSharedRef<FOnlineFriend> Friend)
+{
+	FUniqueNetIdEOSPlusPtr NetIdPlus = nullptr;
+	FUniqueNetIdRef NetId = Friend->GetUserId();
+	if (NetId->GetType() == TEXT("EOS"))
+	{
+		// Grab or make a NetIdPlus
+		if (EOSNetIdToNetIdPlus.Contains(NetId->ToString()))
+		{
+			NetIdPlus = EOSNetIdToNetIdPlus[NetId->ToString()];
+		}
+		else
+		{
+			NetIdPlus = FUniqueNetIdEOSPlus::Create(nullptr, NetId);
+			EOSNetIdToNetIdPlus.Add(NetId->ToString(), NetIdPlus);
+
+			if (!NetIdPlusToNetIdPlus.Contains(NetIdPlus->ToString()))
+			{
+				NetIdPlusToNetIdPlus.Add(NetIdPlus->ToString(), NetIdPlus);
+			}
+		}
+		// Build a new friend plus and map them in
+		TSharedRef<FOnlineFriendPlus> FriendPlus = MakeShared<FOnlineFriendPlus>(nullptr, Friend);
+		NetIdPlusToFriendMap.Add(NetIdPlus->ToString(), FriendPlus);
+		return FriendPlus;
+	}
+	// Grab or make a NetIdPlus
+	if (BaseNetIdToNetIdPlus.Contains(NetId->ToString()))
+	{
+		NetIdPlus = BaseNetIdToNetIdPlus[NetId->ToString()];
+	}
+	else
+	{
+		NetIdPlus = FUniqueNetIdEOSPlus::Create(NetId, nullptr);
+		BaseNetIdToNetIdPlus.Add(NetId->ToString(), NetIdPlus);
+
+		if (!NetIdPlusToNetIdPlus.Contains(NetIdPlus->ToString()))
+		{
+			NetIdPlusToNetIdPlus.Add(NetIdPlus->ToString(), NetIdPlus);
+		}
+	}
+	// Build a new friend plus and map them in
+	TSharedRef<FOnlineFriendPlus> FriendPlus = MakeShared<FOnlineFriendPlus>(Friend, nullptr);
+	NetIdPlusToFriendMap.Add(NetIdPlus->ToString(), FriendPlus);
+	return FriendPlus;
+}
+
+TSharedRef<FOnlineFriendPlus> FOnlineUserEOSPlus::GetFriend(TSharedRef<FOnlineFriend> Friend)
+{
+	FUniqueNetIdRef NetId = Friend->GetUserId();
+	if (NetIdPlusToFriendMap.Contains(NetId->ToString()))
+	{
+		return NetIdPlusToFriendMap[NetId->ToString()];
+	}
+	return AddFriend(Friend);
+}
+
+bool FOnlineUserEOSPlus::GetFriendsList(int32 LocalUserNum, const FString& ListName, TArray<TSharedRef<FOnlineFriend>>& OutFriends)
+{
+	OutFriends.Reset();
+
+	TArray<TSharedRef<FOnlineFriend>> Friends;
+	bool bWasSuccessful = BaseFriendsInterface->GetFriendsList(LocalUserNum, ListName, Friends);
+	// Build the list of base friends
+	for (TSharedRef<FOnlineFriend> Friend : Friends)
+	{
+		OutFriends.Add(GetFriend(Friend));
+	}
+
+	if (UEOSSettings::GetSettings().bUseEAS)
+	{
+		Friends.Reset();
+		bWasSuccessful |= EOSFriendsInterface->GetFriendsList(LocalUserNum, ListName, Friends);
+		// Build the list of EOS friends
+		for (TSharedRef<FOnlineFriend> Friend : Friends)
+		{
+			OutFriends.Add(GetFriend(Friend));
+		}
+	}
+	return bWasSuccessful;
+}
+
+TSharedPtr<FOnlineFriend> FOnlineUserEOSPlus::GetFriend(int32 LocalUserNum, const FUniqueNetId& FriendId, const FString& ListName)
+{
+	if (!NetIdPlusToFriendMap.Num())
+	{
+		TArray<TSharedRef<FOnlineFriend>> Friends;
+		GetFriendsList(LocalUserNum, ListName, Friends);
+	}
+
+	if (FriendId.GetType() == TEXT("EOS"))
+	{
+		TSharedPtr<FOnlineFriend> Friend = EOSFriendsInterface->GetFriend(LocalUserNum, *NetIdPlusToBaseNetId[FriendId.ToString()], ListName);
+		return Friend.IsValid() ? GetFriend(Friend.ToSharedRef()) : Friend;
+	}
+
+	TSharedPtr<FOnlineFriend> Friend = EOSFriendsInterface->GetFriend(LocalUserNum, *NetIdPlusToBaseNetId[FriendId.ToString()], ListName);
+	if (Friend.IsValid())
+	{
+		return GetFriend(Friend.ToSharedRef());
+	}
+	return nullptr;
+}
+
+bool FOnlineUserEOSPlus::IsFriend(int32 LocalUserNum, const FUniqueNetId& FriendId, const FString& ListName)
+{
+	bool bIsFriend = false;
+	if (NetIdPlusToBaseNetId.Contains(FriendId.ToString()))
+	{
+		bIsFriend = BaseFriendsInterface->IsFriend(LocalUserNum, *NetIdPlusToBaseNetId[FriendId.ToString()], ListName);
+	}
+	if (!bIsFriend && UEOSSettings::GetSettings().bUseEAS && NetIdPlusToEOSNetId.Contains(FriendId.ToString()))
+	{
+		bIsFriend = EOSFriendsInterface->IsFriend(LocalUserNum, *NetIdPlusToEOSNetId[FriendId.ToString()], ListName);
+	}
+	return bIsFriend;
+}
+
+bool FOnlineUserEOSPlus::QueryRecentPlayers(const FUniqueNetId& UserId, const FString& Namespace)
+{
+	if (!NetIdPlusToBaseNetId.Contains(UserId.ToString()))
+	{
+		return false;
+	}
+	return BaseFriendsInterface->QueryRecentPlayers(*NetIdPlusToBaseNetId[UserId.ToString()], Namespace);
+}
+
+TSharedRef<FOnlineRecentPlayer> FOnlineUserEOSPlus::AddRecentPlayer(TSharedRef<FOnlineRecentPlayer> Player)
+{
+	FUniqueNetIdEOSPlusPtr NetIdPlus = nullptr;
+	FUniqueNetIdRef NetId = Player->GetUserId();
+	if (NetId->GetType() == TEXT("EOS"))
+	{
+		// Grab or make a NetIdPlus
+		if (EOSNetIdToNetIdPlus.Contains(NetId->ToString()))
+		{
+			NetIdPlus = EOSNetIdToNetIdPlus[NetId->ToString()];
+		}
+		else
+		{
+			NetIdPlus = FUniqueNetIdEOSPlus::Create(nullptr, NetId);
+			EOSNetIdToNetIdPlus.Add(NetId->ToString(), NetIdPlus);
+		}
+		// Build a new recent player plus and map them in
+		TSharedRef<FOnlineRecentPlayerPlus> PlayerPlus = MakeShared<FOnlineRecentPlayerPlus>(nullptr, Player);
+		NetIdPlusToRecentPlayerMap.Add(NetIdPlus->ToString(), PlayerPlus);
+		return PlayerPlus;
+	}
+	// Grab or make a NetIdPlus
+	if (BaseNetIdToNetIdPlus.Contains(NetId->ToString()))
+	{
+		NetIdPlus = BaseNetIdToNetIdPlus[NetId->ToString()];
+	}
+	else
+	{
+		NetIdPlus = FUniqueNetIdEOSPlus::Create(NetId, nullptr);
+		BaseNetIdToNetIdPlus.Add(NetId->ToString(), NetIdPlus);
+	}
+	// Build a new recent player plus and map them in
+	TSharedRef<FOnlineRecentPlayerPlus> PlayerPlus = MakeShared<FOnlineRecentPlayerPlus>(Player, nullptr);
+	NetIdPlusToRecentPlayerMap.Add(NetIdPlus->ToString(), PlayerPlus);
+	return PlayerPlus;
+}
+
+TSharedRef<FOnlineRecentPlayer> FOnlineUserEOSPlus::GetRecentPlayer(TSharedRef<FOnlineRecentPlayer> Player)
+{
+	FUniqueNetIdRef NetId = Player->GetUserId();
+	if (NetIdPlusToRecentPlayerMap.Contains(NetId->ToString()))
+	{
+		return NetIdPlusToRecentPlayerMap[NetId->ToString()];
+	}
+	return AddRecentPlayer(Player);
+}
+
+bool FOnlineUserEOSPlus::GetRecentPlayers(const FUniqueNetId& UserId, const FString& Namespace, TArray<TSharedRef<FOnlineRecentPlayer>>& OutRecentPlayers)
+{
+	OutRecentPlayers.Reset();
+
+	if (!NetIdPlusToBaseNetId.Contains(UserId.ToString()))
+	{
+		return false;
+	}
+
+	TArray<TSharedRef<FOnlineRecentPlayer>> Players;
+	bool bWasSuccessful = BaseFriendsInterface->GetRecentPlayers(*NetIdPlusToBaseNetId[UserId.ToString()], Namespace, Players);
+	for (TSharedRef<FOnlineRecentPlayer> Player : Players)
+	{
+		OutRecentPlayers.Add(GetRecentPlayer(Player));
+	}
+
+	return bWasSuccessful;
+}
+
+bool FOnlineUserEOSPlus::BlockPlayer(int32 LocalUserNum, const FUniqueNetId& PlayerId)
+{
+	if (!NetIdPlusToBaseNetId.Contains(PlayerId.ToString()))
+	{
+		return false;
+	}
+	return BaseFriendsInterface->BlockPlayer(LocalUserNum, *NetIdPlusToBaseNetId[PlayerId.ToString()]);
+}
+
+bool FOnlineUserEOSPlus::UnblockPlayer(int32 LocalUserNum, const FUniqueNetId& PlayerId)
+{
+	if (!NetIdPlusToBaseNetId.Contains(PlayerId.ToString()))
+	{
+		return false;
+	}
+	return BaseFriendsInterface->UnblockPlayer(LocalUserNum, *NetIdPlusToBaseNetId[PlayerId.ToString()]);
+}
+
+bool FOnlineUserEOSPlus::QueryBlockedPlayers(const FUniqueNetId& UserId)
+{
+	if (!NetIdPlusToBaseNetId.Contains(UserId.ToString()))
+	{
+		return false;
+	}
+	return BaseFriendsInterface->QueryBlockedPlayers(*NetIdPlusToBaseNetId[UserId.ToString()]);
+}
+
+TSharedRef<FOnlineBlockedPlayer> FOnlineUserEOSPlus::AddBlockedPlayer(TSharedRef<FOnlineBlockedPlayer> Player)
+{
+	FUniqueNetIdEOSPlusPtr NetIdPlus = nullptr;
+	FUniqueNetIdRef NetId = Player->GetUserId();
+	if (NetId->GetType() == TEXT("EOS"))
+	{
+		if (EOSNetIdToNetIdPlus.Contains(NetId->ToString()))
+		{
+			NetIdPlus = EOSNetIdToNetIdPlus[NetId->ToString()];
+		}
+		else
+		{
+			NetIdPlus = FUniqueNetIdEOSPlus::Create(nullptr, NetId);
+			EOSNetIdToNetIdPlus.Add(NetId->ToString(), NetIdPlus);
+		}
+		TSharedRef<FOnlineBlockedPlayerPlus> PlayerPlus = MakeShared<FOnlineBlockedPlayerPlus>(nullptr, Player);
+		NetIdPlusToBlockedPlayerMap.Add(NetIdPlus->ToString(), PlayerPlus);
+		return PlayerPlus;
+	}
+	if (BaseNetIdToNetIdPlus.Contains(NetId->ToString()))
+	{
+		NetIdPlus = BaseNetIdToNetIdPlus[NetId->ToString()];
+	}
+	else
+	{
+		NetIdPlus = FUniqueNetIdEOSPlus::Create(NetId, nullptr);
+		BaseNetIdToNetIdPlus.Add(NetId->ToString(), NetIdPlus);
+	}
+	TSharedRef<FOnlineBlockedPlayerPlus> PlayerPlus = MakeShared<FOnlineBlockedPlayerPlus>(Player, nullptr);
+	NetIdPlusToBlockedPlayerMap.Add(NetIdPlus->ToString(), PlayerPlus);
+	return PlayerPlus;
+}
+
+TSharedRef<FOnlineBlockedPlayer> FOnlineUserEOSPlus::GetBlockedPlayer(TSharedRef<FOnlineBlockedPlayer> Player)
+{
+	FUniqueNetIdRef NetId = Player->GetUserId();
+	if (NetIdPlusToBlockedPlayerMap.Contains(NetId->ToString()))
+	{
+		return NetIdPlusToBlockedPlayerMap[NetId->ToString()];
+	}
+	return AddBlockedPlayer(Player);
+}
+
+bool FOnlineUserEOSPlus::GetBlockedPlayers(const FUniqueNetId& UserId, TArray< TSharedRef<FOnlineBlockedPlayer> >& OutBlockedPlayers)
+{
+	OutBlockedPlayers.Reset();
+
+	if (!NetIdPlusToBaseNetId.Contains(UserId.ToString()))
+	{
+		return false;
+	}
+
+	TArray<TSharedRef<FOnlineBlockedPlayer>> Players;
+	bool bWasSuccessful = BaseFriendsInterface->GetBlockedPlayers(*NetIdPlusToBaseNetId[UserId.ToString()], Players);
+	for (TSharedRef<FOnlineBlockedPlayer> Player : Players)
+	{
+		OutBlockedPlayers.Add(GetBlockedPlayer(Player));
+	}
+	return bWasSuccessful;
+}
+
+void FOnlineUserEOSPlus::DumpBlockedPlayers() const
+{
+	BaseFriendsInterface->DumpBlockedPlayers();
+	EOSFriendsInterface->DumpBlockedPlayers();
+}
+
+void FOnlineUserEOSPlus::SetFriendAlias(int32 LocalUserNum, const FUniqueNetId& FriendId, const FString& ListName, const FString& Alias, const FOnSetFriendAliasComplete& Delegate)
+{
+	if (NetIdPlusToBaseNetId.Contains(FriendId.ToString()))
+	{
+		BaseFriendsInterface->SetFriendAlias(LocalUserNum, *NetIdPlusToBaseNetId[FriendId.ToString()], ListName, Alias, Delegate);
+		return;
+	}
+	if (NetIdPlusToEOSNetId.Contains(FriendId.ToString()))
+	{
+		EOSFriendsInterface->SetFriendAlias(LocalUserNum, *NetIdPlusToEOSNetId[FriendId.ToString()], ListName, Alias, Delegate);
+		return;
+	}
+	Delegate.ExecuteIfBound(LocalUserNum, FriendId, ListName, FOnlineError(false));
+}
+
+void FOnlineUserEOSPlus::DeleteFriendAlias(int32 LocalUserNum, const FUniqueNetId& FriendId, const FString& ListName, const FOnDeleteFriendAliasComplete& Delegate)
+{
+	if (NetIdPlusToBaseNetId.Contains(FriendId.ToString()))
+	{
+		BaseFriendsInterface->DeleteFriendAlias(LocalUserNum, *NetIdPlusToBaseNetId[FriendId.ToString()], ListName, Delegate);
+		return;
+	}
+	if (NetIdPlusToEOSNetId.Contains(FriendId.ToString()))
+	{
+		EOSFriendsInterface->DeleteFriendAlias(LocalUserNum, *NetIdPlusToEOSNetId[FriendId.ToString()], ListName, Delegate);
+		return;
+	}
+	Delegate.ExecuteIfBound(LocalUserNum, FriendId, ListName, FOnlineError(false));
+}
+
+void FOnlineUserEOSPlus::DumpRecentPlayers() const
+{
+	BaseFriendsInterface->DumpRecentPlayers();
+	EOSFriendsInterface->DumpRecentPlayers();
+}
+
+void FOnlineUserEOSPlus::OnPresenceReceived(const FUniqueNetId& UserId, const TSharedRef<FOnlineUserPresence>& Presence)
+{
+	if (!BaseNetIdToNetIdPlus.Contains(UserId.ToString()))
+	{
+		return;
+	}
+	TriggerOnPresenceReceivedDelegates(*BaseNetIdToNetIdPlus[UserId.ToString()], Presence);
+}
+
+void FOnlineUserEOSPlus::OnPresenceArrayUpdated(const FUniqueNetId& UserId, const TArray<TSharedRef<FOnlineUserPresence>>& NewPresenceArray)
+{
+	if (!BaseNetIdToNetIdPlus.Contains(UserId.ToString()))
+	{
+		return;
+	}
+	TriggerOnPresenceArrayUpdatedDelegates(*BaseNetIdToNetIdPlus[UserId.ToString()], NewPresenceArray);
+}
+
+void FOnlineUserEOSPlus::SetPresence(const FUniqueNetId& User, const FOnlineUserPresenceStatus& Status, const FOnPresenceTaskCompleteDelegate& Delegate)
+{
+	const FUniqueNetIdEOSPlusPtr NetIdPlus = GetNetIdPlus(User.ToString());
+	if (!NetIdPlus.IsValid())
+	{
+		UE_LOG_ONLINE(Error, TEXT("Failed to find user (%s) in net id plus to base net id map"), *User.ToString());
+		Delegate.ExecuteIfBound(User, false);
+		return;
+	}
+	BasePresenceInterface->SetPresence(*NetIdPlus->GetBaseNetId(), Status,
+		FOnPresenceTaskCompleteDelegate::CreateLambda([this, NetIdPlus, StatusCopy = FOnlineUserPresenceStatus(Status), IntermediateComplete = FOnPresenceTaskCompleteDelegate(Delegate)](const FUniqueNetId& UserId, const bool bWasSuccessful)
+	{
+		// Skip setting EAS presence if not mirrored or if we errored at the platform level or the EOS user isn't found
+		if (!bWasSuccessful || !NetIdPlus->GetEOSNetId().IsValid() || !UEOSSettings::GetSettings().bMirrorPresenceToEAS)
+		{
+			IntermediateComplete.ExecuteIfBound(UserId, bWasSuccessful);
+			return;
+		}
+		// Set the EAS version too
+		EOSPresenceInterface->SetPresence(*NetIdPlus->GetEOSNetId(), StatusCopy,
+			FOnPresenceTaskCompleteDelegate::CreateLambda([this, OnComplete = FOnPresenceTaskCompleteDelegate(IntermediateComplete)](const FUniqueNetId& UserId, const bool bWasSuccessful)
+		{
+			// The platform one is the one that matters so if we get here we succeeded earlier
+			OnComplete.ExecuteIfBound(UserId, true);
+		}));
+	}));
+}
+
+void FOnlineUserEOSPlus::QueryPresence(const FUniqueNetId& User, const FOnPresenceTaskCompleteDelegate& Delegate)
+{
+	if (!NetIdPlusToBaseNetId.Contains(User.ToString()))
+	{
+		Delegate.ExecuteIfBound(User, false);
+		return;
+	}
+	BasePresenceInterface->QueryPresence(*NetIdPlusToBaseNetId[User.ToString()], Delegate);
+}
+
+EOnlineCachedResult::Type FOnlineUserEOSPlus::GetCachedPresence(const FUniqueNetId& User, TSharedPtr<FOnlineUserPresence>& OutPresence)
+{
+	if (!NetIdPlusToBaseNetId.Contains(User.ToString()))
+	{
+		return EOnlineCachedResult::NotFound;
+	}
+	return BasePresenceInterface->GetCachedPresence(*NetIdPlusToBaseNetId[User.ToString()], OutPresence);
+}
+
+EOnlineCachedResult::Type FOnlineUserEOSPlus::GetCachedPresenceForApp(const FUniqueNetId& LocalUserId, const FUniqueNetId& User, const FString& AppId, TSharedPtr<FOnlineUserPresence>& OutPresence)
+{
+	if (!NetIdPlusToBaseNetId.Contains(LocalUserId.ToString()) || !NetIdPlusToBaseNetId.Contains(User.ToString()))
+	{
+		return EOnlineCachedResult::NotFound;
+	}
+	return BasePresenceInterface->GetCachedPresenceForApp(*NetIdPlusToBaseNetId[LocalUserId.ToString()], *NetIdPlusToBaseNetId[User.ToString()], AppId, OutPresence);
+}
Index: Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOSPlus/Private/OnlineAchievementsEOSPlus.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOSPlus/Private/OnlineAchievementsEOSPlus.h b/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOSPlus/Private/OnlineAchievementsEOSPlus.h
new file mode 100644
--- /dev/null	(date 1641576012000)
+++ b/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOSPlus/Private/OnlineAchievementsEOSPlus.h	(date 1641576012000)
@@ -0,0 +1,50 @@
+// Copyright Epic Games, Inc. All Rights Reserved.
+
+#pragma once
+
+#include "CoreMinimal.h"
+#include "Online/CoreOnline.h"
+#include "OnlineSubsystem.h"
+#include "Interfaces/OnlineAchievementsInterface.h"
+#include "OnlineUserEOSPlus.h"
+
+class FOnlineSubsystemEOSPlus;
+
+/**
+ * Interface for mirroring platform achievements to EOS achievements
+ */
+class FOnlineAchievementsEOSPlus :
+	public IOnlineAchievements
+{
+public:
+	FOnlineAchievementsEOSPlus() = delete;
+	virtual ~FOnlineAchievementsEOSPlus();
+
+// IOnlineAchievements Interface
+	virtual void WriteAchievements(const FUniqueNetId& PlayerId, FOnlineAchievementsWriteRef& WriteObject, const FOnAchievementsWrittenDelegate& Delegate = FOnAchievementsWrittenDelegate())  override;
+	virtual void QueryAchievements(const FUniqueNetId& PlayerId, const FOnQueryAchievementsCompleteDelegate& Delegate = FOnQueryAchievementsCompleteDelegate())  override;
+	virtual void QueryAchievementDescriptions(const FUniqueNetId& PlayerId, const FOnQueryAchievementsCompleteDelegate& Delegate = FOnQueryAchievementsCompleteDelegate())  override;
+	virtual EOnlineCachedResult::Type GetCachedAchievement(const FUniqueNetId& PlayerId, const FString& AchievementId, FOnlineAchievement& OutAchievement)  override;
+	virtual EOnlineCachedResult::Type GetCachedAchievements(const FUniqueNetId& PlayerId, TArray<FOnlineAchievement>& OutAchievements)  override;
+	virtual EOnlineCachedResult::Type GetCachedAchievementDescription(const FString& AchievementId, FOnlineAchievementDesc& OutAchievementDesc)  override;
+#if !UE_BUILD_SHIPPING
+	virtual bool ResetAchievements(const FUniqueNetId& PlayerId) override;
+#endif
+// ~IOnlineAchievements Interface
+
+PACKAGE_SCOPE:
+	FOnlineAchievementsEOSPlus(FOnlineSubsystemEOSPlus* InSubsystem);
+
+	void OnAchievementUnlocked(const FUniqueNetId& PlayerId, const FString& AchievementId);
+
+private:
+	FUniqueNetIdEOSPlusPtr GetNetIdPlus(const FString& SourceId);
+
+	/** Reference to the owning EOS plus subsystem */
+	FOnlineSubsystemEOSPlus* EOSPlus;
+	/** Since we're going to bind to delegates, we need to hold onto these */
+	IOnlineAchievementsPtr BaseAchievementsInterface;
+	IOnlineAchievementsPtr EosAchievementsInterface;
+};
+
+typedef TSharedPtr<FOnlineAchievementsEOSPlus, ESPMode::ThreadSafe> FOnlineAchievementsEOSPlusPtr;
Index: Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOSPlus/Private/OnlineSubsystemEOSPlus.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOSPlus/Private/OnlineSubsystemEOSPlus.h b/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOSPlus/Private/OnlineSubsystemEOSPlus.h
new file mode 100644
--- /dev/null	(date 1641576012000)
+++ b/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOSPlus/Private/OnlineSubsystemEOSPlus.h	(date 1641576012000)
@@ -0,0 +1,96 @@
+// Copyright Epic Games, Inc. All Rights Reserved.
+
+#pragma once
+
+#include "CoreMinimal.h"
+#include "OnlineSubsystemImpl.h"
+#include "OnlineSubsystemEOSPlusPrivate.h"
+
+#include "OnlineStatsEOSPlus.h"
+#include "OnlineAchievementsEOSPlus.h"
+#include "OnlineUserEOSPlus.h"
+#include "OnlineSessionEOSPlus.h"
+#include "OnlineLeaderboardsEOSPlus.h"
+#include "OnlineStoreEOSPlus.h"
+#include "OnlineExternalUIEOSPlus.h"
+#include "OnlineVoiceEOSPlus.h"
+#include "OnlineTitleFileEOSPlus.h"
+#include "OnlineUserCloudEOSPlus.h"
+
+
+/**
+ * OnlineSubsystemEOSPlus - Wrapper OSS that uses both the main platform and EOS OSS
+ * hence EOS Plus another OSS
+ */
+class FOnlineSubsystemEOSPlus : 
+	public FOnlineSubsystemImpl
+{
+public:
+	virtual ~FOnlineSubsystemEOSPlus() = default;
+
+// IOnlineSubsystem
+	virtual IOnlineSessionPtr GetSessionInterface() const override;
+	virtual IOnlineFriendsPtr GetFriendsInterface() const override;
+	virtual IOnlineGroupsPtr GetGroupsInterface() const override;
+	virtual IOnlinePartyPtr GetPartyInterface() const override;
+	virtual IOnlineSharedCloudPtr GetSharedCloudInterface() const override;
+	virtual IOnlineUserCloudPtr GetUserCloudInterface() const override;
+	virtual IOnlineEntitlementsPtr GetEntitlementsInterface() const override;
+	virtual IOnlineLeaderboardsPtr GetLeaderboardsInterface() const override;
+	virtual IOnlineVoicePtr GetVoiceInterface() const override;
+	virtual IOnlineExternalUIPtr GetExternalUIInterface() const override;
+	virtual IOnlineTimePtr GetTimeInterface() const override;
+	virtual IOnlineIdentityPtr GetIdentityInterface() const override;
+	virtual IOnlineTitleFilePtr GetTitleFileInterface() const override;
+	virtual IOnlineStoreV2Ptr GetStoreV2Interface() const override;
+	virtual IOnlinePurchasePtr GetPurchaseInterface() const override;
+	virtual IOnlineEventsPtr GetEventsInterface() const override;
+	virtual IOnlineAchievementsPtr GetAchievementsInterface() const override;
+	virtual IOnlineSharingPtr GetSharingInterface() const override;
+	virtual IOnlineUserPtr GetUserInterface() const override;
+	virtual IOnlineMessagePtr GetMessageInterface() const override;
+	virtual IOnlinePresencePtr GetPresenceInterface() const override;
+	virtual IOnlineChatPtr GetChatInterface() const override;
+	virtual IOnlineStatsPtr GetStatsInterface() const override;
+	virtual IOnlineTurnBasedPtr GetTurnBasedInterface() const override;
+	virtual IOnlineTournamentPtr GetTournamentInterface() const override;
+	virtual bool IsLocalPlayer(const FUniqueNetId& UniqueId) const override;
+
+	virtual bool Exec(class UWorld* InWorld, const TCHAR* Cmd, FOutputDevice& Ar) override;
+	virtual FText GetOnlineServiceName() const override;
+
+	virtual bool Init() override;
+	virtual void PreUnload() override;
+	virtual bool Shutdown() override;
+	virtual FString GetAppId() const override;
+//~IOnlineSubsystem
+
+PACKAGE_SCOPE:
+/** Only the factory makes instances */
+	FOnlineSubsystemEOSPlus() = delete;
+	explicit FOnlineSubsystemEOSPlus(FName InInstanceName)
+		: FOnlineSubsystemImpl(EOSPLUS_SUBSYSTEM, InInstanceName)
+		, BaseOSS(nullptr)
+		, EosOSS(nullptr)
+	{}
+
+	/** The platform or store specific OSS being used as the primary OSS */
+	IOnlineSubsystem* BaseOSS;
+	/** The EOS OSS that is being used in conjunction with the platform one */
+	IOnlineSubsystem* EosOSS;
+
+	/** The stats interface that routes calls between the two OSSes */
+	FOnlineStatsEOSPlusPtr StatsInterfacePtr;
+	FOnlineAchievementsEOSPlusPtr AchievementsInterfacePtr;
+	FOnlineUserEOSPlusPtr UserInterfacePtr;
+	FOnlineSessionEOSPlusPtr SessionInterfacePtr;
+	FOnlineLeaderboardsEOSPlusPtr LeaderboardsInterfacePtr;
+	FOnlineStoreEOSPlusPtr StoreInterfacePtr;
+	FOnlineExternalUIEOSPlusPtr ExternalUIInterfacePtr;
+	FOnlineVoiceEOSPlusPtr VoiceInterfacePtr;
+	FOnlineTitleFileEOSPlusPtr TitleFileInterfacePtr;
+	FOnlineUserCloudEOSPlusPtr UserCloudInterfacePtr;
+};
+
+typedef TSharedPtr<FOnlineSubsystemEOSPlus, ESPMode::ThreadSafe> FOnlineSubsystemEOSPlusPtr;
+
Index: Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOSPlus/Private/OnlineExternalUIEOSPlus.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOSPlus/Private/OnlineExternalUIEOSPlus.cpp b/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOSPlus/Private/OnlineExternalUIEOSPlus.cpp
new file mode 100644
--- /dev/null	(date 1641575208000)
+++ b/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOSPlus/Private/OnlineExternalUIEOSPlus.cpp	(date 1641575208000)
@@ -0,0 +1,274 @@
+// Copyright Epic Games, Inc. All Rights Reserved.
+
+#include "OnlineExternalUIEOSPlus.h"
+#include "OnlineSubsystemEOSPlus.h"
+#include "OnlineError.h"
+
+FOnlineExternalUIEOSPlus::FOnlineExternalUIEOSPlus(FOnlineSubsystemEOSPlus* InSubsystem)
+	: EOSPlus(InSubsystem)
+{
+	BaseExternalUIInterface = EOSPlus->BaseOSS->GetExternalUIInterface();
+}
+
+FOnlineExternalUIEOSPlus::~FOnlineExternalUIEOSPlus()
+{
+	if (BaseExternalUIInterface.IsValid())
+	{
+		BaseExternalUIInterface->ClearOnExternalUIChangeDelegates(this);
+		BaseExternalUIInterface->ClearOnLoginFlowUIRequiredDelegates(this);
+		BaseExternalUIInterface->ClearOnCreateAccountFlowUIRequiredDelegates(this);
+	}
+}
+
+FUniqueNetIdEOSPlusPtr FOnlineExternalUIEOSPlus::GetNetIdPlus(const FString& SourceId) const
+{
+	return EOSPlus->UserInterfacePtr->GetNetIdPlus(SourceId);
+}
+
+void FOnlineExternalUIEOSPlus::Initialize()
+{
+	if (BaseExternalUIInterface.IsValid())
+	{
+		BaseExternalUIInterface->AddOnExternalUIChangeDelegate_Handle(FOnExternalUIChangeDelegate::CreateThreadSafeSP(this, &FOnlineExternalUIEOSPlus::OnExternalUIChangeBase));
+		BaseExternalUIInterface->AddOnLoginFlowUIRequiredDelegate_Handle(FOnLoginFlowUIRequiredDelegate::CreateThreadSafeSP(this, &FOnlineExternalUIEOSPlus::OnLoginFlowUIRequiredBase));
+		BaseExternalUIInterface->AddOnCreateAccountFlowUIRequiredDelegate_Handle(FOnCreateAccountFlowUIRequiredDelegate::CreateThreadSafeSP(this, &FOnlineExternalUIEOSPlus::OnOnCreateAccountFlowUIRequiredBase));
+	}
+	else
+	{
+		UE_LOG_ONLINE(Warning, TEXT("[FOnlineExternalUIEOSPlus::Initialize] BaseExternalUIInterface delegates not bound. Base interface not valid"));
+	}
+}
+
+//~ Begin IOnlineExternalUI Interface
+
+bool FOnlineExternalUIEOSPlus::ShowLoginUI(const int ControllerIndex, bool bShowOnlineOnly, bool bShowSkipButton, const FOnLoginUIClosedDelegate& Delegate)
+{
+	bool bResult = false;
+
+	if (BaseExternalUIInterface.IsValid())
+	{
+		bResult = BaseExternalUIInterface->ShowLoginUI(ControllerIndex, bShowOnlineOnly, bShowSkipButton, Delegate);
+	}
+	else
+	{
+		UE_LOG_ONLINE(Warning, TEXT("[FOnlineExternalUIEOSPlus::ShowLoginUI] Unable to call method in base interface. Base interface not valid."));
+	}
+
+	return bResult;
+}
+
+bool FOnlineExternalUIEOSPlus::ShowAccountCreationUI(const int ControllerIndex, const FOnAccountCreationUIClosedDelegate& Delegate)
+{
+	bool bResult = false;
+
+	if (BaseExternalUIInterface.IsValid())
+	{
+		bResult = BaseExternalUIInterface->ShowAccountCreationUI(ControllerIndex, Delegate);
+	}
+	else
+	{
+		UE_LOG_ONLINE(Warning, TEXT("[FOnlineExternalUIEOSPlus::ShowAccountCreationUI] Unable to call method in base interface. Base interface not valid."));
+	}
+
+	return bResult;
+}
+
+bool FOnlineExternalUIEOSPlus::ShowFriendsUI(int32 LocalUserNum)
+{
+	bool bResult = false;
+
+	if (BaseExternalUIInterface.IsValid())
+	{
+		bResult = BaseExternalUIInterface->ShowFriendsUI(LocalUserNum);
+	}
+	else
+	{
+		UE_LOG_ONLINE(Warning, TEXT("[FOnlineExternalUIEOSPlus::ShowFriendsUI] Unable to call method in base interface. Base interface not valid."));
+	}
+
+	return bResult;
+}
+
+bool FOnlineExternalUIEOSPlus::ShowInviteUI(int32 LocalUserNum, FName SessionName)
+{
+	bool bResult = false;
+
+	if (BaseExternalUIInterface.IsValid())
+	{
+		bResult = BaseExternalUIInterface->ShowInviteUI(LocalUserNum, SessionName);
+	}
+	else
+	{
+		UE_LOG_ONLINE(Warning, TEXT("[FOnlineExternalUIEOSPlus::ShowInviteUI] Unable to call method in base interface. Base interface not valid."));
+	}
+
+	return bResult;
+}
+
+bool FOnlineExternalUIEOSPlus::ShowAchievementsUI(int32 LocalUserNum)
+{
+	bool bResult = false;
+
+	if (BaseExternalUIInterface.IsValid())
+	{
+		bResult = BaseExternalUIInterface->ShowAchievementsUI(LocalUserNum);
+	}
+	else
+	{
+		UE_LOG_ONLINE(Warning, TEXT("[FOnlineExternalUIEOSPlus::ShowAchievementsUI] Unable to call method in base interface. Base interface not valid."));
+	}
+
+	return bResult;
+}
+
+bool FOnlineExternalUIEOSPlus::ShowLeaderboardUI(const FString& LeaderboardName)
+{
+	bool bResult = false;
+
+	if (BaseExternalUIInterface.IsValid())
+	{
+		bResult = BaseExternalUIInterface->ShowLeaderboardUI(LeaderboardName);
+	}
+	else
+	{
+		UE_LOG_ONLINE(Warning, TEXT("[FOnlineExternalUIEOSPlus::ShowLeaderboardUI] Unable to call method in base interface. Base interface not valid."));
+	}
+
+	return bResult;
+}
+
+bool FOnlineExternalUIEOSPlus::ShowWebURL(const FString& Url, const FShowWebUrlParams& ShowParams, const FOnShowWebUrlClosedDelegate& Delegate)
+{
+	bool bResult = false;
+
+	if (BaseExternalUIInterface.IsValid())
+	{
+		bResult = BaseExternalUIInterface->ShowWebURL(Url, ShowParams, Delegate);
+	}
+	else
+	{
+		UE_LOG_ONLINE(Warning, TEXT("[FOnlineExternalUIEOSPlus::ShowWebURL] Unable to call method in base interface. Base interface not valid."));
+	}
+
+	return bResult;
+}
+
+bool FOnlineExternalUIEOSPlus::CloseWebURL()
+{
+	bool bResult = false;
+
+	if (BaseExternalUIInterface.IsValid())
+	{
+		bResult = BaseExternalUIInterface->CloseWebURL();
+	}
+	else
+	{
+		UE_LOG_ONLINE(Warning, TEXT("[FOnlineExternalUIEOSPlus::CloseWebURL] Unable to call method in base interface. Base interface not valid."));
+	}
+
+	return bResult;
+}
+
+bool FOnlineExternalUIEOSPlus::ShowProfileUI(const FUniqueNetId& Requestor, const FUniqueNetId& Requestee, const FOnProfileUIClosedDelegate& Delegate)
+{
+	bool bResult = false;
+
+	FUniqueNetIdEOSPlusPtr RequestorNetIdPlus = GetNetIdPlus(Requestor.ToString());
+	FUniqueNetIdEOSPlusPtr RequesteeNetIdPlus = GetNetIdPlus(Requestee.ToString());
+	if (RequestorNetIdPlus.IsValid() && RequesteeNetIdPlus.IsValid())
+	{
+		const bool bIsRequestorBaseNetIdValid = ensure(RequestorNetIdPlus->GetBaseNetId().IsValid());
+		const bool bIsRequesteeBaseNetIdValid = RequesteeNetIdPlus->GetBaseNetId().IsValid(); // We don't ensure because the requestee might not have a valid id in the current platform
+		const bool bIsBaseExternalUIInterfaceValid = BaseExternalUIInterface.IsValid();
+		if (bIsRequestorBaseNetIdValid && bIsRequesteeBaseNetIdValid && bIsBaseExternalUIInterfaceValid)
+		{
+			bResult = BaseExternalUIInterface->ShowProfileUI(*RequestorNetIdPlus->GetBaseNetId(), *RequesteeNetIdPlus->GetBaseNetId(), Delegate);
+			return bResult;
+		}
+		else
+		{
+			UE_LOG_ONLINE(Warning, TEXT("[FOnlineStoreEOSPlus::ShowProfileUI] Unable to call method in base interface. bIsRequestorBaseNetIdValid=%s bIsRequesteeBaseNetIdValid=%s IsBaseExternalUIInterfaceValid=%s."), *LexToString(bIsRequestorBaseNetIdValid), *LexToString(bIsRequesteeBaseNetIdValid), *LexToString(bIsBaseExternalUIInterfaceValid));
+		}
+	}
+	else
+	{
+		UE_LOG_ONLINE(Warning, TEXT("[FOnlineStoreEOSPlus::ShowProfileUI] Unable to call method in base interface. Unknown user (%s)"), RequestorNetIdPlus.IsValid() ? *Requestee.ToString() : *Requestor.ToString());
+	}
+
+	return bResult;
+}
+
+bool FOnlineExternalUIEOSPlus::ShowAccountUpgradeUI(const FUniqueNetId& UniqueId)
+{
+	bool bResult = false;
+
+	FUniqueNetIdEOSPlusPtr NetIdPlus = GetNetIdPlus(UniqueId.ToString());
+	if (NetIdPlus.IsValid())
+	{
+		const bool bIsBaseNetIdValid = ensure(NetIdPlus->GetBaseNetId().IsValid());
+		const bool bIsBaseExternalUIInterfaceValid = BaseExternalUIInterface.IsValid();
+		if (bIsBaseNetIdValid && bIsBaseExternalUIInterfaceValid)
+		{
+			bResult = BaseExternalUIInterface->ShowAccountUpgradeUI(*NetIdPlus->GetBaseNetId());
+		}
+		else
+		{
+			UE_LOG_ONLINE(Warning, TEXT("[FOnlineStoreEOSPlus::ShowAccountUpgradeUI] Unable to call method in base interface. IsBaseNetIdValid=%s IsBaseExternalUIInterfaceValid=%s."), *LexToString(bIsBaseNetIdValid), *LexToString(bIsBaseExternalUIInterfaceValid));
+		}
+	}
+	else
+	{
+		UE_LOG_ONLINE(Warning, TEXT("[FOnlineStoreEOSPlus::ShowAccountUpgradeUI] Unable to call method in base interface. Unknown user (%s)"), *UniqueId.ToString());
+	}
+
+	return bResult;
+}
+
+bool FOnlineExternalUIEOSPlus::ShowStoreUI(int32 LocalUserNum, const FShowStoreParams& ShowParams, const FOnShowStoreUIClosedDelegate& Delegate)
+{
+	bool bResult = false;
+
+	if (BaseExternalUIInterface.IsValid())
+	{
+		bResult = BaseExternalUIInterface->ShowStoreUI(LocalUserNum, ShowParams, Delegate);
+	}
+	else
+	{
+		UE_LOG_ONLINE(Warning, TEXT("[FOnlineExternalUIEOSPlus::ShowStoreUI] Unable to call method in base interface. Base interface not valid."));
+	}
+
+	return bResult;
+}
+
+bool FOnlineExternalUIEOSPlus::ShowSendMessageUI(int32 LocalUserNum, const FShowSendMessageParams& ShowParams, const FOnShowSendMessageUIClosedDelegate& Delegate)
+{
+	bool bResult = false;
+
+	if (BaseExternalUIInterface.IsValid())
+	{
+		bResult = BaseExternalUIInterface->ShowSendMessageUI(LocalUserNum, ShowParams, Delegate);
+	}
+	else
+	{
+		UE_LOG_ONLINE(Warning, TEXT("[FOnlineExternalUIEOSPlus::ShowSendMessageUI] Unable to call method in base interface. Base interface not valid."));
+	}
+
+	return bResult;
+}
+
+void FOnlineExternalUIEOSPlus::OnExternalUIChangeBase(bool bIsOpening)
+{
+	TriggerOnExternalUIChangeDelegates(bIsOpening);
+}
+
+void FOnlineExternalUIEOSPlus::OnLoginFlowUIRequiredBase(const FString& RequestedURL, const FOnLoginRedirectURL& OnLoginRedirect, const FOnLoginFlowComplete& OnLoginFlowComplete, bool& bOutShouldContinueLogin)
+{
+	TriggerOnLoginFlowUIRequiredDelegates(RequestedURL, OnLoginRedirect, OnLoginFlowComplete, bOutShouldContinueLogin);
+}
+
+void FOnlineExternalUIEOSPlus::OnOnCreateAccountFlowUIRequiredBase(const FString& RequestedURL, const FOnLoginRedirectURL& OnLoginRedirect, const FOnLoginFlowComplete& OnLoginFlowComplete, bool& bOutShouldContinueLogin)
+{
+	TriggerOnCreateAccountFlowUIRequiredDelegates(RequestedURL, OnLoginRedirect, OnLoginFlowComplete, bOutShouldContinueLogin);
+}
+
+//~ End IOnlineExternalUI Interface
\ No newline at end of file
Index: Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOSPlus/Private/OnlineAchievementsEOSPlus.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOSPlus/Private/OnlineAchievementsEOSPlus.cpp b/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOSPlus/Private/OnlineAchievementsEOSPlus.cpp
new file mode 100644
--- /dev/null	(date 1641575208000)
+++ b/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOSPlus/Private/OnlineAchievementsEOSPlus.cpp	(date 1641575208000)
@@ -0,0 +1,156 @@
+// Copyright Epic Games, Inc. All Rights Reserved.
+
+#include "OnlineAchievementsEOSPlus.h"
+#include "OnlineSubsystem.h"
+#include "OnlineSubsystemEOSPlus.h"
+#include "EOSSettings.h"
+
+FOnAchievementsWrittenDelegate Ignored;
+
+FOnlineAchievementsEOSPlus::FOnlineAchievementsEOSPlus(FOnlineSubsystemEOSPlus* InSubsystem)
+	: EOSPlus(InSubsystem)
+{
+	EosAchievementsInterface = EOSPlus->EosOSS->GetAchievementsInterface();
+	check(EosAchievementsInterface.IsValid());
+
+	BaseAchievementsInterface = EOSPlus->BaseOSS->GetAchievementsInterface();
+	if (BaseAchievementsInterface.IsValid())
+	{
+		BaseAchievementsInterface->AddOnAchievementUnlockedDelegate_Handle(FOnAchievementUnlockedDelegate::CreateRaw(this, &FOnlineAchievementsEOSPlus::OnAchievementUnlocked));
+	}
+}
+
+FOnlineAchievementsEOSPlus::~FOnlineAchievementsEOSPlus()
+{
+	if (BaseAchievementsInterface.IsValid())
+	{
+		BaseAchievementsInterface->ClearOnAchievementUnlockedDelegates(this);
+	}
+}
+
+void FOnlineAchievementsEOSPlus::OnAchievementUnlocked(const FUniqueNetId& PlayerId, const FString& AchievementId)
+{
+	TriggerOnAchievementUnlockedDelegates(PlayerId, AchievementId);
+}
+
+FUniqueNetIdEOSPlusPtr FOnlineAchievementsEOSPlus::GetNetIdPlus(const FString& SourceId)
+{
+	return EOSPlus->UserInterfacePtr->GetNetIdPlus(SourceId);
+}
+
+void FOnlineAchievementsEOSPlus::WriteAchievements(const FUniqueNetId& PlayerId, FOnlineAchievementsWriteRef& WriteObject, const FOnAchievementsWrittenDelegate& Delegate)
+{
+	FUniqueNetIdEOSPlusPtr NetIdPlus = GetNetIdPlus(PlayerId.ToString());
+	if (!NetIdPlus.IsValid())
+	{
+		UE_LOG_ONLINE(Warning, TEXT("FOnlineAchievementsEOSPlus::WriteAchievements() failed due to unknown user (%s)"), *PlayerId.ToString());
+		return;
+	}
+
+	if (NetIdPlus->GetBaseNetId().IsValid() && BaseAchievementsInterface.IsValid())
+	{
+		BaseAchievementsInterface->WriteAchievements(*NetIdPlus->GetBaseNetId(), WriteObject, Delegate);
+	}
+	if (UEOSSettings::GetSettings().bMirrorAchievementsToEOS)
+	{
+		if (NetIdPlus->GetEOSNetId().IsValid())
+		{
+			// Mirror the achievement data to EOS
+			EosAchievementsInterface->WriteAchievements(*NetIdPlus->GetEOSNetId(), WriteObject, Ignored);
+		}
+	}
+}
+
+void FOnlineAchievementsEOSPlus::QueryAchievements(const FUniqueNetId& PlayerId, const FOnQueryAchievementsCompleteDelegate& Delegate)
+{
+	FUniqueNetIdEOSPlusPtr NetIdPlus = GetNetIdPlus(PlayerId.ToString());
+	if (!NetIdPlus.IsValid() || !NetIdPlus->GetBaseNetId().IsValid())
+	{
+		UE_LOG_ONLINE(Warning, TEXT("FOnlineAchievementsEOSPlus::QueryAchievements() failed due to unknown user (%s)"), *PlayerId.ToString());
+		return;
+	}
+
+	if (BaseAchievementsInterface.IsValid())
+	{
+		BaseAchievementsInterface->QueryAchievements(*NetIdPlus->GetBaseNetId(), Delegate);
+	}
+}
+
+void FOnlineAchievementsEOSPlus::QueryAchievementDescriptions(const FUniqueNetId& PlayerId, const FOnQueryAchievementsCompleteDelegate& Delegate)
+{
+	FUniqueNetIdEOSPlusPtr NetIdPlus = GetNetIdPlus(PlayerId.ToString());
+	if (!NetIdPlus.IsValid() || !NetIdPlus->GetBaseNetId().IsValid())
+	{
+		UE_LOG_ONLINE(Warning, TEXT("FOnlineAchievementsEOSPlus::QueryAchievementDescriptions() failed due to unknown user (%s)"), *PlayerId.ToString());
+		return;
+	}
+
+	if (BaseAchievementsInterface.IsValid())
+	{
+		BaseAchievementsInterface->QueryAchievementDescriptions(*NetIdPlus->GetBaseNetId(), Delegate);
+	}
+}
+
+EOnlineCachedResult::Type FOnlineAchievementsEOSPlus::GetCachedAchievement(const FUniqueNetId& PlayerId, const FString& AchievementId, FOnlineAchievement& OutAchievement)
+{
+	FUniqueNetIdEOSPlusPtr NetIdPlus = GetNetIdPlus(PlayerId.ToString());
+	if (!NetIdPlus.IsValid() || !NetIdPlus->GetBaseNetId().IsValid())
+	{
+		UE_LOG_ONLINE(Warning, TEXT("FOnlineAchievementsEOSPlus::GetCachedAchievement() failed due to unknown user (%s)"), *PlayerId.ToString());
+		return EOnlineCachedResult::NotFound;
+	}
+
+	EOnlineCachedResult::Type Result = EOnlineCachedResult::NotFound;
+
+	if (BaseAchievementsInterface.IsValid())
+	{
+		Result = BaseAchievementsInterface->GetCachedAchievement(*NetIdPlus->GetBaseNetId(), AchievementId, OutAchievement);
+	}
+
+	return Result;
+}
+
+EOnlineCachedResult::Type FOnlineAchievementsEOSPlus::GetCachedAchievements(const FUniqueNetId& PlayerId, TArray<FOnlineAchievement>& OutAchievements)
+{
+	FUniqueNetIdEOSPlusPtr NetIdPlus = GetNetIdPlus(PlayerId.ToString());
+	if (!NetIdPlus.IsValid() || !NetIdPlus->GetBaseNetId().IsValid())
+	{
+		UE_LOG_ONLINE(Warning, TEXT("FOnlineAchievementsEOSPlus::GetCachedAchievements() failed due to unknown user (%s)"), *PlayerId.ToString());
+		return EOnlineCachedResult::NotFound;
+	}
+
+	EOnlineCachedResult::Type Result = EOnlineCachedResult::NotFound;
+
+	if (BaseAchievementsInterface.IsValid())
+	{
+		Result = BaseAchievementsInterface->GetCachedAchievements(*NetIdPlus->GetBaseNetId(), OutAchievements);
+	}
+
+	return Result;
+}
+
+EOnlineCachedResult::Type FOnlineAchievementsEOSPlus::GetCachedAchievementDescription(const FString& AchievementId, FOnlineAchievementDesc& OutAchievementDesc)
+{
+	EOnlineCachedResult::Type Result = EOnlineCachedResult::NotFound;
+
+	if (BaseAchievementsInterface.IsValid())
+	{
+		Result = BaseAchievementsInterface->GetCachedAchievementDescription(AchievementId, OutAchievementDesc);
+	}
+
+	return Result;
+}
+
+#if !UE_BUILD_SHIPPING
+bool FOnlineAchievementsEOSPlus::ResetAchievements(const FUniqueNetId& PlayerId)
+{
+	bool bResult = false;
+
+	if (BaseAchievementsInterface.IsValid())
+	{
+		bResult = BaseAchievementsInterface->ResetAchievements(PlayerId);
+	}
+
+	return bResult;
+}
+#endif
Index: Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOSPlus/Private/OnlineExternalUIEOSPlus.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOSPlus/Private/OnlineExternalUIEOSPlus.h b/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOSPlus/Private/OnlineExternalUIEOSPlus.h
new file mode 100644
--- /dev/null	(date 1641576012000)
+++ b/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOSPlus/Private/OnlineExternalUIEOSPlus.h	(date 1641576012000)
@@ -0,0 +1,58 @@
+// Copyright Epic Games, Inc. All Rights Reserved.
+
+#pragma once
+
+#include "CoreMinimal.h"
+#include "Online/CoreOnline.h"
+#include "OnlineSubsystem.h"
+#include "Interfaces/OnlineExternalUIInterface.h"
+#include "OnlineUserEOSPlus.h"
+
+class FOnlineSubsystemEOSPlus;
+
+/**
+ * Interface for encapsulating the platform external ui interface
+ */
+class FOnlineExternalUIEOSPlus :
+	public IOnlineExternalUI,
+	public TSharedFromThis<FOnlineExternalUIEOSPlus, ESPMode::ThreadSafe>
+{
+public:
+	FOnlineExternalUIEOSPlus() = delete;
+	virtual ~FOnlineExternalUIEOSPlus();
+
+	void Initialize();
+
+	//~ Begin IOnlineExternalUI Interface
+	virtual bool ShowLoginUI(const int ControllerIndex, bool bShowOnlineOnly, bool bShowSkipButton, const FOnLoginUIClosedDelegate& Delegate = FOnLoginUIClosedDelegate()) override;
+	virtual bool ShowAccountCreationUI(const int ControllerIndex, const FOnAccountCreationUIClosedDelegate& Delegate = FOnAccountCreationUIClosedDelegate()) override;
+	virtual bool ShowFriendsUI(int32 LocalUserNum) override;
+	virtual bool ShowInviteUI(int32 LocalUserNum, FName SessionName = NAME_GameSession) override;
+	virtual bool ShowAchievementsUI(int32 LocalUserNum) override;
+	virtual bool ShowLeaderboardUI(const FString& LeaderboardName) override;
+	virtual bool ShowWebURL(const FString& Url, const FShowWebUrlParams& ShowParams, const FOnShowWebUrlClosedDelegate& Delegate = FOnShowWebUrlClosedDelegate()) override;
+	virtual bool CloseWebURL() override;
+	virtual bool ShowProfileUI(const FUniqueNetId& Requestor, const FUniqueNetId& Requestee, const FOnProfileUIClosedDelegate& Delegate = FOnProfileUIClosedDelegate()) override;
+	virtual bool ShowAccountUpgradeUI(const FUniqueNetId& UniqueId) override;
+	virtual bool ShowStoreUI(int32 LocalUserNum, const FShowStoreParams& ShowParams, const FOnShowStoreUIClosedDelegate& Delegate = FOnShowStoreUIClosedDelegate()) override;
+	virtual bool ShowSendMessageUI(int32 LocalUserNum, const FShowSendMessageParams& ShowParams, const FOnShowSendMessageUIClosedDelegate& Delegate = FOnShowSendMessageUIClosedDelegate()) override;
+	//~ End IOnlineExternalUI Interface
+
+PACKAGE_SCOPE:
+	FOnlineExternalUIEOSPlus(FOnlineSubsystemEOSPlus* InSubsystem);
+
+	void OnExternalUIChangeBase(bool bIsOpening);
+	void OnLoginFlowUIRequiredBase(const FString& RequestedURL, const FOnLoginRedirectURL& OnLoginRedirect, const FOnLoginFlowComplete& OnLoginFlowComplete, bool& bOutShouldContinueLogin);
+	void OnOnCreateAccountFlowUIRequiredBase(const FString& RequestedURL, const FOnLoginRedirectURL& OnLoginRedirect, const FOnLoginFlowComplete& OnLoginFlowComplete, bool& bOutShouldContinueLogin);
+
+private:
+	FUniqueNetIdEOSPlusPtr GetNetIdPlus(const FString& SourceId) const;
+
+	/** Reference to the owning EOS plus subsystem */
+	FOnlineSubsystemEOSPlus* EOSPlus;
+	
+	// We don't support EOS mirroring yet
+	IOnlineExternalUIPtr BaseExternalUIInterface;
+};
+
+typedef TSharedPtr<FOnlineExternalUIEOSPlus, ESPMode::ThreadSafe> FOnlineExternalUIEOSPlusPtr;
Index: Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOSPlus/Private/OnlineSessionEOSPlus.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOSPlus/Private/OnlineSessionEOSPlus.h b/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOSPlus/Private/OnlineSessionEOSPlus.h
new file mode 100644
--- /dev/null	(date 1641576012000)
+++ b/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOSPlus/Private/OnlineSessionEOSPlus.h	(date 1641576012000)
@@ -0,0 +1,111 @@
+// Copyright Epic Games, Inc. All Rights Reserved.
+
+#pragma once
+
+#include "CoreMinimal.h"
+#include "Online/CoreOnline.h"
+#include "OnlineSessionSettings.h"
+#include "Interfaces/OnlineSessionInterface.h"
+#include "OnlineUserEOSPlus.h"
+
+class FOnlineSubsystemEOSPlus;
+
+/**
+ * Interface for interacting with EOS sessions
+ */
+class FOnlineSessionEOSPlus :
+	public IOnlineSession
+{
+public:
+	FOnlineSessionEOSPlus() = delete;
+	virtual ~FOnlineSessionEOSPlus();
+
+// IOnlineSession Interface
+	virtual FUniqueNetIdPtr CreateSessionIdFromString(const FString& SessionIdStr) override;
+	virtual bool CreateSession(int32 HostingPlayerNum, FName SessionName, const FOnlineSessionSettings& NewSessionSettings) override;
+	virtual bool CreateSession(const FUniqueNetId& HostingPlayerId, FName SessionName, const FOnlineSessionSettings& NewSessionSettings) override;
+	virtual bool StartSession(FName SessionName) override;
+	virtual bool UpdateSession(FName SessionName, FOnlineSessionSettings& UpdatedSessionSettings, bool bShouldRefreshOnlineData = true) override;
+	virtual bool EndSession(FName SessionName) override;
+	virtual bool DestroySession(FName SessionName, const FOnDestroySessionCompleteDelegate& CompletionDelegate = FOnDestroySessionCompleteDelegate()) override;
+	virtual bool IsPlayerInSession(FName SessionName, const FUniqueNetId& UniqueId) override;
+	virtual bool StartMatchmaking(const TArray< FUniqueNetIdRef >& LocalPlayers, FName SessionName, const FOnlineSessionSettings& NewSessionSettings, TSharedRef<FOnlineSessionSearch>& SearchSettings) override;
+	virtual bool CancelMatchmaking(int32 SearchingPlayerNum, FName SessionName) override;
+	virtual bool CancelMatchmaking(const FUniqueNetId& SearchingPlayerId, FName SessionName) override;
+	virtual bool FindSessions(int32 SearchingPlayerNum, const TSharedRef<FOnlineSessionSearch>& SearchSettings) override;
+	virtual bool FindSessions(const FUniqueNetId& SearchingPlayerId, const TSharedRef<FOnlineSessionSearch>& SearchSettings) override;
+	virtual bool FindSessionById(const FUniqueNetId& SearchingUserId, const FUniqueNetId& SessionId, const FUniqueNetId& FriendId, const FOnSingleSessionResultCompleteDelegate& CompletionDelegate) override;
+	virtual bool CancelFindSessions() override;
+	virtual bool PingSearchResults(const FOnlineSessionSearchResult& SearchResult) override;
+	virtual bool JoinSession(int32 PlayerNum, FName SessionName, const FOnlineSessionSearchResult& DesiredSession) override;
+	virtual bool JoinSession(const FUniqueNetId& PlayerId, FName SessionName, const FOnlineSessionSearchResult& DesiredSession) override;
+	virtual bool FindFriendSession(int32 LocalUserNum, const FUniqueNetId& Friend) override;
+	virtual bool FindFriendSession(const FUniqueNetId& LocalUserId, const FUniqueNetId& Friend) override;
+	virtual bool FindFriendSession(const FUniqueNetId& LocalUserId, const TArray<FUniqueNetIdRef>& FriendList) override;
+	virtual bool SendSessionInviteToFriend(int32 LocalUserNum, FName SessionName, const FUniqueNetId& Friend) override;
+	virtual bool SendSessionInviteToFriend(const FUniqueNetId& LocalUserId, FName SessionName, const FUniqueNetId& Friend) override;
+	virtual bool SendSessionInviteToFriends(int32 LocalUserNum, FName SessionName, const TArray< FUniqueNetIdRef >& Friends) override;
+	virtual bool SendSessionInviteToFriends(const FUniqueNetId& LocalUserId, FName SessionName, const TArray< FUniqueNetIdRef >& Friends) override;
+	virtual bool GetResolvedConnectString(FName SessionName, FString& ConnectInfo, FName PortType) override;
+	virtual bool GetResolvedConnectString(const FOnlineSessionSearchResult& SearchResult, FName PortType, FString& ConnectInfo) override;
+	virtual FOnlineSessionSettings* GetSessionSettings(FName SessionName) override;
+	virtual bool RegisterPlayer(FName SessionName, const FUniqueNetId& PlayerId, bool bWasInvited) override;
+	virtual bool RegisterPlayers(FName SessionName, const TArray< FUniqueNetIdRef >& Players, bool bWasInvited = false) override;
+	virtual bool UnregisterPlayer(FName SessionName, const FUniqueNetId& PlayerId) override;
+	virtual bool UnregisterPlayers(FName SessionName, const TArray< FUniqueNetIdRef >& Players) override;
+	virtual void RegisterLocalPlayer(const FUniqueNetId& PlayerId, FName SessionName, const FOnRegisterLocalPlayerCompleteDelegate& Delegate) override;
+	virtual void UnregisterLocalPlayer(const FUniqueNetId& PlayerId, FName SessionName, const FOnUnregisterLocalPlayerCompleteDelegate& Delegate) override;
+	virtual int32 GetNumSessions() override;
+	virtual void DumpSessionState() override;
+	FNamedOnlineSession* GetNamedSession(FName SessionName) override;
+	virtual void RemoveNamedSession(FName SessionName) override;
+	virtual EOnlineSessionState::Type GetSessionState(FName SessionName) const override;
+	virtual bool HasPresenceSession() override;
+	virtual class FNamedOnlineSession* AddNamedSession(FName SessionName, const FOnlineSessionSettings& SessionSettings) override;
+	virtual class FNamedOnlineSession* AddNamedSession(FName SessionName, const FOnlineSession& Session) override;
+
+// ~IOnlineSession Interface
+
+PACKAGE_SCOPE:
+	FOnlineSessionEOSPlus(FOnlineSubsystemEOSPlus* InSubsystem);
+
+	/** Global callbacks that we'll need to broadcast back out */
+	void OnSessionUserInviteAcceptedBase(const bool bWasSuccessful, const int32 ControllerId, FUniqueNetIdPtr UserId, const FOnlineSessionSearchResult& InviteResult);
+	void OnSessionUserInviteAcceptedEOS(const bool bWasSuccessful, const int32 ControllerId, FUniqueNetIdPtr UserId, const FOnlineSessionSearchResult& InviteResult);
+	void OnSessionInviteReceivedBase(const FUniqueNetId& UserId, const FUniqueNetId& FromId, const FString& AppId, const FOnlineSessionSearchResult& InviteResult);
+	void OnSessionInviteReceivedEOS(const FUniqueNetId& UserId, const FUniqueNetId& FromId, const FString& AppId, const FOnlineSessionSearchResult& InviteResult);
+	void OnSessionFailure(const FUniqueNetId& Player, ESessionFailure::Type Failure);
+
+	FDelegateHandle	OnCreateSessionCompleteDelegateHandleEOS;
+	void OnCreateSessionComplete(FName SessionName, bool bWasSuccessful);
+	void OnStartSessionComplete(FName SessionName, bool bWasSuccessful);
+	void OnUpdateSessionComplete(FName SessionName, bool bWasSuccessful);
+	void OnEndSessionComplete(FName SessionName, bool bWasSuccessful);
+	void OnFindSessionsComplete(bool bWasSuccessful);
+	void OnCancelFindSessionsComplete(bool bWasSuccessful);
+	void OnPingSearchResultsComplete(bool bWasSuccessful);
+	void OnJoinSessionComplete(FName SessionName, EOnJoinSessionCompleteResult::Type JoinResult);
+	void OnFindFriendSessionComplete(int32 LocalPlayerNum, bool bWasSuccessful, const TArray<FOnlineSessionSearchResult>& Results);
+	
+	FUniqueNetIdEOSPlusPtr GetNetIdPlus(const FString& SourceId);
+	FUniqueNetIdPtr GetBaseNetId(const FString& SourceId);
+	FUniqueNetIdPtr GetEOSNetId(const FString& SourceId);
+	TArray<FUniqueNetIdRef> GetBaseNetIds(const TArray<FUniqueNetIdRef>& Players);
+	TArray<FUniqueNetIdRef> GetEOSNetIds(const TArray<FUniqueNetIdRef>& Players);
+
+	/** Reference to the owning EOS plus subsystem */
+	FOnlineSubsystemEOSPlus* EOSPlus;
+	bool bUseEOSSessions;
+
+	/** Critical sections for thread safe operation of session lists */
+	mutable FCriticalSection SessionLock;
+	/** Current session settings */
+	TArray<FNamedOnlineSession> Sessions;
+
+	IOnlineSessionPtr BaseSessionInterface;
+	IOnlineSessionPtr EOSSessionInterface;
+
+	TUniqueNetIdMap<TSharedRef<FOnlineSessionSearch>> CachedSearchSettingsPerSearchingUser;
+};
+
+typedef TSharedPtr<FOnlineSessionEOSPlus, ESPMode::ThreadSafe> FOnlineSessionEOSPlusPtr;
Index: Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOSPlus/Private/OnlineVoiceEOSPlus.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOSPlus/Private/OnlineVoiceEOSPlus.cpp b/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOSPlus/Private/OnlineVoiceEOSPlus.cpp
new file mode 100644
--- /dev/null	(date 1641576012000)
+++ b/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOSPlus/Private/OnlineVoiceEOSPlus.cpp	(date 1641576012000)
@@ -0,0 +1,480 @@
+// Copyright Epic Games, Inc. All Rights Reserved.
+
+#include "OnlineVoiceEOSPlus.h"
+#include "OnlineSubsystemEOSPlus.h"
+#include "OnlineError.h"
+
+FOnlineVoiceEOSPlus::FOnlineVoiceEOSPlus(FOnlineSubsystemEOSPlus* InSubsystem)
+	: EOSPlus(InSubsystem)
+{
+	BaseVoiceInterface = EOSPlus->BaseOSS->GetVoiceInterface();
+}
+
+FOnlineVoiceEOSPlus::~FOnlineVoiceEOSPlus()
+{
+	if (BaseVoiceInterface.IsValid())
+	{
+		BaseVoiceInterface->ClearOnPlayerTalkingStateChangedDelegates(this);
+	}
+}
+
+FUniqueNetIdEOSPlusPtr FOnlineVoiceEOSPlus::GetNetIdPlus(const FString& SourceId) const
+{
+	return EOSPlus->UserInterfacePtr->GetNetIdPlus(SourceId);
+}
+
+void FOnlineVoiceEOSPlus::Initialize()
+{
+	if (BaseVoiceInterface.IsValid())
+	{
+		BaseVoiceInterface->AddOnPlayerTalkingStateChangedDelegate_Handle(FOnPlayerTalkingStateChangedDelegate::CreateThreadSafeSP(this, &FOnlineVoiceEOSPlus::OnPlayerTalkingStateChanged));
+	}
+	else
+	{
+		UE_LOG_ONLINE(VeryVerbose, TEXT("[FOnlineVoiceEOSPlus::Initialize] BaseVoiceInterface delegates not bound. Base interface not valid"));
+	}
+}
+
+//~ Begin IOnlineVoice Interface
+
+IVoiceEnginePtr FOnlineVoiceEOSPlus::CreateVoiceEngine()
+{
+	IVoiceEnginePtr Result = nullptr;
+	
+	if (BaseVoiceInterface.IsValid())
+	{
+		Result = BaseVoiceInterface->CreateVoiceEngine();
+	}
+	else
+	{
+		UE_LOG_ONLINE(VeryVerbose, TEXT("[FOnlineVoiceEOSPlus::CreateVoiceEngine] Unable to call method in base interface. Base interface not valid"));
+	}
+	
+	return Result;
+}
+
+void FOnlineVoiceEOSPlus::ProcessMuteChangeNotification()
+{
+	if (BaseVoiceInterface.IsValid())
+	{
+		BaseVoiceInterface->ProcessMuteChangeNotification();
+	}
+	else
+	{
+		UE_LOG_ONLINE(VeryVerbose, TEXT("[FOnlineVoiceEOSPlus::ProcessMuteChangeNotification] Unable to call method in base interface. Base interface not valid"));
+	}
+}
+
+void FOnlineVoiceEOSPlus::StartNetworkedVoice(uint8 LocalUserNum)
+{
+	if (BaseVoiceInterface.IsValid())
+	{
+		BaseVoiceInterface->StartNetworkedVoice(LocalUserNum);
+	}
+	else
+	{
+		UE_LOG_ONLINE(VeryVerbose, TEXT("[FOnlineVoiceEOSPlus::StartNetworkedVoice] Unable to call method in base interface. Base interface not valid"));
+	}
+}
+
+void FOnlineVoiceEOSPlus::StopNetworkedVoice(uint8 LocalUserNum)
+{
+	if (BaseVoiceInterface.IsValid())
+	{
+		BaseVoiceInterface->StopNetworkedVoice(LocalUserNum);
+	}
+	else
+	{
+		UE_LOG_ONLINE(VeryVerbose, TEXT("[FOnlineVoiceEOSPlus::StopNetworkedVoice] Unable to call method in base interface. Base interface not valid"));
+	}
+}
+
+bool FOnlineVoiceEOSPlus::RegisterLocalTalker(uint32 LocalUserNum)
+{
+	bool bResult = false;
+
+	if (BaseVoiceInterface.IsValid())
+	{
+		bResult = BaseVoiceInterface->RegisterLocalTalker(LocalUserNum);
+	}
+	else
+	{
+		UE_LOG_ONLINE(VeryVerbose, TEXT("[FOnlineVoiceEOSPlus::RegisterLocalTalker] Unable to call method in base interface. Base interface not valid"));
+	}
+
+	return bResult;
+}
+
+void FOnlineVoiceEOSPlus::RegisterLocalTalkers()
+{
+	if (BaseVoiceInterface.IsValid())
+	{
+		BaseVoiceInterface->RegisterLocalTalkers();
+	}
+	else
+	{
+		UE_LOG_ONLINE(VeryVerbose, TEXT("[FOnlineVoiceEOSPlus::RegisterLocalTalkers] Unable to call method in base interface. Base interface not valid"));
+	}
+}
+
+bool FOnlineVoiceEOSPlus::UnregisterLocalTalker(uint32 LocalUserNum)
+{
+	bool bResult = false;
+
+	if (BaseVoiceInterface.IsValid())
+	{
+		bResult = BaseVoiceInterface->UnregisterLocalTalker(LocalUserNum);
+	}
+	else
+	{
+		UE_LOG_ONLINE(VeryVerbose, TEXT("[FOnlineVoiceEOSPlus::UnregisterLocalTalker] Unable to call method in base interface. Base interface not valid"));
+	}
+
+	return bResult;
+}
+
+void FOnlineVoiceEOSPlus::UnregisterLocalTalkers()
+{
+	if (BaseVoiceInterface.IsValid())
+	{
+		BaseVoiceInterface->UnregisterLocalTalkers();
+	}
+	else
+	{
+		UE_LOG_ONLINE(VeryVerbose, TEXT("[FOnlineVoiceEOSPlus::UnregisterLocalTalkers] Unable to call method in base interface. Base interface not valid"));
+	}
+}
+
+bool FOnlineVoiceEOSPlus::RegisterRemoteTalker(const FUniqueNetId& UniqueId)
+{
+	bool bResult = false;
+
+	if (BaseVoiceInterface.IsValid())
+	{
+		FUniqueNetIdEOSPlusPtr NetIdPlus = GetNetIdPlus(UniqueId.ToString());
+		if (NetIdPlus.IsValid())
+		{
+			if (ensure(NetIdPlus->GetBaseNetId().IsValid()))
+			{
+				bResult = BaseVoiceInterface->RegisterRemoteTalker(*NetIdPlus->GetBaseNetId());
+			}
+			else
+			{
+				UE_LOG_ONLINE(Warning, TEXT("[FOnlineVoiceEOSPlus::RegisterRemoteTalker] Unable to call method in base interface. BaseNetId not valid for user (%s)."), *UniqueId.ToString());
+			}
+		}
+		else
+		{
+			UE_LOG_ONLINE(Warning, TEXT("[FOnlineVoiceEOSPlus::RegisterRemoteTalker] Unable to call method in base interface. Unknown user (%s)"), *UniqueId.ToString());
+		}
+	}
+	else
+	{
+		UE_LOG_ONLINE(VeryVerbose, TEXT("[FOnlineVoiceEOSPlus::RegisterRemoteTalker] Unable to call method in base interface. Base interface not valid"));
+	}
+
+	return bResult;
+}
+
+bool FOnlineVoiceEOSPlus::UnregisterRemoteTalker(const FUniqueNetId& UniqueId)
+{
+	bool bResult = false;
+
+	if (BaseVoiceInterface.IsValid())
+	{
+		FUniqueNetIdEOSPlusPtr NetIdPlus = GetNetIdPlus(UniqueId.ToString());
+		if (NetIdPlus.IsValid())
+		{
+			if (ensure(NetIdPlus->GetBaseNetId().IsValid()))
+			{
+				bResult = BaseVoiceInterface->UnregisterRemoteTalker(*NetIdPlus->GetBaseNetId());
+			}
+			else
+			{
+				UE_LOG_ONLINE(Warning, TEXT("[FOnlineVoiceEOSPlus::UnregisterRemoteTalker] Unable to call method in base interface. BaseNetId not valid for user (%s)."), *UniqueId.ToString());
+			}
+		}
+		else
+		{
+			UE_LOG_ONLINE(Warning, TEXT("[FOnlineVoiceEOSPlus::UnregisterRemoteTalker] Unable to call method in base interface. Unknown user (%s)"), *UniqueId.ToString());
+		}
+	}
+	else
+	{
+		UE_LOG_ONLINE(VeryVerbose, TEXT("[FOnlineVoiceEOSPlus::UnregisterRemoteTalker] Unable to call method in base interface. Base interface not valid"));
+	}
+
+	return bResult;
+}
+
+void FOnlineVoiceEOSPlus::RemoveAllRemoteTalkers()
+{
+	if (BaseVoiceInterface.IsValid())
+	{
+		BaseVoiceInterface->RemoveAllRemoteTalkers();
+	}
+	else
+	{
+		UE_LOG_ONLINE(VeryVerbose, TEXT("[FOnlineVoiceEOSPlus::RemoveAllRemoteTalkers] Unable to call method in base interface. Base interface not valid"));
+	}
+}
+
+bool FOnlineVoiceEOSPlus::IsHeadsetPresent(uint32 LocalUserNum)
+{
+	bool bResult = false;
+
+	if (BaseVoiceInterface.IsValid())
+	{
+		bResult = BaseVoiceInterface->IsHeadsetPresent(LocalUserNum);
+	}
+	else
+	{
+		UE_LOG_ONLINE(VeryVerbose, TEXT("[FOnlineVoiceEOSPlus::IsHeadsetPresent] Unable to call method in base interface. Base interface not valid"));
+	}
+
+	return bResult;
+}
+
+bool FOnlineVoiceEOSPlus::IsLocalPlayerTalking(uint32 LocalUserNum)
+{
+	bool bResult = false;
+
+	if (BaseVoiceInterface.IsValid())
+	{
+		bResult = BaseVoiceInterface->IsLocalPlayerTalking(LocalUserNum);
+	}
+	else
+	{
+		UE_LOG_ONLINE(VeryVerbose, TEXT("[FOnlineVoiceEOSPlus::IsLocalPlayerTalking] Unable to call method in base interface. Base interface not valid"));
+	}
+
+	return bResult;
+}
+
+bool FOnlineVoiceEOSPlus::IsRemotePlayerTalking(const FUniqueNetId& UniqueId)
+{
+	bool bResult = false;
+
+	if (BaseVoiceInterface.IsValid())
+	{
+		FUniqueNetIdEOSPlusPtr NetIdPlus = GetNetIdPlus(UniqueId.ToString());
+		if (NetIdPlus.IsValid())
+		{
+			if (ensure(NetIdPlus->GetBaseNetId().IsValid()))
+			{
+				bResult = BaseVoiceInterface->IsRemotePlayerTalking(*NetIdPlus->GetBaseNetId());
+			}
+			else
+			{
+				UE_LOG_ONLINE(Warning, TEXT("[FOnlineVoiceEOSPlus::IsRemotePlayerTalking] Unable to call method in base interface. BaseNetId not valid for user (%s)."), *UniqueId.ToString());
+			}
+		}
+		else
+		{
+			UE_LOG_ONLINE(Warning, TEXT("[FOnlineVoiceEOSPlus::IsRemotePlayerTalking] Unable to call method in base interface. Unknown user (%s)"), *UniqueId.ToString());
+		}
+	}
+	else
+	{
+		UE_LOG_ONLINE(VeryVerbose, TEXT("[FOnlineVoiceEOSPlus::IsRemotePlayerTalking] Unable to call method in base interface. Base interface not valid"));
+	}
+
+	return bResult;
+}
+
+bool FOnlineVoiceEOSPlus::IsMuted(uint32 LocalUserNum, const FUniqueNetId& UniqueId) const
+{
+	bool bResult = false;
+
+	if (BaseVoiceInterface.IsValid())
+	{
+		FUniqueNetIdEOSPlusPtr NetIdPlus = GetNetIdPlus(UniqueId.ToString());
+		if (NetIdPlus.IsValid())
+		{
+			if (ensure(NetIdPlus->GetBaseNetId().IsValid()))
+			{
+				bResult = BaseVoiceInterface->IsMuted(LocalUserNum, *NetIdPlus->GetBaseNetId());
+			}
+			else
+			{
+				UE_LOG_ONLINE(Warning, TEXT("[FOnlineVoiceEOSPlus::IsMuted] Unable to call method in base interface. BaseNetId not valid for user (%s)."), *UniqueId.ToString());
+			}
+		}
+		else
+		{
+			UE_LOG_ONLINE(Warning, TEXT("[FOnlineVoiceEOSPlus::IsMuted] Unable to call method in base interface. Unknown user (%s)"), *UniqueId.ToString());
+		}
+	}
+	else
+	{
+		UE_LOG_ONLINE(VeryVerbose, TEXT("[FOnlineVoiceEOSPlus::IsMuted] Unable to call method in base interface. Base interface not valid"));
+	}
+
+	return bResult;
+}
+
+bool FOnlineVoiceEOSPlus::MuteRemoteTalker(uint8 LocalUserNum, const FUniqueNetId& PlayerId, bool bIsSystemWide)
+{
+	bool bResult = false;
+
+	if (BaseVoiceInterface.IsValid())
+	{
+		FUniqueNetIdEOSPlusPtr NetIdPlus = GetNetIdPlus(PlayerId.ToString());
+		if (NetIdPlus.IsValid())
+		{
+			if (ensure(NetIdPlus->GetBaseNetId().IsValid()))
+			{
+				bResult = BaseVoiceInterface->MuteRemoteTalker(LocalUserNum, *NetIdPlus->GetBaseNetId(), bIsSystemWide);
+			}
+			else
+			{
+				UE_LOG_ONLINE(Warning, TEXT("[FOnlineVoiceEOSPlus::MuteRemoteTalker] Unable to call method in base interface. BaseNetId not valid for user (%s)."), *PlayerId.ToString());
+			}
+		}
+		else
+		{
+			UE_LOG_ONLINE(Warning, TEXT("[FOnlineVoiceEOSPlus::MuteRemoteTalker] Unable to call method in base interface. Unknown user (%s)"), *PlayerId.ToString());
+		}
+	}
+	else
+	{
+		UE_LOG_ONLINE(VeryVerbose, TEXT("[FOnlineVoiceEOSPlus::MuteRemoteTalker] Unable to call method in base interface. Base interface not valid"));
+	}
+
+	return bResult;
+}
+
+bool FOnlineVoiceEOSPlus::UnmuteRemoteTalker(uint8 LocalUserNum, const FUniqueNetId& PlayerId, bool bIsSystemWide)
+{
+	bool bResult = false;
+
+	if (BaseVoiceInterface.IsValid())
+	{
+		FUniqueNetIdEOSPlusPtr NetIdPlus = GetNetIdPlus(PlayerId.ToString());
+		if (NetIdPlus.IsValid())
+		{
+			if (ensure(NetIdPlus->GetBaseNetId().IsValid()))
+			{
+				bResult = BaseVoiceInterface->UnmuteRemoteTalker(LocalUserNum, *NetIdPlus->GetBaseNetId(), bIsSystemWide);
+			}
+			else
+			{
+				UE_LOG_ONLINE(Warning, TEXT("[FOnlineVoiceEOSPlus::UnmuteRemoteTalker] Unable to call method in base interface. BaseNetId not valid for user (%s)."), *PlayerId.ToString());
+			}
+		}
+		else
+		{
+			UE_LOG_ONLINE(Warning, TEXT("[FOnlineVoiceEOSPlus::UnmuteRemoteTalker] Unable to call method in base interface. Unknown user (%s)"), *PlayerId.ToString());
+		}
+	}
+	else
+	{
+		UE_LOG_ONLINE(VeryVerbose, TEXT("[FOnlineVoiceEOSPlus::UnmuteRemoteTalker] Unable to call method in base interface. Base interface not valid"));
+	}
+
+	return bResult;
+}
+
+TSharedPtr<FVoicePacket> FOnlineVoiceEOSPlus::SerializeRemotePacket(FArchive& Ar)
+{
+	TSharedPtr<FVoicePacket> Result = nullptr;
+	
+	if (BaseVoiceInterface.IsValid())
+	{
+		Result = BaseVoiceInterface->SerializeRemotePacket(Ar);
+	}
+	else
+	{
+		UE_LOG_ONLINE(VeryVerbose, TEXT("[FOnlineVoiceEOSPlus::SerializeRemotePacket] Unable to call method in base interface. Base interface not valid"));
+	}
+	
+	return Result;
+}
+
+TSharedPtr<FVoicePacket> FOnlineVoiceEOSPlus::GetLocalPacket(uint32 LocalUserNum)
+{
+	TSharedPtr<FVoicePacket> Result = nullptr;
+	
+	if (BaseVoiceInterface.IsValid())
+	{
+		Result = BaseVoiceInterface->GetLocalPacket(LocalUserNum);
+	}
+	else
+	{
+		UE_LOG_ONLINE(VeryVerbose, TEXT("[FOnlineVoiceEOSPlus::GetLocalPacket] Unable to call method in base interface. Base interface not valid"));
+	}
+	
+	return Result;
+}
+
+int32 FOnlineVoiceEOSPlus::GetNumLocalTalkers()
+{
+	int32 Result = 0;
+
+	if (BaseVoiceInterface.IsValid())
+	{
+		Result = BaseVoiceInterface->GetNumLocalTalkers();
+	}
+	else
+	{
+		UE_LOG_ONLINE(VeryVerbose, TEXT("[FOnlineVoiceEOSPlus::GetNumLocalTalkers] Unable to call method in base interface. Base interface not valid"));
+	}
+
+	return Result;
+}
+
+void FOnlineVoiceEOSPlus::ClearVoicePackets()
+{
+	if (BaseVoiceInterface.IsValid())
+	{
+		BaseVoiceInterface->ClearVoicePackets();
+	}
+	else
+	{
+		UE_LOG_ONLINE(VeryVerbose, TEXT("[FOnlineVoiceEOSPlus::ClearVoicePackets] Unable to call method in base interface. Base interface not valid"));
+	}
+}
+
+void FOnlineVoiceEOSPlus::Tick(float DeltaTime)
+{
+	if (BaseVoiceInterface.IsValid())
+	{
+		BaseVoiceInterface->Tick(DeltaTime);
+	}
+	else
+	{
+		UE_LOG_ONLINE(VeryVerbose, TEXT("[FOnlineVoiceEOSPlus::Tick] Unable to call method in base interface. Base interface not valid"));
+	}
+}
+
+FString FOnlineVoiceEOSPlus::GetVoiceDebugState() const
+{
+	FString Result;
+
+	if (BaseVoiceInterface.IsValid())
+	{
+		Result = BaseVoiceInterface->GetVoiceDebugState();
+	}
+	else
+	{
+		UE_LOG_ONLINE(VeryVerbose, TEXT("[FOnlineVoiceEOSPlus::GetVoiceDebugState] Unable to call method in base interface. Base interface not valid"));
+	}
+
+	return Result;
+}
+	
+void FOnlineVoiceEOSPlus::OnPlayerTalkingStateChanged(FUniqueNetIdRef TalkerId, bool bIsTalking)
+{
+	FUniqueNetIdEOSPlusPtr NetIdPlus = GetNetIdPlus(TalkerId->ToString());
+	if (NetIdPlus.IsValid())
+	{
+		// We don't want to trigger it anyways if the NetIdPlus is not valid like in other interfaces, because this one takes a FUniqueNetIdRef as parameter
+		TriggerOnPlayerTalkingStateChangedDelegates(NetIdPlus.ToSharedRef(), bIsTalking);
+	}
+	else
+	{
+		UE_LOG_ONLINE(Warning, TEXT("[FOnlineVoiceEOSPlus::OnPlayerTalkingStateChanged] Unknown user (%s)"), *TalkerId->ToString());
+	}	
+}
+
+//~ End IOnlineVoice Interface
\ No newline at end of file
Index: Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOSPlus/Private/OnlineUserEOSPlus.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOSPlus/Private/OnlineUserEOSPlus.h b/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOSPlus/Private/OnlineUserEOSPlus.h
new file mode 100644
--- /dev/null	(date 1641576012000)
+++ b/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOSPlus/Private/OnlineUserEOSPlus.h	(date 1641576012000)
@@ -0,0 +1,516 @@
+// Copyright Epic Games, Inc. All Rights Reserved.
+
+#pragma once
+
+#include "CoreMinimal.h"
+#include "Online/CoreOnline.h"
+#include "OnlineSubsystem.h"
+#include "Interfaces/OnlineUserInterface.h"
+#include "Interfaces/OnlineIdentityInterface.h"
+#include "Interfaces/OnlineFriendsInterface.h"
+#include "Interfaces/OnlinePresenceInterface.h"
+
+class FOnlineSubsystemEOSPlus;
+
+#ifndef EOS_NETID_BYTE_SIZE
+	#define EOS_NETID_BYTE_SIZE 32
+#endif
+
+#define BASE_NETID_TYPE_SIZE 1
+
+using FUniqueNetIdEOSPlusPtr = TSharedPtr<const class FUniqueNetIdEOSPlus>;
+using FUniqueNetIdEOSPlusRef = TSharedRef<const class FUniqueNetIdEOSPlus>;
+
+/**
+ * Unique net id wrapper for a EOS plus another account id. The underlying string is a combination
+ * of both account ids concatenated
+ */
+class FUniqueNetIdEOSPlus :
+	public FUniqueNetIdString
+{
+public:
+	template<typename... TArgs>
+	static FUniqueNetIdEOSPlusRef Create(TArgs&&... Args)
+	{
+		return MakeShareable(new FUniqueNetIdEOSPlus(Forward<TArgs>(Args)...));
+	}
+
+// FUniqueNetId interface
+	virtual const uint8* GetBytes() const override;
+	virtual int32 GetSize() const override;
+	virtual bool IsValid() const override;
+// ~FUniqueNetId interface
+
+	FUniqueNetIdPtr GetBaseNetId() const
+	{
+		return BaseUniqueNetId;
+	}
+
+	FUniqueNetIdPtr GetEOSNetId() const
+	{
+		return EOSUniqueNetId;
+	}
+
+	/** global static instance of invalid (zero) id */
+	static const FUniqueNetIdEOSPlusRef& EmptyId()
+	{
+		static const FUniqueNetIdEOSPlusRef EmptyId(Create());
+		return EmptyId;
+	}
+
+PACKAGE_SCOPE:
+	FUniqueNetIdPtr BaseUniqueNetId;
+	FUniqueNetIdPtr EOSUniqueNetId;
+	TArray<uint8> RawBytes;
+
+private:
+	PRAGMA_DISABLE_DEPRECATION_WARNINGS
+	FUniqueNetIdEOSPlus()
+	{
+	}
+	PRAGMA_ENABLE_DEPRECATION_WARNINGS
+
+	explicit FUniqueNetIdEOSPlus(FUniqueNetIdPtr InBaseUniqueNetId, FUniqueNetIdPtr InEOSUniqueNetId);
+};
+
+using FUniqueNetIdBinaryPtr = TSharedPtr<const class FUniqueNetIdBinary>;
+using FUniqueNetIdBinaryRef = TSharedRef<const class FUniqueNetIdBinary>;
+
+class FUniqueNetIdBinary :
+	public FUniqueNetId
+{
+public:
+	virtual ~FUniqueNetIdBinary() = default;
+
+	template<typename... TArgs>
+	static FUniqueNetIdBinaryRef Create(TArgs&&... Args)
+	{
+		return MakeShareable(new FUniqueNetIdBinary(Forward<TArgs>(Args)...));
+	}
+
+	virtual FName GetType() const override
+	{
+		return Type;
+	}
+
+	virtual const uint8* GetBytes() const override
+	{
+		return RawBytes.GetData();
+	}
+
+	virtual int32 GetSize() const override
+	{
+		return RawBytes.Num();
+	}
+
+	virtual bool IsValid() const override
+	{
+		return RawBytes.Num() > 0;
+	}
+
+	virtual FString ToString() const override
+	{
+		return BytesToHex(RawBytes.GetData(), RawBytes.Num());
+	}
+	virtual FString ToDebugString() const override
+	{
+		return ToString();
+	}
+
+	/** Needed for TMap::GetTypeHash() */
+	friend uint32 GetTypeHash(const FUniqueNetIdBinary& A)
+	{
+		uint32 Hash = 0;
+		for (uint8 CurrentByte : A.RawBytes)
+		{
+			Hash = HashCombine(Hash, GetTypeHash(CurrentByte));
+		}
+		return Hash;
+	}
+
+protected:
+	TArray<uint8> RawBytes;
+	FName Type;
+
+	FUniqueNetIdBinary(const TArray<uint8>& InRawBytes, const FName InType)
+		: RawBytes(InRawBytes)
+		, Type(InType)
+	{
+	}
+
+	FUniqueNetIdBinary(const uint8* InRawBytes, const int32 InSize, const FName InType)
+		: Type(InType)
+	{
+		RawBytes.AddZeroed(InSize);
+		FMemory::Memcpy(RawBytes.GetData(), InRawBytes, InSize);
+	}
+};
+
+template<class AggregateUserType>
+class TOnlineAggregateUser :
+	public AggregateUserType
+{
+public:
+	TOnlineAggregateUser(TSharedPtr<AggregateUserType> InBase, TSharedPtr<AggregateUserType> InEOS)
+		: BaseItem(InBase)
+		, EOSItem(InEOS)
+	{
+		check(InBase.IsValid() || EOSItem.IsValid());
+	}
+
+	virtual ~TOnlineAggregateUser()
+	{
+	}
+
+// FOnlineUser interface
+	virtual FUniqueNetIdRef GetUserId() const override
+	{
+		FUniqueNetIdPtr BaseNetId;
+		if (IsBaseItemValid())
+		{
+			BaseNetId = BaseItem->GetUserId();
+		}
+		FUniqueNetIdPtr EOSNetId;
+		if (IsEOSItemValid())
+		{
+			EOSNetId = EOSItem->GetUserId();
+		}
+		return FUniqueNetIdEOSPlus::Create(BaseNetId, EOSNetId);
+	}
+
+	virtual FString GetRealName() const override
+	{
+		return GetBaseOrEOSItem()->GetRealName();
+	}
+
+	virtual FString GetDisplayName(const FString& Platform = FString()) const override
+	{
+		// If they are only an EOS user, then use that
+		if (Platform == TEXT("EOS") || !IsBaseItemValid())
+		{
+			if (IsEOSItemValid())
+			{
+				return EOSItem->GetDisplayName();
+			}
+			return FString();
+		}
+		if (IsBaseItemValid())
+		{
+			return BaseItem->GetDisplayName(Platform);
+		}
+		return FString();
+	}
+
+	virtual bool GetUserAttribute(const FString& AttrName, FString& OutAttrValue) const override
+	{
+		if (IsBaseItemValid() && BaseItem->GetUserAttribute(AttrName, OutAttrValue))
+		{
+			return true;
+		}
+		return IsEOSItemValid() && EOSItem->GetUserAttribute(AttrName, OutAttrValue);
+	}
+
+	virtual bool SetUserLocalAttribute(const FString& AttrName, const FString& AttrValue) override
+	{
+		if (IsBaseItemValid() && BaseItem->SetUserLocalAttribute(AttrName, AttrValue))
+		{
+			return true;
+		}
+		return IsEOSItemValid() && EOSItem->SetUserLocalAttribute(AttrName, AttrValue);
+	}
+// ~FOnlineUser interface
+
+	bool IsBaseItemValid() const
+	{
+		return BaseItem.IsValid();
+	}
+
+	bool IsEOSItemValid() const
+	{
+		return EOSItem.IsValid();
+	}
+
+	void SetEOSItem(TSharedPtr<AggregateUserType> InEOSItem)
+	{
+		EOSItem = InEOSItem;
+	}
+
+	TSharedPtr<AggregateUserType> GetBaseOrEOSItem()
+	{
+		return BaseItem.IsValid() ? BaseItem : EOSItem;
+	}
+
+	TSharedPtr<AggregateUserType> GetBaseOrEOSItem() const
+	{
+		return BaseItem.IsValid() ? BaseItem : EOSItem;
+	}
+
+protected:
+	TSharedPtr<AggregateUserType> BaseItem;
+	TSharedPtr<AggregateUserType> EOSItem;
+};
+
+typedef TOnlineAggregateUser<FOnlineUser> FOnlineUserPlus;
+typedef TOnlineAggregateUser<FOnlineBlockedPlayer> FOnlineBlockedPlayerPlus;
+
+class FOnlineUserAccountPlus :
+	public TOnlineAggregateUser<FUserOnlineAccount>
+{
+public:
+	FOnlineUserAccountPlus(TSharedPtr<FUserOnlineAccount> InBase, TSharedPtr<FUserOnlineAccount> InEOS)
+		: TOnlineAggregateUser<FUserOnlineAccount>(InBase, InEOS)
+	{
+	}
+
+	virtual ~FOnlineUserAccountPlus()
+	{
+	}
+
+// FUserOnlineAccount interface
+	virtual FString GetAccessToken() const override
+	{
+		return BaseItem->GetAccessToken();
+	}
+
+	virtual bool GetAuthAttribute(const FString& AttrName, FString& OutAttrValue) const override
+	{
+		if (IsBaseItemValid() && BaseItem->GetAuthAttribute(AttrName, OutAttrValue))
+		{
+			return true;
+		}
+		return IsEOSItemValid() && EOSItem->GetAuthAttribute(AttrName, OutAttrValue);
+	}
+
+	virtual bool SetUserAttribute(const FString& AttrName, const FString& AttrValue) override
+	{
+		if (IsBaseItemValid() && BaseItem->SetUserAttribute(AttrName, AttrValue))
+		{
+			return true;
+		}
+		return IsEOSItemValid() && EOSItem->SetUserAttribute(AttrName, AttrValue);
+	}
+// ~FUserOnlineAccount interface
+};
+
+class FOnlineFriendPlus :
+	public TOnlineAggregateUser<FOnlineFriend>
+{
+public:
+	FOnlineFriendPlus(TSharedPtr<FOnlineFriend> InBase, TSharedPtr<FOnlineFriend> InEOS)
+		: TOnlineAggregateUser<FOnlineFriend>(InBase, InEOS)
+	{
+	}
+
+	virtual ~FOnlineFriendPlus()
+	{
+	}
+
+// FOnlineFriend interface
+	virtual EInviteStatus::Type GetInviteStatus() const
+	{
+		EInviteStatus::Type Status = EInviteStatus::Unknown;
+		if (IsBaseItemValid())
+		{
+			Status = BaseItem->GetInviteStatus();
+		}
+		if (Status == EInviteStatus::Unknown && IsEOSItemValid())
+		{
+			Status = EOSItem->GetInviteStatus();
+		}
+		return Status;
+	}
+
+	virtual const class FOnlineUserPresence& GetPresence() const
+	{
+		if (IsBaseItemValid())
+		{
+			return BaseItem->GetPresence();
+		}
+		if (IsEOSItemValid())
+		{
+			return EOSItem->GetPresence();
+		}
+		return EmptyPresence;
+	}
+// ~FOnlineFriend interface
+
+	FOnlineUserPresence EmptyPresence;
+};
+
+class FOnlineRecentPlayerPlus :
+	public TOnlineAggregateUser<FOnlineRecentPlayer>
+{
+public:
+	FOnlineRecentPlayerPlus(TSharedPtr<FOnlineRecentPlayer> InBase, TSharedPtr<FOnlineRecentPlayer> InEOS)
+		: TOnlineAggregateUser<FOnlineRecentPlayer>(InBase, InEOS)
+	{
+	}
+
+	virtual ~FOnlineRecentPlayerPlus()
+	{
+	}
+
+// FOnlineRecentPlayer interface
+	virtual FDateTime GetLastSeen() const
+	{
+		if (IsBaseItemValid())
+		{
+			return BaseItem->GetLastSeen();
+		}
+		return FDateTime(0);
+	}
+// ~FOnlineRecentPlayer interface
+};
+
+/**
+ * Interface for combining platform users with EOS/EAS users
+ */
+class FOnlineUserEOSPlus :
+	public IOnlineUser,
+	public IOnlineIdentity,
+	public IOnlineFriends,
+	public IOnlinePresence,
+	public TSharedFromThis<FOnlineUserEOSPlus, ESPMode::ThreadSafe>
+{
+public:
+	FOnlineUserEOSPlus() = delete;
+	virtual ~FOnlineUserEOSPlus();
+
+	void Initialize();
+
+// IOnlineUser Interface
+	virtual bool QueryUserInfo(int32 LocalUserNum, const TArray<FUniqueNetIdRef>& UserIds) override;
+	virtual bool GetAllUserInfo(int32 LocalUserNum, TArray<TSharedRef<FOnlineUser>>& OutUsers) override;
+	virtual TSharedPtr<FOnlineUser> GetUserInfo(int32 LocalUserNum, const FUniqueNetId& UserId) override;
+	virtual bool QueryUserIdMapping(const FUniqueNetId& UserId, const FString& DisplayNameOrEmail, const FOnQueryUserMappingComplete& Delegate = FOnQueryUserMappingComplete()) override;
+	virtual bool QueryExternalIdMappings(const FUniqueNetId& UserId, const FExternalIdQueryOptions& QueryOptions, const TArray<FString>& ExternalIds, const FOnQueryExternalIdMappingsComplete& Delegate = FOnQueryExternalIdMappingsComplete()) override;
+	virtual void GetExternalIdMappings(const FExternalIdQueryOptions& QueryOptions, const TArray<FString>& ExternalIds, TArray<FUniqueNetIdPtr>& OutIds) override;
+	virtual FUniqueNetIdPtr GetExternalIdMapping(const FExternalIdQueryOptions& QueryOptions, const FString& ExternalId) override;
+// ~IOnlineUser Interface
+
+// IOnlineIdentity Interface
+	virtual bool Login(int32 LocalUserNum, const FOnlineAccountCredentials& AccountCredentials) override;
+	virtual bool Logout(int32 LocalUserNum) override;
+	virtual bool AutoLogin(int32 LocalUserNum) override;
+	virtual TSharedPtr<FUserOnlineAccount> GetUserAccount(const FUniqueNetId& UserId) const override;
+	virtual TArray<TSharedPtr<FUserOnlineAccount>> GetAllUserAccounts() const override;
+	virtual FUniqueNetIdPtr GetUniquePlayerId(int32 LocalUserNum) const override;
+	virtual FUniqueNetIdPtr CreateUniquePlayerId(uint8* Bytes, int32 Size) override;
+	virtual FUniqueNetIdPtr CreateUniquePlayerId(const FString& Str) override;
+	virtual ELoginStatus::Type GetLoginStatus(int32 LocalUserNum) const override;
+	virtual ELoginStatus::Type GetLoginStatus(const FUniqueNetId& UserId) const override;
+	virtual FString GetPlayerNickname(int32 LocalUserNum) const override;
+	virtual FString GetPlayerNickname(const FUniqueNetId& UserId) const override;
+	virtual FString GetAuthToken(int32 LocalUserNum) const override;
+	virtual void GetUserPrivilege(const FUniqueNetId& UserId, EUserPrivileges::Type Privilege, const FOnGetUserPrivilegeCompleteDelegate& Delegate) override;
+	virtual FString GetAuthType() const override;
+	virtual void RevokeAuthToken(const FUniqueNetId& LocalUserId, const FOnRevokeAuthTokenCompleteDelegate& Delegate) override;
+	virtual FPlatformUserId GetPlatformUserIdFromUniqueNetId(const FUniqueNetId& UniqueNetId) const override;
+	virtual void GetLinkedAccountAuthToken(int32 LocalUserNum, const FOnGetLinkedAccountAuthTokenCompleteDelegate& Delegate) const override;
+// ~IOnlineIdentity Interface
+
+// IOnlineFriends Interface
+	virtual bool ReadFriendsList(int32 LocalUserNum, const FString& ListName, const FOnReadFriendsListComplete& Delegate = FOnReadFriendsListComplete()) override;
+	virtual bool DeleteFriendsList(int32 LocalUserNum, const FString& ListName, const FOnDeleteFriendsListComplete& Delegate = FOnDeleteFriendsListComplete()) override;
+	virtual bool SendInvite(int32 LocalUserNum, const FUniqueNetId& FriendId, const FString& ListName, const FOnSendInviteComplete& Delegate = FOnSendInviteComplete()) override;
+	virtual bool AcceptInvite(int32 LocalUserNum, const FUniqueNetId& FriendId, const FString& ListName, const FOnAcceptInviteComplete& Delegate = FOnAcceptInviteComplete()) override;
+	virtual bool RejectInvite(int32 LocalUserNum, const FUniqueNetId& FriendId, const FString& ListName) override;
+	virtual bool DeleteFriend(int32 LocalUserNum, const FUniqueNetId& FriendId, const FString& ListName) override;
+	virtual bool GetFriendsList(int32 LocalUserNum, const FString& ListName, TArray< TSharedRef<FOnlineFriend> >& OutFriends) override;
+	virtual TSharedPtr<FOnlineFriend> GetFriend(int32 LocalUserNum, const FUniqueNetId& FriendId, const FString& ListName) override;
+	virtual bool IsFriend(int32 LocalUserNum, const FUniqueNetId& FriendId, const FString& ListName) override;
+	virtual bool QueryRecentPlayers(const FUniqueNetId& UserId, const FString& Namespace) override;
+	virtual bool GetRecentPlayers(const FUniqueNetId& UserId, const FString& Namespace, TArray< TSharedRef<FOnlineRecentPlayer> >& OutRecentPlayers) override;
+	virtual bool BlockPlayer(int32 LocalUserNum, const FUniqueNetId& PlayerId) override;
+	virtual bool UnblockPlayer(int32 LocalUserNum, const FUniqueNetId& PlayerId) override;
+	virtual bool QueryBlockedPlayers(const FUniqueNetId& UserId) override;
+	virtual bool GetBlockedPlayers(const FUniqueNetId& UserId, TArray< TSharedRef<FOnlineBlockedPlayer> >& OutBlockedPlayers) override;
+	virtual void DumpBlockedPlayers() const override;
+	virtual void SetFriendAlias(int32 LocalUserNum, const FUniqueNetId& FriendId, const FString& ListName, const FString& Alias, const FOnSetFriendAliasComplete& Delegate = FOnSetFriendAliasComplete()) override;
+	virtual void DeleteFriendAlias(int32 LocalUserNum, const FUniqueNetId& FriendId, const FString& ListName, const FOnDeleteFriendAliasComplete& Delegate = FOnDeleteFriendAliasComplete()) override;
+	virtual void DumpRecentPlayers() const override;
+// ~IOnlineFriends Interface
+
+// IOnlinePresence Interface
+	virtual void SetPresence(const FUniqueNetId& User, const FOnlineUserPresenceStatus& Status, const FOnPresenceTaskCompleteDelegate& Delegate = FOnPresenceTaskCompleteDelegate()) override;
+	virtual void QueryPresence(const FUniqueNetId& User, const FOnPresenceTaskCompleteDelegate& Delegate = FOnPresenceTaskCompleteDelegate()) override;
+	virtual EOnlineCachedResult::Type GetCachedPresence(const FUniqueNetId& User, TSharedPtr<FOnlineUserPresence>& OutPresence) override;
+	virtual EOnlineCachedResult::Type GetCachedPresenceForApp(const FUniqueNetId& LocalUserId, const FUniqueNetId& User, const FString& AppId, TSharedPtr<FOnlineUserPresence>& OutPresence) override;
+// ~IOnlinePresence Interface
+
+PACKAGE_SCOPE:
+	FOnlineUserEOSPlus(FOnlineSubsystemEOSPlus* InSubsystem);
+
+	// Delegates to rebroadcast things back out
+
+	// User delegates
+	void OnQueryUserInfoCompleteBase(int32 LocalUserNum, bool bWasSuccessful, const TArray< FUniqueNetIdRef >& UserIds, const FString& ErrorStr);
+
+	// Identity delegates
+	void OnLoginChanged(int32 LocalUserNum);
+	void OnEOSLoginChanged(int32 LocalUserNum);
+	void OnLoginStatusChanged(int32 LocalUserNum, ELoginStatus::Type OldStatus, ELoginStatus::Type NewStatus, const FUniqueNetId& NewId);
+	void OnControllerPairingChanged(int32 LocalUserNum, FControllerPairingChangedUserInfo PreviousUser, FControllerPairingChangedUserInfo NewUser);
+	void OnLoginComplete(int32 LocalUserNum, bool bWasSuccessful, const FUniqueNetId& UserId, const FString& Error);
+	void OnBaseLoginComplete(int32 LocalUserNum, bool bWasSuccessful, const FUniqueNetId& UserId, const FString& ErrorStr);
+	void OnLogoutComplete(int32 LocalUserNum, bool bWasSuccessful);
+
+	// Presence delegates
+	void OnPresenceReceived(const FUniqueNetId& UserId, const TSharedRef<FOnlineUserPresence>& Presence);
+	void OnPresenceArrayUpdated(const FUniqueNetId& UserId, const TArray<TSharedRef<FOnlineUserPresence>>& NewPresenceArray);
+
+	// Friends delegates 
+	void OnFriendsChanged();
+	void OnOutgoingInviteSent();
+	void OnInviteReceived(const FUniqueNetId& UserId, const FUniqueNetId& FriendId);
+	void OnInviteAccepted(const FUniqueNetId& UserId, const FUniqueNetId& FriendId);
+	void OnInviteRejected(const FUniqueNetId& UserId, const FUniqueNetId& FriendId);
+	void OnInviteAborted(const FUniqueNetId& UserId, const FUniqueNetId& FriendId);
+	void OnFriendRemoved(const FUniqueNetId& UserId, const FUniqueNetId& FriendId);
+
+	FUniqueNetIdEOSPlusPtr GetNetIdPlus(const FString& SourceId) const;
+	FUniqueNetIdPtr GetBaseNetId(const FString& SourceId) const;
+	FUniqueNetIdPtr GetEOSNetId(const FString& SourceId) const;
+
+private:
+	void AddPlayer(int32 LocalUserNum);
+	void RemovePlayer(int32 LocalUserNum);
+	FUniqueNetIdEOSPlusPtr AddRemotePlayer(FUniqueNetIdPtr BaseNetId, FUniqueNetIdPtr EOSNetId);
+	TSharedRef<FOnlineFriendPlus> AddFriend(TSharedRef<FOnlineFriend> Friend);
+	TSharedRef<FOnlineFriendPlus> GetFriend(TSharedRef<FOnlineFriend> Friend);
+	TSharedRef<FOnlineRecentPlayer> AddRecentPlayer(TSharedRef<FOnlineRecentPlayer> Player);
+	TSharedRef<FOnlineRecentPlayer> GetRecentPlayer(TSharedRef<FOnlineRecentPlayer> Player);
+	TSharedRef<FOnlineBlockedPlayer> AddBlockedPlayer(TSharedRef<FOnlineBlockedPlayer> Player);
+	TSharedRef<FOnlineBlockedPlayer> GetBlockedPlayer(TSharedRef<FOnlineBlockedPlayer> Player);
+
+	/** Reference to the owning EOS plus subsystem */
+	FOnlineSubsystemEOSPlus* EOSPlus;
+
+	IOnlineUserPtr BaseUserInterface;
+	//IOnlineUserPtr EOSUserInterface; // No EOS mirroring yet
+	IOnlineIdentityPtr BaseIdentityInterface;
+	IOnlineIdentityPtr EOSIdentityInterface;
+	IOnlineFriendsPtr BaseFriendsInterface;
+	IOnlineFriendsPtr EOSFriendsInterface;
+	IOnlinePresencePtr BasePresenceInterface;
+	IOnlinePresencePtr EOSPresenceInterface;
+
+	/** Maps of net ids */
+	TMap<FString, FUniqueNetIdEOSPlusPtr> BaseNetIdToNetIdPlus;
+	TMap<FString, FUniqueNetIdEOSPlusPtr> EOSNetIdToNetIdPlus;
+	TMap<FString, FUniqueNetIdPtr> NetIdPlusToBaseNetId;
+	TMap<FString, FUniqueNetIdPtr> NetIdPlusToEOSNetId;
+	TMap<FString, FUniqueNetIdEOSPlusPtr> NetIdPlusToNetIdPlus;
+	TMap<int32, FUniqueNetIdEOSPlusPtr> LocalUserNumToNetIdPlus;
+
+	/** Online user variants maps */
+	TMap<FString, TSharedRef<FOnlineUserAccountPlus>> NetIdPlusToUserAccountMap;
+	TMap<FString, TSharedRef<FOnlineFriendPlus>> NetIdPlusToFriendMap;
+	TMap<FString, TSharedRef<FOnlineRecentPlayerPlus>> NetIdPlusToRecentPlayerMap;
+	TMap<FString, TSharedRef<FOnlineBlockedPlayerPlus>> NetIdPlusToBlockedPlayerMap;
+
+	/** Last Login Credentials used for a login attempt */
+	TMap<int32, TSharedRef<FOnlineAccountCredentials>> LocalUserNumToLastLoginCredentials;
+};
+
+typedef TSharedPtr<FOnlineUserEOSPlus, ESPMode::ThreadSafe> FOnlineUserEOSPlusPtr;
Index: Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOSPlus/Private/OnlineStatsEOSPlus.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOSPlus/Private/OnlineStatsEOSPlus.h b/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOSPlus/Private/OnlineStatsEOSPlus.h
new file mode 100644
--- /dev/null	(date 1641576012000)
+++ b/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOSPlus/Private/OnlineStatsEOSPlus.h	(date 1641576012000)
@@ -0,0 +1,53 @@
+// Copyright Epic Games, Inc. All Rights Reserved.
+
+#pragma once
+
+#include "CoreMinimal.h"
+#include "Online/CoreOnline.h"
+#include "Interfaces/OnlineStatsInterface.h"
+#include "Interfaces/OnlineEventsInterface.h"
+#include "OnlineUserEOSPlus.h"
+
+class FOnlineSubsystemEOSPlus;
+
+/**
+ * Interface that mirrors stats on both OSSes
+ */
+class FOnlineStatsEOSPlus :
+	public IOnlineStats,
+	public IOnlineEvents
+{
+public:
+	FOnlineStatsEOSPlus() = delete;
+	virtual ~FOnlineStatsEOSPlus() = default;
+
+// IOnlineStats Interface
+	virtual void QueryStats(const FUniqueNetIdRef LocalUserId, const FUniqueNetIdRef StatsUser, const FOnlineStatsQueryUserStatsComplete& Delegate) override;
+	virtual void QueryStats(const FUniqueNetIdRef LocalUserId, const TArray<FUniqueNetIdRef>& StatUsers, const TArray<FString>& StatNames, const FOnlineStatsQueryUsersStatsComplete& Delegate) override;
+	virtual TSharedPtr<const FOnlineStatsUserStats> GetStats(const FUniqueNetIdRef StatsUserId) const override;
+	virtual void UpdateStats(const FUniqueNetIdRef LocalUserId, const TArray<FOnlineStatsUserUpdatedStats>& UpdatedUserStats, const FOnlineStatsUpdateStatsComplete& Delegate) override;
+#if !UE_BUILD_SHIPPING
+	virtual void ResetStats(const FUniqueNetIdRef StatsUserId) override;
+#endif
+// ~IOnlineStats Interface
+
+// IOnlineEvents Interface
+	virtual bool TriggerEvent(const FUniqueNetId& PlayerId, const TCHAR* EventName, const FOnlineEventParms& Parms) override;
+	virtual void SetPlayerSessionId(const FUniqueNetId& PlayerId, const FGuid& PlayerSessionId) override;
+// ~IOnlineEvents Interface
+
+PACKAGE_SCOPE:
+	FOnlineStatsEOSPlus(FOnlineSubsystemEOSPlus* InSubsystem)
+		: EOSPlus(InSubsystem)
+	{
+	}
+
+private:
+	FUniqueNetIdEOSPlusPtr GetNetIdPlus(const FString& SourceId);
+
+private:
+	/** Reference to the owning EOS plus subsystem */
+	FOnlineSubsystemEOSPlus* EOSPlus;
+};
+
+typedef TSharedPtr<FOnlineStatsEOSPlus, ESPMode::ThreadSafe> FOnlineStatsEOSPlusPtr;
Index: Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOSPlus/Private/OnlineUserCloudEOSPlus.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOSPlus/Private/OnlineUserCloudEOSPlus.cpp b/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOSPlus/Private/OnlineUserCloudEOSPlus.cpp
new file mode 100644
--- /dev/null	(date 1641576012000)
+++ b/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOSPlus/Private/OnlineUserCloudEOSPlus.cpp	(date 1641576012000)
@@ -0,0 +1,421 @@
+// Copyright Epic Games, Inc. All Rights Reserved.
+
+#include "OnlineUserCloudEOSPlus.h"
+#include "OnlineSubsystemEOSPlus.h"
+#include "OnlineError.h"
+
+FOnlineUserCloudEOSPlus::FOnlineUserCloudEOSPlus(FOnlineSubsystemEOSPlus* InSubsystem)
+	: EOSPlus(InSubsystem)
+{
+	BaseUserCloudInterface = EOSPlus->BaseOSS->GetUserCloudInterface();
+}
+
+FOnlineUserCloudEOSPlus::~FOnlineUserCloudEOSPlus()
+{
+	if (BaseUserCloudInterface.IsValid())
+	{
+		BaseUserCloudInterface->ClearOnEnumerateUserFilesCompleteDelegates(this);
+		BaseUserCloudInterface->ClearOnWriteUserFileProgressDelegates(this);
+		BaseUserCloudInterface->ClearOnWriteUserFileCompleteDelegates(this);
+		BaseUserCloudInterface->ClearOnWriteUserFileCanceledDelegates(this);
+		BaseUserCloudInterface->ClearOnReadUserFileCompleteDelegates(this);
+		BaseUserCloudInterface->ClearOnDeleteUserFileCompleteDelegates(this);
+		BaseUserCloudInterface->ClearOnRequestUsageInfoCompleteDelegates(this);
+	}
+}
+
+FUniqueNetIdEOSPlusPtr FOnlineUserCloudEOSPlus::GetNetIdPlus(const FString& SourceId) const
+{
+	return EOSPlus->UserInterfacePtr->GetNetIdPlus(SourceId);
+}
+
+void FOnlineUserCloudEOSPlus::Initialize()
+{
+	if (BaseUserCloudInterface.IsValid())
+	{
+		BaseUserCloudInterface->AddOnEnumerateUserFilesCompleteDelegate_Handle(FOnEnumerateUserFilesCompleteDelegate::CreateThreadSafeSP(this, &FOnlineUserCloudEOSPlus::OnEnumerateUserFilesComplete));
+		BaseUserCloudInterface->AddOnWriteUserFileProgressDelegate_Handle(FOnWriteUserFileProgressDelegate::CreateThreadSafeSP(this, &FOnlineUserCloudEOSPlus::OnWriteUserFileProgress));
+		BaseUserCloudInterface->AddOnWriteUserFileCompleteDelegate_Handle(FOnWriteUserFileCompleteDelegate::CreateThreadSafeSP(this, &FOnlineUserCloudEOSPlus::OnWriteUserFileComplete));
+		BaseUserCloudInterface->AddOnWriteUserFileCanceledDelegate_Handle(FOnWriteUserFileCanceledDelegate::CreateThreadSafeSP(this, &FOnlineUserCloudEOSPlus::OnWriteUserFileCanceled));
+		BaseUserCloudInterface->AddOnReadUserFileCompleteDelegate_Handle(FOnReadUserFileCompleteDelegate::CreateThreadSafeSP(this, &FOnlineUserCloudEOSPlus::OnReadUserFileComplete));
+		BaseUserCloudInterface->AddOnDeleteUserFileCompleteDelegate_Handle(FOnDeleteUserFileCompleteDelegate::CreateThreadSafeSP(this, &FOnlineUserCloudEOSPlus::OnDeleteUserFileComplete));
+		BaseUserCloudInterface->AddOnRequestUsageInfoCompleteDelegate_Handle(FOnRequestUsageInfoCompleteDelegate::CreateThreadSafeSP(this, &FOnlineUserCloudEOSPlus::OnRequestUsageInfoComplete));
+	}
+	else
+	{
+		UE_LOG_ONLINE(Warning, TEXT("[FOnlineUserCloudEOSPlus::Initialize] BaseUserCloudInterface delegates not bound. Base interface not valid"));
+	}
+}
+
+//~ Begin IOnlineUserCloud Interface
+
+bool FOnlineUserCloudEOSPlus::GetFileContents(const FUniqueNetId& UserId, const FString& FileName, TArray<uint8>& FileContents)
+{
+	bool bResult = false;
+
+	const FUniqueNetIdEOSPlusPtr NetIdPlus = GetNetIdPlus(UserId.ToString());
+	if (NetIdPlus.IsValid())
+	{
+		const bool bIsBaseNetIdValid = ensure(NetIdPlus->GetBaseNetId().IsValid());
+		const bool bIsBaseUserCloudInterfaceValid = BaseUserCloudInterface.IsValid();
+		if (bIsBaseNetIdValid && bIsBaseUserCloudInterfaceValid)
+		{
+			bResult = BaseUserCloudInterface->GetFileContents(*NetIdPlus->GetBaseNetId(), FileName, FileContents);
+		}
+		else
+		{
+			UE_LOG_ONLINE(Warning, TEXT("[FOnlineUserCloudEOSPlus::GetFileContents] Unable to call method in base interface. IsBaseNetIdValid=%s IsBaseUserCloudInterfaceValid=%s."), *LexToString(bIsBaseNetIdValid), *LexToString(bIsBaseUserCloudInterfaceValid));
+		}
+	}
+	else
+	{
+		UE_LOG_ONLINE(Warning, TEXT("[FOnlineUserCloudEOSPlus::GetFileContents] Unable to call method in base interface. Unknown user (%s)"), *UserId.ToString());
+	}
+
+	return bResult;
+}
+
+bool FOnlineUserCloudEOSPlus::ClearFiles(const FUniqueNetId& UserId)
+{
+	bool bResult = false;
+
+	const FUniqueNetIdEOSPlusPtr NetIdPlus = GetNetIdPlus(UserId.ToString());
+	if (NetIdPlus.IsValid())
+	{
+		const bool bIsBaseNetIdValid = ensure(NetIdPlus->GetBaseNetId().IsValid());
+		const bool bIsBaseUserCloudInterfaceValid = BaseUserCloudInterface.IsValid();
+		if (bIsBaseNetIdValid && bIsBaseUserCloudInterfaceValid)
+		{
+			bResult = BaseUserCloudInterface->ClearFiles(*NetIdPlus->GetBaseNetId());
+		}
+		else
+		{
+			UE_LOG_ONLINE(Warning, TEXT("[FOnlineUserCloudEOSPlus::ClearFiles] Unable to call method in base interface. IsBaseNetIdValid=%s IsBaseUserCloudInterfaceValid=%s."), *LexToString(bIsBaseNetIdValid), *LexToString(bIsBaseUserCloudInterfaceValid));
+		}
+	}
+	else
+	{
+		UE_LOG_ONLINE(Warning, TEXT("[FOnlineUserCloudEOSPlus::ClearFiles] Unable to call method in base interface. Unknown user (%s)"), *UserId.ToString());
+	}
+
+	return bResult;
+}
+
+bool FOnlineUserCloudEOSPlus::ClearFile(const FUniqueNetId& UserId, const FString& FileName)
+{
+	bool bResult = false;
+
+	const FUniqueNetIdEOSPlusPtr NetIdPlus = GetNetIdPlus(UserId.ToString());
+	if (NetIdPlus.IsValid())
+	{
+		const bool bIsBaseNetIdValid = ensure(NetIdPlus->GetBaseNetId().IsValid());
+		const bool bIsBaseUserCloudInterfaceValid = BaseUserCloudInterface.IsValid();
+		if (bIsBaseNetIdValid && bIsBaseUserCloudInterfaceValid)
+		{
+			bResult = BaseUserCloudInterface->ClearFile(*NetIdPlus->GetBaseNetId(), FileName);
+		}
+		else
+		{
+			UE_LOG_ONLINE(Warning, TEXT("[FOnlineUserCloudEOSPlus::ClearFile] Unable to call method in base interface. IsBaseNetIdValid=%s IsBaseUserCloudInterfaceValid=%s."), *LexToString(bIsBaseNetIdValid), *LexToString(bIsBaseUserCloudInterfaceValid));
+		}
+	}
+	else
+	{
+		UE_LOG_ONLINE(Warning, TEXT("[FOnlineUserCloudEOSPlus::ClearFile] Unable to call method in base interface. Unknown user (%s)"), *UserId.ToString());
+	}
+
+	return bResult;
+}
+
+void FOnlineUserCloudEOSPlus::EnumerateUserFiles(const FUniqueNetId& UserId)
+{
+	const FUniqueNetIdEOSPlusPtr NetIdPlus = GetNetIdPlus(UserId.ToString());
+	if (NetIdPlus.IsValid())
+	{
+		const bool bIsBaseNetIdValid = ensure(NetIdPlus->GetBaseNetId().IsValid());
+		const bool bIsBaseUserCloudInterfaceValid = BaseUserCloudInterface.IsValid();
+		if (bIsBaseNetIdValid && bIsBaseUserCloudInterfaceValid)
+		{
+			BaseUserCloudInterface->EnumerateUserFiles(*NetIdPlus->GetBaseNetId());
+		}
+		else
+		{
+			UE_LOG_ONLINE(Warning, TEXT("[FOnlineUserCloudEOSPlus::EnumerateUserFiles] Unable to call method in base interface. IsBaseNetIdValid=%s IsBaseUserCloudInterfaceValid=%s."), *LexToString(bIsBaseNetIdValid), *LexToString(bIsBaseUserCloudInterfaceValid));
+		}
+	}
+	else
+	{
+		UE_LOG_ONLINE(Warning, TEXT("[FOnlineUserCloudEOSPlus::EnumerateUserFiles] Unable to call method in base interface. Unknown user (%s)"), *UserId.ToString());
+	}
+}
+	
+void FOnlineUserCloudEOSPlus::GetUserFileList(const FUniqueNetId& UserId, TArray<FCloudFileHeader>& UserFiles)
+{
+	const FUniqueNetIdEOSPlusPtr NetIdPlus = GetNetIdPlus(UserId.ToString());
+	if (NetIdPlus.IsValid())
+	{
+		const bool bIsBaseNetIdValid = ensure(NetIdPlus->GetBaseNetId().IsValid());
+		const bool bIsBaseUserCloudInterfaceValid = BaseUserCloudInterface.IsValid();
+		if (bIsBaseNetIdValid && bIsBaseUserCloudInterfaceValid)
+		{
+			BaseUserCloudInterface->GetUserFileList(*NetIdPlus->GetBaseNetId(), UserFiles);
+		}
+		else
+		{
+			UE_LOG_ONLINE(Warning, TEXT("[FOnlineUserCloudEOSPlus::GetUserFileList] Unable to call method in base interface. IsBaseNetIdValid=%s IsBaseUserCloudInterfaceValid=%s."), *LexToString(bIsBaseNetIdValid), *LexToString(bIsBaseUserCloudInterfaceValid));
+		}
+	}
+	else
+	{
+		UE_LOG_ONLINE(Warning, TEXT("[FOnlineUserCloudEOSPlus::GetUserFileList] Unable to call method in base interface. Unknown user (%s)"), *UserId.ToString());
+	}
+}
+	
+bool FOnlineUserCloudEOSPlus::ReadUserFile(const FUniqueNetId& UserId, const FString& FileName)
+{
+	bool bResult = false;
+
+	const FUniqueNetIdEOSPlusPtr NetIdPlus = GetNetIdPlus(UserId.ToString());
+	if (NetIdPlus.IsValid())
+	{
+		const bool bIsBaseNetIdValid = ensure(NetIdPlus->GetBaseNetId().IsValid());
+		const bool bIsBaseUserCloudInterfaceValid = BaseUserCloudInterface.IsValid();
+		if (bIsBaseNetIdValid && bIsBaseUserCloudInterfaceValid)
+		{
+			bResult = BaseUserCloudInterface->ReadUserFile(*NetIdPlus->GetBaseNetId(), FileName);
+		}
+		else
+		{
+			UE_LOG_ONLINE(Warning, TEXT("[FOnlineUserCloudEOSPlus::ReadUserFile] Unable to call method in base interface. IsBaseNetIdValid=%s IsBaseUserCloudInterfaceValid=%s."), *LexToString(bIsBaseNetIdValid), *LexToString(bIsBaseUserCloudInterfaceValid));
+		}
+	}
+	else
+	{
+		UE_LOG_ONLINE(Warning, TEXT("[FOnlineUserCloudEOSPlus::ReadUserFile] Unable to call method in base interface. Unknown user (%s)"), *UserId.ToString());
+	}
+
+	return bResult;
+}
+	
+bool FOnlineUserCloudEOSPlus::WriteUserFile(const FUniqueNetId& UserId, const FString& FileName, TArray<uint8>& FileContents, bool bCompressBeforeUpload)
+{
+	bool bResult = false;
+
+	const FUniqueNetIdEOSPlusPtr NetIdPlus = GetNetIdPlus(UserId.ToString());
+	if (NetIdPlus.IsValid())
+	{
+		const bool bIsBaseNetIdValid = ensure(NetIdPlus->GetBaseNetId().IsValid());
+		const bool bIsBaseUserCloudInterfaceValid = BaseUserCloudInterface.IsValid();
+		if (bIsBaseNetIdValid && bIsBaseUserCloudInterfaceValid)
+		{
+			bResult = BaseUserCloudInterface->WriteUserFile(*NetIdPlus->GetBaseNetId(), FileName, FileContents, bCompressBeforeUpload);
+		}
+		else
+		{
+			UE_LOG_ONLINE(Warning, TEXT("[FOnlineUserCloudEOSPlus::WriteUserFile] Unable to call method in base interface. IsBaseNetIdValid=%s IsBaseUserCloudInterfaceValid=%s."), *LexToString(bIsBaseNetIdValid), *LexToString(bIsBaseUserCloudInterfaceValid));
+		}
+	}
+	else
+	{
+		UE_LOG_ONLINE(Warning, TEXT("[FOnlineUserCloudEOSPlus::WriteUserFile] Unable to call method in base interface. Unknown user (%s)"), *UserId.ToString());
+	}
+
+	return bResult;
+}
+	
+void FOnlineUserCloudEOSPlus::CancelWriteUserFile(const FUniqueNetId& UserId, const FString& FileName)
+{
+	const FUniqueNetIdEOSPlusPtr NetIdPlus = GetNetIdPlus(UserId.ToString());
+	if (NetIdPlus.IsValid())
+	{
+		const bool bIsBaseNetIdValid = ensure(NetIdPlus->GetBaseNetId().IsValid());
+		const bool bIsBaseUserCloudInterfaceValid = BaseUserCloudInterface.IsValid();
+		if (bIsBaseNetIdValid && bIsBaseUserCloudInterfaceValid)
+		{
+			BaseUserCloudInterface->CancelWriteUserFile(*NetIdPlus->GetBaseNetId(), FileName);
+		}
+		else
+		{
+			UE_LOG_ONLINE(Warning, TEXT("[FOnlineUserCloudEOSPlus::CancelWriteUserFile] Unable to call method in base interface. IsBaseNetIdValid=%s IsBaseUserCloudInterfaceValid=%s."), *LexToString(bIsBaseNetIdValid), *LexToString(bIsBaseUserCloudInterfaceValid));
+		}
+	}
+	else
+	{
+		UE_LOG_ONLINE(Warning, TEXT("[FOnlineUserCloudEOSPlus::CancelWriteUserFile] Unable to call method in base interface. Unknown user (%s)"), *UserId.ToString());
+	}
+}
+
+bool FOnlineUserCloudEOSPlus::DeleteUserFile(const FUniqueNetId& UserId, const FString& FileName, bool bShouldCloudDelete, bool bShouldLocallyDelete)
+{
+	bool bResult = false;
+
+	const FUniqueNetIdEOSPlusPtr NetIdPlus = GetNetIdPlus(UserId.ToString());
+	if (NetIdPlus.IsValid())
+	{
+		const bool bIsBaseNetIdValid = ensure(NetIdPlus->GetBaseNetId().IsValid());
+		const bool bIsBaseUserCloudInterfaceValid = BaseUserCloudInterface.IsValid();
+		if (bIsBaseNetIdValid && bIsBaseUserCloudInterfaceValid)
+		{
+			bResult = BaseUserCloudInterface->DeleteUserFile(*NetIdPlus->GetBaseNetId(), FileName, bShouldCloudDelete, bShouldLocallyDelete);
+		}
+		else
+		{
+			UE_LOG_ONLINE(Warning, TEXT("[FOnlineUserCloudEOSPlus::DeleteUserFile] Unable to call method in base interface. IsBaseNetIdValid=%s IsBaseUserCloudInterfaceValid=%s."), *LexToString(bIsBaseNetIdValid), *LexToString(bIsBaseUserCloudInterfaceValid));
+		}
+	}
+	else
+	{
+		UE_LOG_ONLINE(Warning, TEXT("[FOnlineUserCloudEOSPlus::DeleteUserFile] Unable to call method in base interface. Unknown user (%s)"), *UserId.ToString());
+	}
+
+	return bResult;
+}
+
+bool FOnlineUserCloudEOSPlus::RequestUsageInfo(const FUniqueNetId& UserId)
+{
+	bool bResult = false;
+
+	const FUniqueNetIdEOSPlusPtr NetIdPlus = GetNetIdPlus(UserId.ToString());
+	if (NetIdPlus.IsValid())
+	{
+		const bool bIsBaseNetIdValid = ensure(NetIdPlus->GetBaseNetId().IsValid());
+		const bool bIsBaseUserCloudInterfaceValid = BaseUserCloudInterface.IsValid();
+		if (bIsBaseNetIdValid && bIsBaseUserCloudInterfaceValid)
+		{
+			bResult = BaseUserCloudInterface->RequestUsageInfo(*NetIdPlus->GetBaseNetId());
+		}
+		else
+		{
+			UE_LOG_ONLINE(Warning, TEXT("[FOnlineUserCloudEOSPlus::RequestUsageInfo] Unable to call method in base interface. IsBaseNetIdValid=%s IsBaseUserCloudInterfaceValid=%s."), *LexToString(bIsBaseNetIdValid), *LexToString(bIsBaseUserCloudInterfaceValid));
+		}
+	}
+	else
+	{
+		UE_LOG_ONLINE(Warning, TEXT("[FOnlineUserCloudEOSPlus::RequestUsageInfo] Unable to call method in base interface. Unknown user (%s)"), *UserId.ToString());
+	}
+
+	return bResult;
+}
+
+void FOnlineUserCloudEOSPlus::DumpCloudState(const FUniqueNetId& UserId)
+{
+	const FUniqueNetIdEOSPlusPtr NetIdPlus = GetNetIdPlus(UserId.ToString());
+	if (NetIdPlus.IsValid())
+	{
+		const bool bIsBaseNetIdValid = ensure(NetIdPlus->GetBaseNetId().IsValid());
+		const bool bIsBaseUserCloudInterfaceValid = BaseUserCloudInterface.IsValid();
+		if (bIsBaseNetIdValid && bIsBaseUserCloudInterfaceValid)
+		{
+			BaseUserCloudInterface->DumpCloudState(*NetIdPlus->GetBaseNetId());
+		}
+		else
+		{
+			UE_LOG_ONLINE(Warning, TEXT("[FOnlineUserCloudEOSPlus::DumpCloudState] Unable to call method in base interface. IsBaseNetIdValid=%s IsBaseUserCloudInterfaceValid=%s."), *LexToString(bIsBaseNetIdValid), *LexToString(bIsBaseUserCloudInterfaceValid));
+		}
+	}
+	else
+	{
+		UE_LOG_ONLINE(Warning, TEXT("[FOnlineUserCloudEOSPlus::DumpCloudState] Unable to call method in base interface. Unknown user (%s)"), *UserId.ToString());
+	}
+}
+
+void FOnlineUserCloudEOSPlus::DumpCloudFileState(const FUniqueNetId& UserId, const FString& FileName)
+{
+	const FUniqueNetIdEOSPlusPtr NetIdPlus = GetNetIdPlus(UserId.ToString());
+	if (NetIdPlus.IsValid())
+	{
+		const bool bIsBaseNetIdValid = ensure(NetIdPlus->GetBaseNetId().IsValid());
+		const bool bIsBaseUserCloudInterfaceValid = BaseUserCloudInterface.IsValid();
+		if (bIsBaseNetIdValid && bIsBaseUserCloudInterfaceValid)
+		{
+			BaseUserCloudInterface->DumpCloudFileState(*NetIdPlus->GetBaseNetId(), FileName);
+		}
+		else
+		{
+			UE_LOG_ONLINE(Warning, TEXT("[FOnlineUserCloudEOSPlus::DumpCloudFileState] Unable to call method in base interface. IsBaseNetIdValid=%s IsBaseUserCloudInterfaceValid=%s."), *LexToString(bIsBaseNetIdValid), *LexToString(bIsBaseUserCloudInterfaceValid));
+		}
+	}
+	else
+	{
+		UE_LOG_ONLINE(Warning, TEXT("[FOnlineUserCloudEOSPlus::DumpCloudFileState] Unable to call method in base interface. Unknown user (%s)"), *UserId.ToString());
+	}
+}
+
+void FOnlineUserCloudEOSPlus::OnEnumerateUserFilesComplete(bool bWasSuccessful, const FUniqueNetId& UserId)
+{
+	const FUniqueNetIdEOSPlusPtr NetIdPlus = GetNetIdPlus(UserId.ToString());
+	if (!NetIdPlus.IsValid())
+	{
+		UE_LOG_ONLINE(Warning, TEXT("[FOnlineUserCloudEOSPlus::OnEnumerateUserFilesComplete] Unknown user (%s)"), *UserId.ToString());
+	}
+
+	TriggerOnEnumerateUserFilesCompleteDelegates(bWasSuccessful, *NetIdPlus);
+}
+
+void FOnlineUserCloudEOSPlus::OnWriteUserFileProgress(int32 BytesWritten, const FUniqueNetId& UserId, const FString& FileName)
+{
+	const FUniqueNetIdEOSPlusPtr NetIdPlus = GetNetIdPlus(UserId.ToString());
+	if (!NetIdPlus.IsValid())
+	{
+		UE_LOG_ONLINE(Warning, TEXT("[FOnlineUserCloudEOSPlus::OnWriteUserFileProgress] Unknown user (%s)"), *UserId.ToString());
+	}
+
+	TriggerOnWriteUserFileProgressDelegates(BytesWritten, *NetIdPlus, FileName);
+}
+
+void FOnlineUserCloudEOSPlus::OnWriteUserFileComplete(bool bWasSuccessful, const FUniqueNetId& UserId, const FString& FileName)
+{
+	const FUniqueNetIdEOSPlusPtr NetIdPlus = GetNetIdPlus(UserId.ToString());
+	if (!NetIdPlus.IsValid())
+	{
+		UE_LOG_ONLINE(Warning, TEXT("[FOnlineUserCloudEOSPlus::OnWriteUserFileComplete] Unknown user (%s)"), *UserId.ToString());
+	}
+
+	TriggerOnWriteUserFileCompleteDelegates(bWasSuccessful, *NetIdPlus, FileName);
+}
+
+void FOnlineUserCloudEOSPlus::OnWriteUserFileCanceled(bool bWasSuccessful, const FUniqueNetId& UserId, const FString& FileName)
+{
+	const FUniqueNetIdEOSPlusPtr NetIdPlus = GetNetIdPlus(UserId.ToString());
+	if (!NetIdPlus.IsValid())
+	{
+		UE_LOG_ONLINE(Warning, TEXT("[FOnlineUserCloudEOSPlus::OnWriteUserFileCanceled] Unknown user (%s)"), *UserId.ToString());
+	}
+
+	TriggerOnWriteUserFileCanceledDelegates(bWasSuccessful, *NetIdPlus, FileName);
+}
+
+void FOnlineUserCloudEOSPlus::OnReadUserFileComplete(bool bWasSuccessful, const FUniqueNetId& UserId, const FString& FileName)
+{
+	const FUniqueNetIdEOSPlusPtr NetIdPlus = GetNetIdPlus(UserId.ToString());
+	if (!NetIdPlus.IsValid())
+	{
+		UE_LOG_ONLINE(Warning, TEXT("[FOnlineUserCloudEOSPlus::OnReadUserFileComplete] Unknown user (%s)"), *UserId.ToString());
+	}
+
+	TriggerOnReadUserFileCompleteDelegates(bWasSuccessful, *NetIdPlus, FileName);
+}
+
+void FOnlineUserCloudEOSPlus::OnDeleteUserFileComplete(bool bWasSuccessful, const FUniqueNetId& UserId, const FString& FileName)
+{
+	const FUniqueNetIdEOSPlusPtr NetIdPlus = GetNetIdPlus(UserId.ToString());
+	if (!NetIdPlus.IsValid())
+	{
+		UE_LOG_ONLINE(Warning, TEXT("[FOnlineUserCloudEOSPlus::OnDeleteUserFileComplete] Unknown user (%s)"), *UserId.ToString());
+	}
+
+	TriggerOnDeleteUserFileCompleteDelegates(bWasSuccessful, *NetIdPlus, FileName);
+}
+	
+void FOnlineUserCloudEOSPlus::OnRequestUsageInfoComplete(bool bWasSuccessful, const FUniqueNetId& UserId, int64 BytesUsed, const TOptional<int64>& TotalQuota)
+{
+	const FUniqueNetIdEOSPlusPtr NetIdPlus = GetNetIdPlus(UserId.ToString());
+	if (!NetIdPlus.IsValid())
+	{
+		UE_LOG_ONLINE(Warning, TEXT("[FOnlineUserCloudEOSPlus::OnRequestUsageInfoComplete] Unknown user (%s)"), *UserId.ToString());
+	}
+
+	TriggerOnRequestUsageInfoCompleteDelegates(bWasSuccessful, *NetIdPlus, BytesUsed, TotalQuota);
+}
+	
+//~ End IOnlineUserCloud Interface
\ No newline at end of file
Index: Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOSPlus/Private/OnlineStoreEOSPlus.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOSPlus/Private/OnlineStoreEOSPlus.h b/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOSPlus/Private/OnlineStoreEOSPlus.h
new file mode 100644
--- /dev/null	(date 1641576012000)
+++ b/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOSPlus/Private/OnlineStoreEOSPlus.h	(date 1641576012000)
@@ -0,0 +1,64 @@
+// Copyright Epic Games, Inc. All Rights Reserved.
+
+#pragma once
+
+#include "CoreMinimal.h"
+#include "Online/CoreOnline.h"
+#include "OnlineSubsystem.h"
+#include "Interfaces/OnlineStoreInterfaceV2.h"
+#include "Interfaces/OnlinePurchaseInterface.h"
+#include "OnlineUserEOSPlus.h"
+
+class FOnlineSubsystemEOSPlus;
+
+/**
+ * Interface for encapsulating the platform store interface
+ */
+class FOnlineStoreEOSPlus :
+	public IOnlineStoreV2,
+	public IOnlinePurchase,
+	public TSharedFromThis<FOnlineStoreEOSPlus, ESPMode::ThreadSafe>
+{
+public:
+	FOnlineStoreEOSPlus() = delete;
+	virtual ~FOnlineStoreEOSPlus();
+
+	void Initialize();
+
+	//~ Begin IOnlineStoreV2 Interface
+	virtual void QueryCategories(const FUniqueNetId& UserId, const FOnQueryOnlineStoreCategoriesComplete& Delegate = FOnQueryOnlineStoreCategoriesComplete()) override;
+	virtual void GetCategories(TArray<FOnlineStoreCategory>& OutCategories) const override;
+	virtual void QueryOffersByFilter(const FUniqueNetId& UserId, const FOnlineStoreFilter& Filter, const FOnQueryOnlineStoreOffersComplete& Delegate = FOnQueryOnlineStoreOffersComplete()) override;
+	virtual void QueryOffersById(const FUniqueNetId& UserId, const TArray<FUniqueOfferId>& OfferIds, const FOnQueryOnlineStoreOffersComplete& Delegate = FOnQueryOnlineStoreOffersComplete()) override;
+	virtual void GetOffers(TArray<FOnlineStoreOfferRef>& OutOffers) const override;
+	virtual TSharedPtr<FOnlineStoreOffer> GetOffer(const FUniqueOfferId& OfferId) const override;
+	//~ End IOnlineStoreV2 Interface
+
+	//~ Begin IOnlinePurchase Interface
+	virtual bool IsAllowedToPurchase(const FUniqueNetId& UserId) override;
+	virtual void Checkout(const FUniqueNetId& UserId, const FPurchaseCheckoutRequest& CheckoutRequest, const FOnPurchaseCheckoutComplete& Delegate) override;
+	virtual void FinalizePurchase(const FUniqueNetId& UserId, const FString& ReceiptId) override;
+	virtual void RedeemCode(const FUniqueNetId& UserId, const FRedeemCodeRequest& RedeemCodeRequest, const FOnPurchaseRedeemCodeComplete& Delegate) override;
+	virtual void QueryReceipts(const FUniqueNetId& UserId, bool bRestoreReceipts, const FOnQueryReceiptsComplete& Delegate) override;
+	virtual void GetReceipts(const FUniqueNetId& UserId, TArray<FPurchaseReceipt>& OutReceipts) const override;
+	virtual void FinalizeReceiptValidationInfo(const FUniqueNetId& UserId, FString& InReceiptValidationInfo, const FOnFinalizeReceiptValidationInfoComplete& Delegate) override;
+	//~ End IOnlinePurchase Interface
+
+PACKAGE_SCOPE:
+	FOnlineStoreEOSPlus(FOnlineSubsystemEOSPlus* InSubsystem);
+
+	void OnQueryForAvailablePurchasesCompleteBase(bool bWasSuccessful);
+	void OnUnexpectedPurchaseReceiptBase(const FUniqueNetId& UserId);
+
+private:
+	FUniqueNetIdEOSPlusPtr GetNetIdPlus(const FString& SourceId) const;
+
+	/** Reference to the owning EOS plus subsystem */
+	FOnlineSubsystemEOSPlus* EOSPlus;
+	
+	// We don't support EOS mirroring yet
+	IOnlineStoreV2Ptr BaseStoreInterface;
+	IOnlinePurchasePtr BasePurchaseInterface;
+};
+
+typedef TSharedPtr<FOnlineStoreEOSPlus, ESPMode::ThreadSafe> FOnlineStoreEOSPlusPtr;
Index: Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOSPlus/Private/OnlineSubsystemModuleEOSPlus.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOSPlus/Private/OnlineSubsystemModuleEOSPlus.cpp b/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOSPlus/Private/OnlineSubsystemModuleEOSPlus.cpp
new file mode 100644
--- /dev/null	(date 1641576012000)
+++ b/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOSPlus/Private/OnlineSubsystemModuleEOSPlus.cpp	(date 1641576012000)
@@ -0,0 +1,88 @@
+// Copyright Epic Games, Inc. All Rights Reserved.
+
+#include "OnlineSubsystemEOSPlusModule.h"
+#include "OnlineSubsystemModule.h"
+#include "OnlineSubsystemNames.h"
+#include "OnlineSubsystemEOSPlus.h"
+
+#include "Features/IModularFeature.h"
+#include "Features/IModularFeatures.h"
+#include "Misc/ConfigCacheIni.h"
+
+#define LOCTEXT_NAMESPACE "EOSPlus"
+
+IMPLEMENT_MODULE(FOnlineSubsystemEOSPlusModule, OnlineSubsystemEOSPlus);
+
+/**
+ * Class responsible for creating instance(s) of the subsystem
+ */
+class FOnlineFactoryEOSPlus :
+	public IOnlineFactory
+{
+public:
+
+	FOnlineFactoryEOSPlus() {}
+	virtual ~FOnlineFactoryEOSPlus() {}
+
+	virtual IOnlineSubsystemPtr CreateSubsystem(FName InstanceName)
+	{
+		FOnlineSubsystemEOSPlusPtr OnlineSub = MakeShared<FOnlineSubsystemEOSPlus, ESPMode::ThreadSafe>(InstanceName);
+		if (!OnlineSub->Init())
+		{
+			UE_LOG_ONLINE(Warning, TEXT("EOSPlus failed to initialize!"));
+			OnlineSub->Shutdown();
+			OnlineSub = nullptr;
+		}
+
+		return OnlineSub;
+	}
+};
+
+void FOnlineSubsystemEOSPlusModule::StartupModule()
+{
+	if (IsRunningCommandlet())
+	{
+		return;
+	}
+
+	// Force loading of the EOS OSS module in case the plugin manager failed to get the dependencies right
+	FModuleManager::LoadModuleChecked<FOnlineSubsystemModule>(TEXT("OnlineSubsystemEOS"));
+	// Make sure the base OSS has a chance to register its OSS factory
+	LoadBaseOSS();
+
+	PlusFactory = new FOnlineFactoryEOSPlus();
+
+	// Create and register our singleton factory with the main online subsystem for easy access
+	FOnlineSubsystemModule& OSS = FModuleManager::GetModuleChecked<FOnlineSubsystemModule>("OnlineSubsystem");
+	OSS.RegisterPlatformService(EOSPLUS_SUBSYSTEM, PlusFactory);
+}
+
+void FOnlineSubsystemEOSPlusModule::ShutdownModule()
+{
+	FOnlineSubsystemModule& OSS = FModuleManager::GetModuleChecked<FOnlineSubsystemModule>("OnlineSubsystem");
+	OSS.UnregisterPlatformService(EOSPLUS_SUBSYSTEM);
+
+	delete PlusFactory;
+	PlusFactory = nullptr;
+}
+
+void FOnlineSubsystemEOSPlusModule::LoadBaseOSS()
+{
+	FString BaseOSSName;
+	GConfig->GetString(TEXT("[OnlineSubsystemEOSPlus]"), TEXT("BaseOSSName"), BaseOSSName, GEngineIni);
+	if (BaseOSSName.IsEmpty())
+	{
+		// Load the native platform OSS name
+		GConfig->GetString(TEXT("OnlineSubsystem"), TEXT("NativePlatformService"), BaseOSSName, GEngineIni);
+	}
+	if (BaseOSSName.IsEmpty())
+	{
+		UE_LOG_ONLINE(Verbose, TEXT("EOSPlus failed to find the native OSS!"));
+		return;
+	}
+	// Load the module for the base OSS
+	FString ModuleName(TEXT("OnlineSubsystem") + BaseOSSName);
+	FModuleManager::LoadModuleChecked<FOnlineSubsystemModule>(*ModuleName);
+}
+
+#undef LOCTEXT_NAMESPACE
Index: Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOSPlus/Private/OnlineLeaderboardsEOSPlus.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOSPlus/Private/OnlineLeaderboardsEOSPlus.h b/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOSPlus/Private/OnlineLeaderboardsEOSPlus.h
new file mode 100644
--- /dev/null	(date 1641576012000)
+++ b/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOSPlus/Private/OnlineLeaderboardsEOSPlus.h	(date 1641576012000)
@@ -0,0 +1,54 @@
+// Copyright Epic Games, Inc. All Rights Reserved.
+
+#pragma once
+
+#include "CoreMinimal.h"
+#include "Online/CoreOnline.h"
+#include "OnlineSubsystem.h"
+#include "Interfaces/OnlineLeaderboardInterface.h"
+#include "OnlineUserEOSPlus.h"
+
+class FOnlineSubsystemEOSPlus;
+
+/**
+ * Interface for mirroring platform leaderboards to EOS leaderboards
+ */
+class FOnlineLeaderboardsEOSPlus :
+	public IOnlineLeaderboards,
+	public TSharedFromThis<FOnlineLeaderboardsEOSPlus, ESPMode::ThreadSafe>
+{
+public:
+	FOnlineLeaderboardsEOSPlus() = delete;
+	virtual ~FOnlineLeaderboardsEOSPlus();
+
+	void Initialize();
+
+// IOnlineLeaderboards Interface
+	virtual bool ReadLeaderboards(const TArray< FUniqueNetIdRef >& Players, FOnlineLeaderboardReadRef& ReadObject) override;
+	virtual bool ReadLeaderboardsForFriends(int32 LocalUserNum, FOnlineLeaderboardReadRef& ReadObject) override;
+	virtual bool ReadLeaderboardsAroundRank(int32 Rank, uint32 Range, FOnlineLeaderboardReadRef& ReadObject) override;
+	virtual bool ReadLeaderboardsAroundUser(FUniqueNetIdRef Player, uint32 Range, FOnlineLeaderboardReadRef& ReadObject) override;
+	virtual void FreeStats(FOnlineLeaderboardRead& ReadObject) override;
+	virtual bool WriteLeaderboards(const FName& SessionName, const FUniqueNetId& Player, FOnlineLeaderboardWrite& WriteObject) override;
+	virtual bool FlushLeaderboards(const FName& SessionName) override;
+	virtual bool WriteOnlinePlayerRatings(const FName& SessionName, int32 LeaderboardId, const TArray<FOnlinePlayerScore>& PlayerScores) override;
+// ~IOnlineLeaderboards Interface
+
+PACKAGE_SCOPE:
+	FOnlineLeaderboardsEOSPlus(FOnlineSubsystemEOSPlus* InSubsystem);
+
+	void OnLeaderboardReadComplete(bool bWasSuccessful);
+	void OnLeaderboardFlushComplete(const FName SessionName, bool bWasSuccessful);
+
+private:
+	FUniqueNetIdEOSPlusPtr GetNetIdPlus(const FString& SourceId);
+
+	/** Reference to the owning EOS plus subsystem */
+	FOnlineSubsystemEOSPlus* EOSPlus;
+
+	// We don't support EOS mirroring yet
+	// IOnlineLeaderboardsPtr EOSLeaderboardsInterface;
+	IOnlineLeaderboardsPtr BaseLeaderboardsInterface;
+};
+
+typedef TSharedPtr<FOnlineLeaderboardsEOSPlus, ESPMode::ThreadSafe> FOnlineLeaderboardsEOSPlusPtr;
Index: Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOSPlus/Private/OnlineStatsEOSPlus.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOSPlus/Private/OnlineStatsEOSPlus.cpp b/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOSPlus/Private/OnlineStatsEOSPlus.cpp
new file mode 100644
--- /dev/null	(date 1641575208000)
+++ b/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOSPlus/Private/OnlineStatsEOSPlus.cpp	(date 1641575208000)
@@ -0,0 +1,133 @@
+// Copyright Epic Games, Inc. All Rights Reserved.
+
+#include "OnlineStatsEOSPlus.h"
+#include "OnlineSubsystem.h"
+#include "OnlineSubsystemEOSPlus.h"
+#include "EOSSettings.h"
+
+FUniqueNetIdEOSPlusPtr FOnlineStatsEOSPlus::GetNetIdPlus(const FString& SourceId)
+{
+	return EOSPlus->UserInterfacePtr->GetNetIdPlus(SourceId);
+}
+
+void FOnlineStatsEOSPlus::QueryStats(const FUniqueNetIdRef LocalUserId, const FUniqueNetIdRef StatsUser, const FOnlineStatsQueryUserStatsComplete& Delegate)
+{
+	IOnlineStatsPtr Stats = EOSPlus->BaseOSS->GetStatsInterface();
+	if (Stats.IsValid())
+	{
+		Stats->QueryStats(LocalUserId, StatsUser, Delegate);
+	}
+}
+
+void FOnlineStatsEOSPlus::QueryStats(const FUniqueNetIdRef LocalUserId, const TArray<FUniqueNetIdRef>& StatUsers, const TArray<FString>& StatNames, const FOnlineStatsQueryUsersStatsComplete& Delegate)
+{
+	IOnlineStatsPtr Stats = EOSPlus->BaseOSS->GetStatsInterface();
+	if (Stats.IsValid())
+	{
+		Stats->QueryStats(LocalUserId, StatUsers, StatNames, Delegate);
+	}
+}
+
+TSharedPtr<const FOnlineStatsUserStats> FOnlineStatsEOSPlus::GetStats(const FUniqueNetIdRef StatsUserId) const
+{
+	IOnlineStatsPtr Stats = EOSPlus->BaseOSS->GetStatsInterface();
+	if (Stats.IsValid())
+	{
+		return Stats->GetStats(StatsUserId);
+	}
+	return nullptr;
+}
+
+FOnlineStatsUpdateStatsComplete IgnoredStatsComplete;
+
+void FOnlineStatsEOSPlus::UpdateStats(const FUniqueNetIdRef LocalUserId, const TArray<FOnlineStatsUserUpdatedStats>& UpdatedUserStats, const FOnlineStatsUpdateStatsComplete& Delegate)
+{
+	FUniqueNetIdEOSPlusPtr NetIdPlus = GetNetIdPlus(LocalUserId->ToString());
+	if (NetIdPlus.IsValid())
+	{
+		// This one is the one that will fire the delegate upon completion
+		IOnlineStatsPtr Stats = EOSPlus->BaseOSS->GetStatsInterface();
+		if (Stats.IsValid())
+		{
+			// We send a processed copy of the updated stats to the base interface, with the corresponding base user ids
+			TArray<FOnlineStatsUserUpdatedStats> BaseUpdatedUserStats;
+
+			for (const FOnlineStatsUserUpdatedStats& UserStat : UpdatedUserStats)
+			{
+				FUniqueNetIdEOSPlusPtr UserStatNetIdPlus = GetNetIdPlus(UserStat.Account->ToString());
+				if (UserStatNetIdPlus.IsValid())
+				{
+					FOnlineStatsUserUpdatedStats& BaseUpdatedStats = BaseUpdatedUserStats.Emplace_GetRef(UserStatNetIdPlus->GetBaseNetId().ToSharedRef());
+					BaseUpdatedStats.Stats = UserStat.Stats;
+				}
+			}
+
+			Stats->UpdateStats(NetIdPlus->GetBaseNetId().ToSharedRef(), BaseUpdatedUserStats, Delegate);
+		}
+
+		const FEOSSettings& EOSSettings = UEOSSettings::GetSettings();
+		if (EOSSettings.bMirrorStatsToEOS)
+		{
+			// Also write the data to EOS
+			IOnlineStatsPtr EOSStats = EOSPlus->EosOSS->GetStatsInterface();
+			if (EOSStats.IsValid())
+			{
+				// We send a processed copy of the updated stats to the EOS interface, with the corresponding EOS user ids
+				TArray<FOnlineStatsUserUpdatedStats> EOSUpdatedUserStats;
+
+				for (const FOnlineStatsUserUpdatedStats& UserStat : UpdatedUserStats)
+				{
+					FUniqueNetIdEOSPlusPtr UserStatNetIdPlus = GetNetIdPlus(UserStat.Account->ToString());
+
+					if (UserStatNetIdPlus.IsValid())
+					{
+						FOnlineStatsUserUpdatedStats& EOSUpdatedStats = EOSUpdatedUserStats.Emplace_GetRef(UserStatNetIdPlus->GetEOSNetId().ToSharedRef());
+						EOSUpdatedStats.Stats = UserStat.Stats;
+					}
+				}
+
+				EOSStats->UpdateStats(NetIdPlus->GetEOSNetId().ToSharedRef(), EOSUpdatedUserStats, IgnoredStatsComplete);
+			}
+		}
+	}
+}
+
+#if !UE_BUILD_SHIPPING
+void FOnlineStatsEOSPlus::ResetStats(const FUniqueNetIdRef StatsUserId)
+{
+	// Only need to forward to the base since EOS doesn't support this
+	IOnlineStatsPtr Stats = EOSPlus->BaseOSS->GetStatsInterface();
+	if (Stats.IsValid())
+	{
+		Stats->ResetStats(StatsUserId);
+	}
+}
+#endif
+
+bool FOnlineStatsEOSPlus::TriggerEvent(const FUniqueNetId& PlayerId, const TCHAR* EventName, const FOnlineEventParms& Parms)
+{
+	IOnlineEventsPtr Events = EOSPlus->BaseOSS->GetEventsInterface();
+	if (Events.IsValid())
+	{
+		FUniqueNetIdEOSPlusPtr NetIdPlus = GetNetIdPlus(PlayerId.ToString());
+		if (NetIdPlus.IsValid())
+		{
+			return Events->TriggerEvent(*NetIdPlus->GetBaseNetId(), EventName, Parms);
+		}
+	}
+
+	return false;
+}
+
+void FOnlineStatsEOSPlus::SetPlayerSessionId(const FUniqueNetId& PlayerId, const FGuid& PlayerSessionId)
+{
+	IOnlineEventsPtr Events = EOSPlus->BaseOSS->GetEventsInterface();
+	if (Events.IsValid())
+	{
+		FUniqueNetIdEOSPlusPtr NetIdPlus = GetNetIdPlus(PlayerId.ToString());
+		if (NetIdPlus.IsValid())
+		{
+			Events->SetPlayerSessionId(*NetIdPlus->GetBaseNetId(), PlayerSessionId);
+		}
+	}
+}
Index: Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOSPlus/Private/OnlineUserCloudEOSPlus.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOSPlus/Private/OnlineUserCloudEOSPlus.h b/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOSPlus/Private/OnlineUserCloudEOSPlus.h
new file mode 100644
--- /dev/null	(date 1641576012000)
+++ b/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOSPlus/Private/OnlineUserCloudEOSPlus.h	(date 1641576012000)
@@ -0,0 +1,62 @@
+// Copyright Epic Games, Inc. All Rights Reserved.
+
+#pragma once
+
+#include "CoreMinimal.h"
+#include "Online/CoreOnline.h"
+#include "OnlineSubsystem.h"
+#include "Interfaces/OnlineUserCloudInterface.h"
+#include "OnlineUserEOSPlus.h"
+
+class FOnlineSubsystemEOSPlus;
+
+/**
+ * Interface for encapsulating the platform user cloud interface
+ */
+class FOnlineUserCloudEOSPlus :
+	public IOnlineUserCloud,
+	public TSharedFromThis<FOnlineUserCloudEOSPlus, ESPMode::ThreadSafe>
+{
+public:
+	FOnlineUserCloudEOSPlus() = delete;
+	virtual ~FOnlineUserCloudEOSPlus();
+
+	void Initialize();
+
+	//~ Begin IOnlineUserCloud Interface
+	virtual bool GetFileContents(const FUniqueNetId& UserId, const FString& FileName, TArray<uint8>& FileContents) override;
+	virtual bool ClearFiles(const FUniqueNetId& UserId) override;
+	virtual bool ClearFile(const FUniqueNetId& UserId, const FString& FileName) override;
+	virtual void EnumerateUserFiles(const FUniqueNetId& UserId) override;
+	virtual void GetUserFileList(const FUniqueNetId& UserId, TArray<FCloudFileHeader>& UserFiles) override;
+	virtual bool ReadUserFile(const FUniqueNetId& UserId, const FString& FileName) override;
+	virtual bool WriteUserFile(const FUniqueNetId& UserId, const FString& FileName, TArray<uint8>& FileContents, bool bCompressBeforeUpload = false) override;
+	virtual void CancelWriteUserFile(const FUniqueNetId& UserId, const FString& FileName) override;
+	virtual bool DeleteUserFile(const FUniqueNetId& UserId, const FString& FileName, bool bShouldCloudDelete, bool bShouldLocallyDelete) override;
+	virtual bool RequestUsageInfo(const FUniqueNetId& UserId) override;
+	virtual void DumpCloudState(const FUniqueNetId& UserId) override;
+	virtual void DumpCloudFileState(const FUniqueNetId& UserId, const FString& FileName) override;
+	//~ End IOnlineUserCloud Interface
+
+PACKAGE_SCOPE:
+	FOnlineUserCloudEOSPlus(FOnlineSubsystemEOSPlus* InSubsystem);
+
+	void OnEnumerateUserFilesComplete(bool bWasSuccessful, const FUniqueNetId& UserId);
+	void OnWriteUserFileProgress(int32 BytesWritten, const FUniqueNetId& UserId, const FString& FileName);
+	void OnWriteUserFileComplete(bool bWasSuccessful, const FUniqueNetId& UserId, const FString& FileName);
+	void OnWriteUserFileCanceled(bool bWasSuccessful, const FUniqueNetId& UserId, const FString& FileName);
+	void OnReadUserFileComplete(bool bWasSuccessful, const FUniqueNetId& UserId, const FString& FileName);
+	void OnDeleteUserFileComplete(bool bWasSuccessful, const FUniqueNetId& UserId, const FString& FileName);
+	void OnRequestUsageInfoComplete(bool bWasSuccessful, const FUniqueNetId& UserId, int64 BytesUsed, const TOptional<int64>& TotalQuota);
+
+private:
+	FUniqueNetIdEOSPlusPtr GetNetIdPlus(const FString& SourceId) const;
+
+	/** Reference to the owning EOS plus subsystem */
+	FOnlineSubsystemEOSPlus* EOSPlus;
+	
+	// We don't support EOS mirroring yet
+	IOnlineUserCloudPtr BaseUserCloudInterface;
+};
+
+typedef TSharedPtr<FOnlineUserCloudEOSPlus, ESPMode::ThreadSafe> FOnlineUserCloudEOSPlusPtr;
Index: Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOSPlus/Private/OnlineTitleFileEOSPlus.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOSPlus/Private/OnlineTitleFileEOSPlus.h b/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOSPlus/Private/OnlineTitleFileEOSPlus.h
new file mode 100644
--- /dev/null	(date 1641576012000)
+++ b/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOSPlus/Private/OnlineTitleFileEOSPlus.h	(date 1641576012000)
@@ -0,0 +1,54 @@
+// Copyright Epic Games, Inc. All Rights Reserved.
+
+#pragma once
+
+#include "CoreMinimal.h"
+#include "Online/CoreOnline.h"
+#include "OnlineSubsystem.h"
+#include "Interfaces/OnlineTitleFileInterface.h"
+#include "OnlineUserEOSPlus.h"
+
+class FOnlineSubsystemEOSPlus;
+
+/**
+ * Interface for encapsulating the platform title file interface
+ */
+class FOnlineTitleFileEOSPlus :
+	public IOnlineTitleFile,
+	public TSharedFromThis<FOnlineTitleFileEOSPlus, ESPMode::ThreadSafe>
+{
+public:
+	FOnlineTitleFileEOSPlus() = delete;
+	virtual ~FOnlineTitleFileEOSPlus();
+
+	void Initialize();
+
+	//~ Begin IOnlineTitleFile Interface
+	virtual bool GetFileContents(const FString& FileName, TArray<uint8>& FileContents) override;
+	virtual bool ClearFiles() override;
+	virtual bool ClearFile(const FString& FileName) override;
+	virtual void DeleteCachedFiles(bool bSkipEnumerated) override;
+	virtual bool EnumerateFiles(const FPagedQuery& Page = FPagedQuery()) override;
+	virtual void GetFileList(TArray<FCloudFileHeader>& Files) override;
+	virtual bool ReadFile(const FString& FileName) override;
+	//~ End IOnlineTitleFile Interface
+
+PACKAGE_SCOPE:
+	FOnlineTitleFileEOSPlus(FOnlineSubsystemEOSPlus* InSubsystem);
+
+	void OnEnumerateFilesComplete(bool bWasSuccessful, const FString& ErrorStr);
+	void OnReadFileProgress(const FString& FileName, uint64 NumBytes);
+	void OnReadFileComplete(bool bWasSuccessful, const FString& FileName);
+	void OnTitleFileAnalyticsEvent(const FString& EventName, const TArray<FAnalyticsEventAttribute>& Attributes);
+
+private:
+	FUniqueNetIdEOSPlusPtr GetNetIdPlus(const FString& SourceId) const;
+
+	/** Reference to the owning EOS plus subsystem */
+	FOnlineSubsystemEOSPlus* EOSPlus;
+	
+	// We don't support EOS mirroring yet
+	IOnlineTitleFilePtr BaseTitleFileInterface;
+};
+
+typedef TSharedPtr<FOnlineTitleFileEOSPlus, ESPMode::ThreadSafe> FOnlineTitleFileEOSPlusPtr;
Index: Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOSPlus/Private/OnlineTitleFileEOSPlus.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOSPlus/Private/OnlineTitleFileEOSPlus.cpp b/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOSPlus/Private/OnlineTitleFileEOSPlus.cpp
new file mode 100644
--- /dev/null	(date 1641576012000)
+++ b/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOSPlus/Private/OnlineTitleFileEOSPlus.cpp	(date 1641576012000)
@@ -0,0 +1,170 @@
+// Copyright Epic Games, Inc. All Rights Reserved.
+
+#include "OnlineTitleFileEOSPlus.h"
+#include "OnlineSubsystemEOSPlus.h"
+#include "OnlineError.h"
+
+FOnlineTitleFileEOSPlus::FOnlineTitleFileEOSPlus(FOnlineSubsystemEOSPlus* InSubsystem)
+	: EOSPlus(InSubsystem)
+{
+	BaseTitleFileInterface = EOSPlus->BaseOSS->GetTitleFileInterface();
+}
+
+FOnlineTitleFileEOSPlus::~FOnlineTitleFileEOSPlus()
+{
+	if (BaseTitleFileInterface.IsValid())
+	{
+		BaseTitleFileInterface->ClearOnEnumerateFilesCompleteDelegates(this);
+		BaseTitleFileInterface->ClearOnReadFileProgressDelegates(this);
+		BaseTitleFileInterface->ClearOnReadFileCompleteDelegates(this);
+		BaseTitleFileInterface->ClearOnTitleFileAnalyticsEventDelegates(this);
+	}
+}
+
+FUniqueNetIdEOSPlusPtr FOnlineTitleFileEOSPlus::GetNetIdPlus(const FString& SourceId) const
+{
+	return EOSPlus->UserInterfacePtr->GetNetIdPlus(SourceId);
+}
+
+void FOnlineTitleFileEOSPlus::Initialize()
+{
+	if (BaseTitleFileInterface.IsValid())
+	{
+		BaseTitleFileInterface->AddOnEnumerateFilesCompleteDelegate_Handle(FOnEnumerateFilesCompleteDelegate::CreateThreadSafeSP(this, &FOnlineTitleFileEOSPlus::OnEnumerateFilesComplete));
+		BaseTitleFileInterface->AddOnReadFileProgressDelegate_Handle(FOnReadFileProgressDelegate::CreateThreadSafeSP(this, &FOnlineTitleFileEOSPlus::OnReadFileProgress));
+		BaseTitleFileInterface->AddOnReadFileCompleteDelegate_Handle(FOnReadFileCompleteDelegate::CreateThreadSafeSP(this, &FOnlineTitleFileEOSPlus::OnReadFileComplete));
+		BaseTitleFileInterface->AddOnTitleFileAnalyticsEventDelegate_Handle(FOnTitleFileAnalyticsEventDelegate::CreateThreadSafeSP(this, &FOnlineTitleFileEOSPlus::OnTitleFileAnalyticsEvent));
+	}
+	else
+	{
+		UE_LOG_ONLINE(VeryVerbose, TEXT("[FOnlineTitleFileEOSPlus::Initialize] BaseTitleFileInterface delegates not bound. Base interface not valid"));
+	}
+}
+
+//~ Begin IOnlineTitleFile Interface
+
+bool FOnlineTitleFileEOSPlus::GetFileContents(const FString& FileName, TArray<uint8>& FileContents)
+{
+	bool bResult = false;
+
+	if (BaseTitleFileInterface.IsValid())
+	{
+		bResult = BaseTitleFileInterface->GetFileContents(FileName, FileContents);
+	}
+	else
+	{
+		UE_LOG_ONLINE(VeryVerbose, TEXT("[FOnlineTitleFileEOSPlus::GetFileContents] Unable to call method in base interface. Base interface not valid"));
+	}
+
+	return bResult;
+}
+
+bool FOnlineTitleFileEOSPlus::ClearFiles()
+{
+	bool bResult = false;
+
+	if (BaseTitleFileInterface.IsValid())
+	{
+		bResult = BaseTitleFileInterface->ClearFiles();
+	}
+	else
+	{
+		UE_LOG_ONLINE(VeryVerbose, TEXT("[FOnlineTitleFileEOSPlus::ClearFiles] Unable to call method in base interface. Base interface not valid"));
+	}
+
+	return bResult;
+}
+
+bool FOnlineTitleFileEOSPlus::ClearFile(const FString& FileName)
+{
+	bool bResult = false;
+
+	if (BaseTitleFileInterface.IsValid())
+	{
+		bResult = BaseTitleFileInterface->ClearFile(FileName);
+	}
+	else
+	{
+		UE_LOG_ONLINE(VeryVerbose, TEXT("[FOnlineTitleFileEOSPlus::ClearFile] Unable to call method in base interface. Base interface not valid"));
+	}
+
+	return bResult;
+}
+
+void FOnlineTitleFileEOSPlus::DeleteCachedFiles(bool bSkipEnumerated)
+{
+	if (BaseTitleFileInterface.IsValid())
+	{
+		BaseTitleFileInterface->DeleteCachedFiles(bSkipEnumerated);
+	}
+	else
+	{
+		UE_LOG_ONLINE(VeryVerbose, TEXT("[FOnlineTitleFileEOSPlus::DeleteCachedFiles] Unable to call method in base interface. Base interface not valid"));
+	}
+}
+
+bool FOnlineTitleFileEOSPlus::EnumerateFiles(const FPagedQuery& Page)
+{
+	bool bResult = false;
+
+	if (BaseTitleFileInterface.IsValid())
+	{
+		bResult = BaseTitleFileInterface->EnumerateFiles(Page);
+	}
+	else
+	{
+		UE_LOG_ONLINE(VeryVerbose, TEXT("[FOnlineTitleFileEOSPlus::EnumerateFiles] Unable to call method in base interface. Base interface not valid"));
+	}
+
+	return bResult;
+}
+
+void FOnlineTitleFileEOSPlus::GetFileList(TArray<FCloudFileHeader>& Files)
+{
+	if (BaseTitleFileInterface.IsValid())
+	{
+		BaseTitleFileInterface->GetFileList(Files);
+	}
+	else
+	{
+		UE_LOG_ONLINE(VeryVerbose, TEXT("[FOnlineTitleFileEOSPlus::GetFileList] Unable to call method in base interface. Base interface not valid"));
+	}
+}
+
+bool FOnlineTitleFileEOSPlus::ReadFile(const FString& FileName)
+{
+	bool bResult = false;
+
+	if (BaseTitleFileInterface.IsValid())
+	{
+		bResult = BaseTitleFileInterface->ReadFile(FileName);
+	}
+	else
+	{
+		UE_LOG_ONLINE(VeryVerbose, TEXT("[FOnlineTitleFileEOSPlus::ReadFile] Unable to call method in base interface. Base interface not valid"));
+	}
+
+	return bResult;
+}
+
+void FOnlineTitleFileEOSPlus::OnEnumerateFilesComplete(bool bWasSuccessful, const FString& ErrorStr)
+{
+	TriggerOnEnumerateFilesCompleteDelegates(bWasSuccessful, ErrorStr);
+}
+
+void FOnlineTitleFileEOSPlus::OnReadFileProgress(const FString& FileName, uint64 NumBytes)
+{
+	TriggerOnReadFileProgressDelegates(FileName, NumBytes);
+}
+
+void FOnlineTitleFileEOSPlus::OnReadFileComplete(bool bWasSuccessful, const FString& FileName)
+{
+	TriggerOnReadFileCompleteDelegates(bWasSuccessful, FileName);
+}
+
+void FOnlineTitleFileEOSPlus::OnTitleFileAnalyticsEvent(const FString& EventName, const TArray<FAnalyticsEventAttribute>& Attributes)
+{
+	TriggerOnTitleFileAnalyticsEventDelegates(EventName, Attributes);
+}
+
+//~ End IOnlineTitleFile Interface
\ No newline at end of file
Index: Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOSPlus/Private/OnlineSubsystemEOSPlusPrivate.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOSPlus/Private/OnlineSubsystemEOSPlusPrivate.h b/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOSPlus/Private/OnlineSubsystemEOSPlusPrivate.h
new file mode 100644
--- /dev/null	(date 1641575208000)
+++ b/Plugins/OnlineSubsystemEOS/Source/OnlineSubsystemEOSPlus/Private/OnlineSubsystemEOSPlusPrivate.h	(date 1641575208000)
@@ -0,0 +1,9 @@
+// Copyright Epic Games, Inc. All Rights Reserved.
+
+#pragma once
+
+#include "CoreMinimal.h"
+#include "OnlineSubsystem.h"
+#include "Modules/ModuleManager.h"
+
+#define EOSPLUS_SUBSYSTEM TEXT("EOSPlus")
Index: Source/FantasyBattle/Public/Interfaces/LobbyInterface.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Source/FantasyBattle/Public/Interfaces/LobbyInterface.h b/Source/FantasyBattle/Public/Interfaces/LobbyInterface.h
new file mode 100644
--- /dev/null	(date 1643312388795)
+++ b/Source/FantasyBattle/Public/Interfaces/LobbyInterface.h	(date 1643312388795)
@@ -0,0 +1,29 @@
+// Fill out your copyright notice in the Description page of Project Settings.
+
+#pragma once
+
+#include "CoreMinimal.h"
+#include "StructLibrary.h"
+#include "UObject/Interface.h"
+#include "LobbyInterface.generated.h"
+
+// This class does not need to be modified.
+UINTERFACE(MinimalAPI)
+class ULobbyInterface : public UInterface
+{
+	GENERATED_BODY()
+};
+
+/**
+ * 
+ */
+class FANTASYBATTLE_API ILobbyInterface
+{
+	GENERATED_BODY()
+public:
+	// Add interface functions to this class. This is the class that will be inherited to implement this interface.
+	virtual void SetArmy(int32 ArrayIndex) = 0;
+	
+	virtual void SetIsReady(bool newValue) = 0;
+public:
+};
Index: .idea/.idea.FantasyBattle/.idea/.gitignore
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/.idea.FantasyBattle/.idea/.gitignore b/.idea/.idea.FantasyBattle/.idea/.gitignore
new file mode 100644
--- /dev/null	(date 1641635560000)
+++ b/.idea/.idea.FantasyBattle/.idea/.gitignore	(date 1641635560000)
@@ -0,0 +1,8 @@
+# Default ignored files
+/shelf/
+/workspace.xml
+# Rider ignored files
+/modules.xml
+/projectSettingsUpdater.xml
+/.idea.FantasyBattle.iml
+/contentModel.xml
Index: .idea/.idea.FantasyBattle/.idea/indexLayout.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/.idea.FantasyBattle/.idea/indexLayout.xml b/.idea/.idea.FantasyBattle/.idea/indexLayout.xml
new file mode 100644
--- /dev/null	(date 1641635450000)
+++ b/.idea/.idea.FantasyBattle/.idea/indexLayout.xml	(date 1641635450000)
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="UserContentModel">
+    <attachedFolders />
+    <explicitIncludes />
+    <explicitExcludes />
+  </component>
+</project>
\ No newline at end of file
Index: .idea/.idea.FantasyBattle/.idea/vcs.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/.idea.FantasyBattle/.idea/vcs.xml b/.idea/.idea.FantasyBattle/.idea/vcs.xml
new file mode 100644
--- /dev/null	(date 1641635450000)
+++ b/.idea/.idea.FantasyBattle/.idea/vcs.xml	(date 1641635450000)
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="VcsDirectoryMappings">
+    <mapping directory="$PROJECT_DIR$" vcs="Git" />
+  </component>
+</project>
\ No newline at end of file
Index: Source/FantasyBattle/Private/Interfaces/LobbyInterface.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Source/FantasyBattle/Private/Interfaces/LobbyInterface.cpp b/Source/FantasyBattle/Private/Interfaces/LobbyInterface.cpp
new file mode 100644
--- /dev/null	(date 1642870131351)
+++ b/Source/FantasyBattle/Private/Interfaces/LobbyInterface.cpp	(date 1642870131351)
@@ -0,0 +1,6 @@
+// Fill out your copyright notice in the Description page of Project Settings.
+
+
+#include "Interfaces/LobbyInterface.h"
+
+// Add default functionality here for any ILobbyInterface functions that are not pure virtual.
Index: .idea/.idea.FantasyBattle/.idea/encodings.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/.idea.FantasyBattle/.idea/encodings.xml b/.idea/.idea.FantasyBattle/.idea/encodings.xml
new file mode 100644
--- /dev/null	(date 1641635400000)
+++ b/.idea/.idea.FantasyBattle/.idea/encodings.xml	(date 1641635400000)
@@ -0,0 +1,4 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="Encoding" addBOMForNewFiles="with BOM under Windows, with no BOM otherwise" />
+</project>
\ No newline at end of file
Index: .idea/.idea.FantasyBattle/.idea/.name
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/.idea.FantasyBattle/.idea/.name b/.idea/.idea.FantasyBattle/.idea/.name
new file mode 100644
--- /dev/null	(date 1643447794046)
+++ b/.idea/.idea.FantasyBattle/.idea/.name	(date 1643447794046)
@@ -0,0 +1,1 @@
+FantasyBattle
\ No newline at end of file
Index: Config/DefaultInput.ini
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Config/DefaultInput.ini b/Config/DefaultInput.ini
new file mode 100644
--- /dev/null	(date 1642457312000)
+++ b/Config/DefaultInput.ini	(date 1642457312000)
@@ -0,0 +1,82 @@
+[/Script/Engine.InputSettings]
+-AxisConfig=(AxisKeyName="Gamepad_LeftX",AxisProperties=(DeadZone=0.25,Exponent=1.f,Sensitivity=1.f))
+-AxisConfig=(AxisKeyName="Gamepad_LeftY",AxisProperties=(DeadZone=0.25,Exponent=1.f,Sensitivity=1.f))
+-AxisConfig=(AxisKeyName="Gamepad_RightX",AxisProperties=(DeadZone=0.25,Exponent=1.f,Sensitivity=1.f))
+-AxisConfig=(AxisKeyName="Gamepad_RightY",AxisProperties=(DeadZone=0.25,Exponent=1.f,Sensitivity=1.f))
+-AxisConfig=(AxisKeyName="MouseX",AxisProperties=(DeadZone=0.f,Exponent=1.f,Sensitivity=0.07f))
+-AxisConfig=(AxisKeyName="MouseY",AxisProperties=(DeadZone=0.f,Exponent=1.f,Sensitivity=0.07f))
+-AxisConfig=(AxisKeyName="Mouse2D",AxisProperties=(DeadZone=0.f,Exponent=1.f,Sensitivity=0.07f))
++AxisConfig=(AxisKeyName="Gamepad_LeftX",AxisProperties=(DeadZone=0.250000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
++AxisConfig=(AxisKeyName="Gamepad_LeftY",AxisProperties=(DeadZone=0.250000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
++AxisConfig=(AxisKeyName="Gamepad_RightX",AxisProperties=(DeadZone=0.250000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
++AxisConfig=(AxisKeyName="Gamepad_RightY",AxisProperties=(DeadZone=0.250000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
++AxisConfig=(AxisKeyName="MouseX",AxisProperties=(DeadZone=0.000000,Sensitivity=0.070000,Exponent=1.000000,bInvert=False))
++AxisConfig=(AxisKeyName="MouseY",AxisProperties=(DeadZone=0.000000,Sensitivity=0.070000,Exponent=1.000000,bInvert=False))
++AxisConfig=(AxisKeyName="Mouse2D",AxisProperties=(DeadZone=0.000000,Sensitivity=0.070000,Exponent=1.000000,bInvert=False))
++AxisConfig=(AxisKeyName="MouseWheelAxis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
++AxisConfig=(AxisKeyName="Gamepad_LeftTriggerAxis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
++AxisConfig=(AxisKeyName="Gamepad_RightTriggerAxis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
++AxisConfig=(AxisKeyName="Gamepad_Special_Left_X",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
++AxisConfig=(AxisKeyName="Gamepad_Special_Left_Y",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
++AxisConfig=(AxisKeyName="Vive_Left_Trigger_Axis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
++AxisConfig=(AxisKeyName="Vive_Left_Trackpad_X",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
++AxisConfig=(AxisKeyName="Vive_Left_Trackpad_Y",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
++AxisConfig=(AxisKeyName="Vive_Right_Trigger_Axis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
++AxisConfig=(AxisKeyName="Vive_Right_Trackpad_X",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
++AxisConfig=(AxisKeyName="Vive_Right_Trackpad_Y",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
++AxisConfig=(AxisKeyName="MixedReality_Left_Trigger_Axis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
++AxisConfig=(AxisKeyName="MixedReality_Left_Thumbstick_X",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
++AxisConfig=(AxisKeyName="MixedReality_Left_Thumbstick_Y",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
++AxisConfig=(AxisKeyName="MixedReality_Left_Trackpad_X",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
++AxisConfig=(AxisKeyName="MixedReality_Left_Trackpad_Y",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
++AxisConfig=(AxisKeyName="MixedReality_Right_Trigger_Axis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
++AxisConfig=(AxisKeyName="MixedReality_Right_Thumbstick_X",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
++AxisConfig=(AxisKeyName="MixedReality_Right_Thumbstick_Y",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
++AxisConfig=(AxisKeyName="MixedReality_Right_Trackpad_X",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
++AxisConfig=(AxisKeyName="MixedReality_Right_Trackpad_Y",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
++AxisConfig=(AxisKeyName="OculusTouch_Left_Grip_Axis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
++AxisConfig=(AxisKeyName="OculusTouch_Left_Trigger_Axis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
++AxisConfig=(AxisKeyName="OculusTouch_Left_Thumbstick_X",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
++AxisConfig=(AxisKeyName="OculusTouch_Left_Thumbstick_Y",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
++AxisConfig=(AxisKeyName="OculusTouch_Right_Grip_Axis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
++AxisConfig=(AxisKeyName="OculusTouch_Right_Trigger_Axis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
++AxisConfig=(AxisKeyName="OculusTouch_Right_Thumbstick_X",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
++AxisConfig=(AxisKeyName="OculusTouch_Right_Thumbstick_Y",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
++AxisConfig=(AxisKeyName="ValveIndex_Left_Grip_Axis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
++AxisConfig=(AxisKeyName="ValveIndex_Left_Grip_Force",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
++AxisConfig=(AxisKeyName="ValveIndex_Left_Trigger_Axis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
++AxisConfig=(AxisKeyName="ValveIndex_Left_Thumbstick_X",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
++AxisConfig=(AxisKeyName="ValveIndex_Left_Thumbstick_Y",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
++AxisConfig=(AxisKeyName="ValveIndex_Left_Trackpad_X",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
++AxisConfig=(AxisKeyName="ValveIndex_Left_Trackpad_Y",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
++AxisConfig=(AxisKeyName="ValveIndex_Left_Trackpad_Force",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
++AxisConfig=(AxisKeyName="ValveIndex_Left_Trackpad_Touch",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
++AxisConfig=(AxisKeyName="ValveIndex_Right_Grip_Axis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
++AxisConfig=(AxisKeyName="ValveIndex_Right_Grip_Force",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
++AxisConfig=(AxisKeyName="ValveIndex_Right_Trigger_Axis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
++AxisConfig=(AxisKeyName="ValveIndex_Right_Thumbstick_X",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
++AxisConfig=(AxisKeyName="ValveIndex_Right_Thumbstick_Y",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
++AxisConfig=(AxisKeyName="ValveIndex_Right_Trackpad_X",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
++AxisConfig=(AxisKeyName="ValveIndex_Right_Trackpad_Y",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
++AxisConfig=(AxisKeyName="ValveIndex_Right_Trackpad_Force",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+bAltEnterTogglesFullscreen=True
+bF11TogglesFullscreen=True
+bUseMouseForTouch=False
+bEnableMouseSmoothing=True
+bEnableFOVScaling=True
+bCaptureMouseOnLaunch=True
+bEnableLegacyInputScales=True
+bAlwaysShowTouchInterface=False
+bShowConsoleOnFourFingerTap=True
+bEnableGestureRecognizer=False
+bUseAutocorrect=False
+DefaultViewportMouseCaptureMode=CapturePermanently_IncludingInitialMouseDown
+DefaultViewportMouseLockMode=LockOnCapture
+FOVScale=0.011110
+DoubleClickTime=0.200000
+DefaultPlayerInputClass=/Script/Engine.PlayerInput
+DefaultInputComponentClass=/Script/Engine.InputComponent
+DefaultTouchInterface=/Engine/MobileResources/HUD/DefaultVirtualJoysticks.DefaultVirtualJoysticks
+-ConsoleKeys=Tilde
++ConsoleKeys=½
+
Index: Source/FantasyBattle/Private/BaseUnit.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// Fill out your copyright notice in the Description page of Project Settings.\r\n\r\n\r\n#include \"BaseUnit.h\"\r\n#include \"Components/BoxComponent.h\"\r\n#include \"ProceduralMeshComponent.h\"\r\n#include \"Kismet/KismetMathLibrary.h\"\r\n\r\n// Sets default values\r\nABaseUnit::ABaseUnit()\r\n{\r\n \t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\r\n\tPrimaryActorTick.bCanEverTick = true;\r\n\r\n\tRoot = CreateDefaultSubobject<USceneComponent>(FName(\"Root\"));\r\n\tRootComponent = Root;\r\n\r\n\tBoxCollision = CreateDefaultSubobject<UBoxComponent>(FName(\"BoxCollision\"));\r\n\tBoxCollision->SetupAttachment(RootComponent);\r\n\t//BoxCollision->SetIsReplicated(true);\r\n\tBoxCollision->bHiddenInGame = false;\r\n\r\n\tMovementMesh = CreateDefaultSubobject<UProceduralMeshComponent>(TEXT(\"MeshComp\"));\r\n\tMovementMesh->bUseAsyncCooking = true;\r\n\tMovementMesh->ContainsPhysicsTriMeshData(false);\r\n\tMovementMesh->AttachToComponent(RootComponent, FAttachmentTransformRules(EAttachmentRule::SnapToTarget, true));\r\n\r\n\tUnitSize = FVector(100.f, 100.f, 50.f);\r\n\tBoxCollision->SetBoxExtent(UnitSize);\r\n\tFrontRow = 4;\r\n}\r\n\r\n// Called when the game starts or when spawned\r\nvoid ABaseUnit::BeginPlay()\r\n{\r\n\tSuper::BeginPlay();\r\n\t\r\n\tif (LOSMaterial)\r\n\t{\r\n\t\tLOSMaterialInstance = UMaterialInstanceDynamic::Create(LOSMaterial, this);\r\n\t\tMovementMesh->SetMaterial(0, LOSMaterialInstance);\r\n\t\tLOSMaterialInstance->SetVectorParameterValue(\"Color\", LOSMaterialColor);\r\n\t}\r\n}\r\n\r\n// Called every frame\r\nvoid ABaseUnit::Tick(float DeltaTime)\r\n{\r\n\tSuper::Tick(DeltaTime);\r\n\r\n}\r\n\r\nFVector ABaseUnit::GetUnitSize()\r\n{\r\n\treturn UnitSize;\r\n}\r\n\r\nvoid ABaseUnit::GetFrontCorners(FVector& LeftCorner, FVector& RightCorner)\r\n{\r\n\tLeftCorner = UKismetMathLibrary::TransformLocation(GetActorTransform(), FVector(UnitSize.X, -UnitSize.Y, -UnitSize.Z + 1));\r\n\tRightCorner = UKismetMathLibrary::TransformLocation(GetActorTransform(), FVector(UnitSize.X, UnitSize.Y, -UnitSize.Z + 1));\r\n}\r\n\r\nvoid ABaseUnit::GetFrontCornersLocal(FVector& LeftCorner, FVector& RightCorner)\r\n{\r\n\tLeftCorner = FVector(UnitSize.X, -UnitSize.Y, -UnitSize.Z + 1);\r\n\tRightCorner = FVector(UnitSize.X, UnitSize.Y, -UnitSize.Z + 1);\r\n}\r\n\r\nvoid ABaseUnit::GetVertices()\r\n{\r\n\tFVector LeftStart;\r\n\tFVector RightStart;\r\n\tint32 StartAngle = SightArc / 2;\r\n\tGetFrontCornersLocal(LeftStart, RightStart);\r\n\tint32 HalfVertices = FMath::RoundToInt(SightArc / AngleStep) / 2;\t//Get number of points in half so i can use equal numbers from both corners\r\n\tFVector FrontRowDirection = (RightStart - LeftStart);\r\n\tFrontRowDirection.Normalize();\r\n\tint32 FrontSteps = FMath::CeilToInt((RightStart - LeftStart).Size() / 40);\r\n\tLOSVertices.Add(LeftStart);\r\n\tfor (int i = 1; i < FrontSteps; i++)\r\n\t{\r\n\t\tLOSVertices.Add(LeftStart + (FrontRowDirection * (i * 40)));\r\n\t}\r\n\tLOSVertices.Add(RightStart);\r\n\r\n\tfor (int i = 0; i < HalfVertices; i++)\r\n\t{\r\n\t\tFVector CurrentAngleDirection = GetActorForwardVector().RotateAngleAxis(-StartAngle + (i*AngleStep), FVector(0, 0, 1));\r\n\t\tFVector LineEndLocation = LeftStart + (CurrentAngleDirection * SightRange);\r\n\t\t//FVector HitResultInCharacterLocalSpace = GetActorTransform().InverseTransformPosition(LineEndLocation);\r\n\t\tLOSVertices.Add(LineEndLocation);\r\n\t}\r\n\r\n\tfor (int i = 0; i < FrontSteps +1; i++)\r\n\t{\r\n\t\tFVector LineEndLocation = LOSVertices[i] + (GetActorForwardVector() * SightRange);\r\n\t\t//FVector HitResultInCharacterLocalSpace = GetActorTransform().InverseTransformPosition(LineEndLocation);\r\n\t\tLOSVertices.Add(LineEndLocation);\r\n\t}\r\n\r\n\tfor (int i = 0; i < HalfVertices; i++)\r\n\t{\r\n\t\tFVector CurrentAngleDirection = GetActorForwardVector().RotateAngleAxis(AngleStep + (i * AngleStep), FVector(0, 0, 1));\r\n\t\tFVector LineEndLocation = RightStart + (CurrentAngleDirection * SightRange);\r\n\t\t//FVector HitResultInCharacterLocalSpace = GetActorTransform().InverseTransformPosition(LineEndLocation);\r\n\t\tLOSVertices.Add(LineEndLocation);\r\n\t}\r\n\tint CenterTriDiff = (FrontSteps + 1) + HalfVertices;\r\n\tfor (int i = FrontSteps +1; i < LOSVertices.Num() -1; i++)\r\n\t{\r\n\t\tif (i < CenterTriDiff)\r\n\t\t{\r\n\t\t\tLOSTriangles.Add(0);\r\n\t\t\tLOSTriangles.Add(i +1);\r\n\t\t\tLOSTriangles.Add(i);\r\n\t\t}\r\n\t\telse if (i < FrontSteps + CenterTriDiff)\r\n\t\t{\r\n\t\t\tLOSTriangles.Add(i - CenterTriDiff);\r\n\t\t\tLOSTriangles.Add(i + 1);\r\n\t\t\tLOSTriangles.Add(i);\r\n\t\t\tLOSTriangles.Add(i - CenterTriDiff);\r\n\t\t\tLOSTriangles.Add(i - CenterTriDiff + 1);\r\n\t\t\tLOSTriangles.Add(i + 1);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tLOSTriangles.Add(FrontSteps);\r\n\t\t\tLOSTriangles.Add(i + 1);\r\n\t\t\tLOSTriangles.Add(i);\t\t\r\n\t\t}\t\t\r\n\t}\r\n\tDrawLOSMesh();\r\n}\r\n\r\nvoid ABaseUnit::DrawLOSMesh()\r\n{\r\n\tTArray<FVector> TempNormals;\r\n\tTArray<FVector2D> TempUV0;\r\n\tTArray<FProcMeshTangent> TempTangents;\r\n\tTArray<FLinearColor> TempVertexColors;\r\n\tMovementMesh->CreateMeshSection_LinearColor(0, LOSVertices, LOSTriangles, TempNormals, TempUV0, TempVertexColors, TempTangents, false);\r\n\r\n}\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Source/FantasyBattle/Private/BaseUnit.cpp b/Source/FantasyBattle/Private/BaseUnit.cpp
--- a/Source/FantasyBattle/Private/BaseUnit.cpp	(revision 9b08c3c30042b95af90916955e891c673f23b32c)
+++ b/Source/FantasyBattle/Private/BaseUnit.cpp	(date 1641691430000)
@@ -23,7 +23,8 @@
 	MovementMesh = CreateDefaultSubobject<UProceduralMeshComponent>(TEXT("MeshComp"));
 	MovementMesh->bUseAsyncCooking = true;
 	MovementMesh->ContainsPhysicsTriMeshData(false);
-	MovementMesh->AttachToComponent(RootComponent, FAttachmentTransformRules(EAttachmentRule::SnapToTarget, true));
+	//MovementMesh->AttachToComponent(RootComponent, FAttachmentTransformRules(EAttachmentRule::SnapToTarget, true));
+	MovementMesh->SetupAttachment(RootComponent);
 
 	UnitSize = FVector(100.f, 100.f, 50.f);
 	BoxCollision->SetBoxExtent(UnitSize);
Index: Source/FantasyBattle/FantasyBattle.Build.cs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// Copyright Epic Games, Inc. All Rights Reserved.\r\n\r\nusing UnrealBuildTool;\r\n\r\npublic class FantasyBattle : ModuleRules\r\n{\r\n\tpublic FantasyBattle(ReadOnlyTargetRules Target) : base(Target)\r\n\t{\r\n\t\tPCHUsage = PCHUsageMode.UseExplicitOrSharedPCHs;\r\n\t\r\n\t\tPublicDependencyModuleNames.AddRange(new string[] { \"Core\", \"CoreUObject\", \"Engine\", \"InputCore\", \"ProceduralMeshComponent\", \"SpecialRules\" });\r\n\r\n\t\tPrivateDependencyModuleNames.AddRange(new string[] { \"DiceRoll\"});\r\n\r\n\t\tPrivateIncludePaths.AddRange(new string[] {  });\r\n\t\t// Uncomment if you are using Slate UI\r\n\t\t// PrivateDependencyModuleNames.AddRange(new string[] { \"Slate\", \"SlateCore\" });\r\n\r\n\t\t// Uncomment if you are using online features\r\n\t\t// PrivateDependencyModuleNames.Add(\"OnlineSubsystem\");\r\n\r\n\t\t// To include OnlineSubsystemSteam, add it to the plugins section in your uproject file with the Enabled attribute set to true\r\n\t}\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Source/FantasyBattle/FantasyBattle.Build.cs b/Source/FantasyBattle/FantasyBattle.Build.cs
--- a/Source/FantasyBattle/FantasyBattle.Build.cs	(revision 9b08c3c30042b95af90916955e891c673f23b32c)
+++ b/Source/FantasyBattle/FantasyBattle.Build.cs	(date 1643219065982)
@@ -8,9 +8,9 @@
 	{
 		PCHUsage = PCHUsageMode.UseExplicitOrSharedPCHs;
 	
-		PublicDependencyModuleNames.AddRange(new string[] { "Core", "CoreUObject", "Engine", "InputCore", "ProceduralMeshComponent", "SpecialRules" });
+		PublicDependencyModuleNames.AddRange(new string[] { "Core", "CoreUObject", "Engine", "InputCore", "ProceduralMeshComponent", "SpecialRules", "OnlineSubsystem", "OnlineSubsystemEOS" });
 
-		PrivateDependencyModuleNames.AddRange(new string[] { "DiceRoll"});
+		PrivateDependencyModuleNames.AddRange(new string[] { "DiceRoll", "Slate", "SlateCore" });
 
 		PrivateIncludePaths.AddRange(new string[] {  });
 		// Uncomment if you are using Slate UI
Index: Source/FantasyBattleEditor.Target.cs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// Copyright Epic Games, Inc. All Rights Reserved.\r\n\r\nusing UnrealBuildTool;\r\nusing System.Collections.Generic;\r\n\r\npublic class FantasyBattleEditorTarget : TargetRules\r\n{\r\n\tpublic FantasyBattleEditorTarget( TargetInfo Target) : base(Target)\r\n\t{\r\n\t\tType = TargetType.Editor;\r\n\t\tDefaultBuildSettings = BuildSettingsVersion.V2;\r\n\t\tExtraModuleNames.AddRange( new string[] { \"FantasyBattle\" } );\r\n\t}\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Source/FantasyBattleEditor.Target.cs b/Source/FantasyBattleEditor.Target.cs
--- a/Source/FantasyBattleEditor.Target.cs	(revision 9b08c3c30042b95af90916955e891c673f23b32c)
+++ b/Source/FantasyBattleEditor.Target.cs	(date 1641762734000)
@@ -10,5 +10,6 @@
 		Type = TargetType.Editor;
 		DefaultBuildSettings = BuildSettingsVersion.V2;
 		ExtraModuleNames.AddRange( new string[] { "FantasyBattle" } );
+		ProjectDefinitions.Add("ONLINE_SUBSYSTEM_EOS_ENABLE_STEAM=1");
 	}
 }
Index: Source/FantasyBattle/Public/FantasyBattle_GI.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Source/FantasyBattle/Public/FantasyBattle_GI.h b/Source/FantasyBattle/Public/FantasyBattle_GI.h
new file mode 100644
--- /dev/null	(date 1643307569865)
+++ b/Source/FantasyBattle/Public/FantasyBattle_GI.h	(date 1643307569865)
@@ -0,0 +1,170 @@
+// Fill out your copyright notice in the Description page of Project Settings.
+
+#pragma once
+
+#include "CoreMinimal.h"
+#include "Engine/GameInstance.h"
+#include "OnlineSessionSettings.h"
+#include "Interfaces/OnlineSessionInterface.h"
+#include "Templates/SharedPointer.h"
+#include "StructLibrary.h"
+#include "FantasyBattle_GI.generated.h"
+
+class UUI_LobbyMenu;
+class UUI_MainMenu;
+struct FArmyStat;
+
+DECLARE_DYNAMIC_DELEGATE_TwoParams(FOnSessionCreated, FName, SessionName, bool, bWasSuccessful);
+
+USTRUCT(BlueprintType)
+struct FFoundSessionResult
+{
+	GENERATED_USTRUCT_BODY()
+
+public:
+	UPROPERTY(BlueprintReadOnly)
+	FString ConnectInfo;
+	UPROPERTY(BlueprintReadOnly)
+	int32 MaxPlayers;
+	UPROPERTY(BlueprintReadOnly)
+	int32 CurrentPlayers;
+	UPROPERTY(BlueprintReadOnly)
+	FString HostUserName;
+	UPROPERTY(BlueprintReadOnly)
+	FString ServerName;
+
+	FOnlineSessionSearchResult SessionData;
+
+	FFoundSessionResult() {}
+
+	FFoundSessionResult(FOnlineSessionSearchResult newSession, FString ConnectString)
+	{
+		MaxPlayers = newSession.Session.SessionSettings.NumPublicConnections;
+		CurrentPlayers = MaxPlayers - newSession.Session.NumOpenPrivateConnections;
+		HostUserName = newSession.Session.OwningUserName;
+		newSession.Session.SessionSettings.Get("ServerName", ServerName);
+		ConnectInfo = ConnectString;
+		SessionData = newSession;
+	}
+
+};
+/**
+ * 
+ */
+UCLASS()
+class FANTASYBATTLE_API UFantasyBattle_GI : public UGameInstance
+{
+	GENERATED_BODY()
+
+public:
+
+	UFantasyBattle_GI();
+
+	virtual void Init() override;
+
+	FORCEINLINE bool IsInSession() {return bInSession;}
+	
+	//~Widgets Start
+	UFUNCTION(BlueprintCallable)
+	UUI_LobbyMenu* ShowLobbyMenu();
+		
+	UFUNCTION(BlueprintCallable)
+	void ShowMainMenu();
+		
+	UFUNCTION(BlueprintCallable)
+	void ShowCreateMenu();
+	
+	FString FindUserInfo(const FUniqueNetIdRef PlayerID);
+	
+protected:
+
+	UPROPERTY(EditDefaultsOnly)
+	TSubclassOf<UUI_MainMenu> MainMenuClass;
+
+	UPROPERTY(EditDefaultsOnly)
+	TSubclassOf<UUI_LobbyMenu> LobbyMenuClass;
+
+	UPROPERTY(EditDefaultsOnly)
+	TSubclassOf<UUserWidget> CreateArmyMenuClass;
+
+	UPROPERTY()
+	UUI_MainMenu* MainMenu;
+
+	UPROPERTY()
+	UUI_LobbyMenu* LobbyMenu;
+
+	UPROPERTY()
+	UUserWidget* CreateMenu;
+	
+	//~ Widgets End
+	//~ OnlineSubsystem Variables/Functions
+public:
+	UFUNCTION(BlueprintCallable)
+	void Login(FString UserName);
+	
+	UFUNCTION(BlueprintCallable)
+	void CreateSession();
+	void CreateSession_Server();
+
+	UFUNCTION(BlueprintCallable)
+	void DestroySession();
+	
+	UFUNCTION(BlueprintCallable)
+	void GetAllFriends();
+
+	UFUNCTION(BlueprintCallable)
+	void ShowFriendsUI();
+
+	UFUNCTION(BlueprintCallable)
+	void FindSessions();
+
+	void FindFriendsSessions(const FUniqueNetId& UserID);
+
+	UFUNCTION(BlueprintCallable)
+	void JoinSelectedSession(FFoundSessionResult Session);
+	
+	FOnSessionCreated OnSessionCreated;
+
+protected:
+
+	class IOnlineSubsystem* OnlineSubsystem;
+
+	void OnCreateSessionComplete(FName SessionName, bool bWasSuccessful);
+	void OnDestroySessionComplete(FName SessionName, bool bWasSuccessful);
+	void OnLoginComplete(int32 LocalUserNum, bool bWasSuccessful, const FUniqueNetId& UserId, const FString& Error);
+	void OnGetFriendsListComplete(int32 LocalUserNum, bool bWasSuccessful, const FString& ListName, const FString& ErrorStr);
+	void OnInvitationAccepted(const bool bWasSuccessful, const int32 ControllerId, FUniqueNetIdPtr UserId, const FOnlineSessionSearchResult& InviteResult);
+	void HandleFindSessionsComplete(bool bWasSuccessful, TSharedRef<FOnlineSessionSearch> Search);
+	void HandleJoinSessionComplete(FName SessionName, EOnJoinSessionCompleteResult::Type JoinResult, FString ConnectInfo);
+
+	UPROPERTY(BlueprintReadWrite)
+	bool bInSession;
+	
+	UPROPERTY(BlueprintReadOnly, VisibleAnywhere)
+	TArray<FFoundSessionResult> Sessions;
+	
+private:
+	
+	bool bIsLoggedIn;
+	
+	FDelegateHandle FindSessionsDelegateHandle;
+	FDelegateHandle JoinSessionDelegateHandle;
+//~ End OnlineSubsystem
+	
+	TArray<FUniqueNetIdRef> FriendsIDs;
+
+//~ SaveGame	
+	FString SaveGameListString = TEXT("SaveGameList");
+	UPROPERTY()
+	class UArmySaveGame* SaveGame;
+	void InitSaveGameList();
+
+public:
+	UFUNCTION(BlueprintCallable)
+	bool AddArmyToSave(FArmyStat Army);
+	UFUNCTION(BlueprintCallable)	
+	bool OverwriteArmy(FArmyStat Army, int32 Index, FString ErrorStr);
+
+	TArray<FArmyStat> GetSaveGameList();
+};
+
Index: Source/FantasyBattle/Private/StructLibrary.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// Fill out your copyright notice in the Description page of Project Settings.\r\n\r\n\r\n#include \"StructLibrary.h\"\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Source/FantasyBattle/Private/StructLibrary.cpp b/Source/FantasyBattle/Private/StructLibrary.cpp
--- a/Source/FantasyBattle/Private/StructLibrary.cpp	(revision 9b08c3c30042b95af90916955e891c673f23b32c)
+++ b/Source/FantasyBattle/Private/StructLibrary.cpp	(date 1643222290600)
@@ -3,3 +3,12 @@
 
 #include "StructLibrary.h"
 
+bool UStructLibrary::Equals_Profile(const FManProfile& A, const FManProfile& B)
+{
+	return A.ProfileName.ToString() == B.ProfileName.ToString();
+}
+
+bool UStructLibrary::Equals_Army(const FArmyStat& A, const FArmyStat& B)
+{
+	return A.ArmyName == B.ArmyName;
+}
Index: Source/FantasyBattle/Public/UI_CreationMainMenu.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// Fill out your copyright notice in the Description page of Project Settings.\r\n\r\n#pragma once\r\n\r\n#include \"CoreMinimal.h\"\r\n#include \"Blueprint/UserWidget.h\"\r\n#include \"FantasyBattle/Public/StructLibrary.h\"\r\n#include \"UI_CreationMainMenu.generated.h\"\r\n\r\nUSTRUCT(BlueprintType)\r\nstruct FUnitColor\r\n{\r\n\tGENERATED_USTRUCT_BODY()\r\n\r\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite)\r\n\t\tFLinearColor LordColor;\r\n\r\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite)\r\n\t\tFLinearColor HeroColor;\r\n\r\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite)\r\n\t\tFLinearColor CoreColor;\r\n\r\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite)\r\n\t\tFLinearColor SpecialColor;\r\n\r\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite)\r\n\t\tFLinearColor RareColor;\r\n};\r\n/**\r\n * \r\n */\r\nUCLASS()\r\nclass FANTASYBATTLE_API UUI_CreationMainMenu : public UUserWidget\r\n{\r\n\tGENERATED_BODY()\r\n\r\npublic:\r\n\r\n\t////UUI_CreationMainMenu(const FObjectInitializer& ObjectInitializer);\r\n\r\n\tUFUNCTION(BlueprintCallable)\r\n\t\tFLinearColor GetRarityColor(const enum EUnitRarity UnitRarity);\r\n\r\n\t\tvirtual bool Initialize() override;\r\nprotected:\r\n\r\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Color\")\r\n\t\tFUnitColor RarityColor;\r\n\r\n\t//Called everytime a Buildunit have been created\r\n\tUFUNCTION(BlueprintImplementableEvent)\r\n\t\tvoid OnCreationUnitCreated(UUserWidget* CreationUnit, FUnitStat UnitStats, const FLinearColor UnitColor);\r\n\r\n\tUFUNCTION(BlueprintCallable)\r\n\t\tvoid CreateArmyUnit(const FUnitStat UnitStats);\r\n\r\n\t//Called everytime a ArmyUnit have been created\r\n\tUFUNCTION(BlueprintImplementableEvent)\r\n\t\tvoid OnArmyUnitCreated(class UUI_ArmyUnit* ArmyUnit);\r\n\r\nprivate:\r\n\r\n\tUPROPERTY(EditAnywhere, BlueprintReadOnly, Category = \"Army\", meta = (AllowPrivateAccess = \"true\"))\r\n\t\tTArray<UUI_ArmyUnit*> IncludedUnits;\r\n\r\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, meta = (BindWidget, AllowPrivateAccess = \"true\"))\r\n\t\tclass UScrollBox* BuildUnitPanel_Scroll;\r\n\r\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, meta = (BindWidget, AllowPrivateAccess = \"true\"))\r\n\t\tUScrollBox* ArmyIncluded_Scroll;\r\n\r\n\tUPROPERTY(EditAnywhere, BlueprintReadOnly, Category = \"Data\", meta = (AllowPrivateAccess = \"true\"))\r\n\t\tclass UDataTable* ManStatTable;\r\n\r\n\tUPROPERTY(EditAnywhere, BlueprintReadOnly, Category = \"Data\", meta = (AllowPrivateAccess = \"true\"))\r\n\t\tUDataTable* UnitStatTable;\r\n\r\n\tUPROPERTY(EditAnywhere, BlueprintReadOnly, Category = \"Blueprint Class\", meta = (AllowPrivateAccess = \"true\"))\r\n\t\tTSubclassOf<UUserWidget> BuildUnitClass;\r\n\r\n\tUPROPERTY(EditAnywhere, BlueprintReadOnly, Category = \"Blueprint Class\", meta = (AllowPrivateAccess = \"true\"))\r\n\t\tTSubclassOf<UUI_ArmyUnit> ArmyUnitClass;\r\n\r\n};\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Source/FantasyBattle/Public/UI_CreationMainMenu.h b/Source/FantasyBattle/Public/UI_CreationMainMenu.h
--- a/Source/FantasyBattle/Public/UI_CreationMainMenu.h	(revision 9b08c3c30042b95af90916955e891c673f23b32c)
+++ b/Source/FantasyBattle/Public/UI_CreationMainMenu.h	(date 1641633312000)
@@ -55,6 +55,9 @@
 	UFUNCTION(BlueprintCallable)
 		void CreateArmyUnit(const FUnitStat UnitStats);
 
+	UFUNCTION(BlueprintCallable)
+		void LoadArmy(const FArmyStat Army);
+
 	//Called everytime a ArmyUnit have been created
 	UFUNCTION(BlueprintImplementableEvent)
 		void OnArmyUnitCreated(class UUI_ArmyUnit* ArmyUnit);
@@ -76,6 +79,9 @@
 	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Data", meta = (AllowPrivateAccess = "true"))
 		UDataTable* UnitStatTable;
 
+	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Data", meta = (AllowPrivateAccess = "true"))
+		UDataTable* MountStatTable;
+
 	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Blueprint Class", meta = (AllowPrivateAccess = "true"))
 		TSubclassOf<UUserWidget> BuildUnitClass;
 
Index: Source/FantasyBattle/Public/UI_ArmyUnit.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// Fill out your copyright notice in the Description page of Project Settings.\r\n\r\n#pragma once\r\n\r\n#include \"CoreMinimal.h\"\r\n#include \"Blueprint/UserWidget.h\"\r\n#include \"EnumLibrary.h\"\r\n#include \"StructLibrary.h\"\r\n#include \"SpecialRules/Public/SpecialRulesLibrary.h\"\r\n#include \"UI_ArmyUnit.generated.h\"\r\n\r\n/**\r\n * \r\n */\r\nUCLASS()\r\nclass FANTASYBATTLE_API UUI_ArmyUnit : public UUserWidget\r\n{\r\n\tGENERATED_BODY()\r\n\r\npublic:\r\n\r\n\tvirtual bool Initialize() override;\r\n\r\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = \"Unit\")\r\n\t\tFUnitStat UnitProfil;\r\n\r\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Unit\")\r\n\t\tTMap<EProfilePrio, FManProfile> Profiler;\r\n\r\n\t//If overriden either add the profile to Profiler or make the call to parent!\r\n\tUFUNCTION(BlueprintNativeEvent)\r\n\t\tvoid AddProfile(const EProfilePrio Prio, const FManProfile Profil);\r\n\r\n\t//Called when all Profiles have been loaded\r\n\tUFUNCTION(BlueprintImplementableEvent, meta=(DisplayName =\"OnProfilesLoaded\"))\r\n\t\tvoid ProfilesLoaded();\r\n\r\n\t/*Called when Unitvalue Changes\r\n\t@Diffrence is the amount the new value change */\r\n\tUFUNCTION(BlueprintImplementableEvent, meta = (DisplayName = \"OnUnitValueChanged\"))\r\n\t\tvoid UnitValueChanged(int32 Diffrence);\r\n\r\n\tUFUNCTION(BlueprintPure)\r\n\t\tFORCEINLINE FGuid GetID() {return ID;}\r\n\r\n\tUFUNCTION(BlueprintPure)\r\n\t\tFORCEINLINE EUnitRarity GetUnitRarity() {return UnitProfil.Rarity;}\r\n\r\nprivate:\r\n\r\n\tUPROPERTY(BlueprintReadWrite, Category = \"Unit\", meta=(AllowPrivateAccess = \"true\"))\r\n\t\tint32 UnitValue;\r\n\r\n\tUPROPERTY(BlueprintReadWrite, Category = \"Unit\", meta = (AllowPrivateAccess = \"true\"))\r\n\t\tint32 StaticExtraPoints;\r\n\r\n\t\tvoid RecalcUnitValue();\r\n\r\nprotected:\r\n\r\n\tUFUNCTION(BlueprintCallable)\r\n\t\tvoid AddAntal(EProfilePrio Prio, int32 NewAntal);\r\n\r\nprivate:\r\n\r\n\tUPROPERTY(BlueprintReadWrite, Category = \"Identify\", meta = (AllowPrivateAccess = \"true\"))\r\n\t\tFGuid ID;\r\n\t\r\n};\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Source/FantasyBattle/Public/UI_ArmyUnit.h b/Source/FantasyBattle/Public/UI_ArmyUnit.h
--- a/Source/FantasyBattle/Public/UI_ArmyUnit.h	(revision 9b08c3c30042b95af90916955e891c673f23b32c)
+++ b/Source/FantasyBattle/Public/UI_ArmyUnit.h	(date 1641633312000)
@@ -28,17 +28,25 @@
 		TMap<EProfilePrio, FManProfile> Profiler;
 
 	//If overriden either add the profile to Profiler or make the call to parent!
-	UFUNCTION(BlueprintNativeEvent)
+	UFUNCTION(BlueprintNativeEvent, BlueprintCallable)
 		void AddProfile(const EProfilePrio Prio, const FManProfile Profil);
 
 	//Called when all Profiles have been loaded
 	UFUNCTION(BlueprintImplementableEvent, meta=(DisplayName ="OnProfilesLoaded"))
 		void ProfilesLoaded();
 
+	//Called when all Profiles have been loaded from a Savegame
+	UFUNCTION(BlueprintImplementableEvent, meta = (DisplayName = "OnProfilesLoadedFromSave"))
+		void ProfilesLoadedFromSave(const TArray<FText>& IncludedUpgrades);
+
 	/*Called when Unitvalue Changes
 	@Diffrence is the amount the new value change */
 	UFUNCTION(BlueprintImplementableEvent, meta = (DisplayName = "OnUnitValueChanged"))
-		void UnitValueChanged(int32 Diffrence);
+		void UnitValueChanged(float Diffrence, EUnitRarity Rarity);
+
+	/* Called when the number of units change*/
+	UFUNCTION(BlueprintImplementableEvent, meta = (DisplayName = "OnUnitAntalChanged"))
+		void UnitAntalChanged(int32 NewAntal, EProfilePrio Prio);
 
 	UFUNCTION(BlueprintPure)
 		FORCEINLINE FGuid GetID() {return ID;}
@@ -48,11 +56,11 @@
 
 private:
 
-	UPROPERTY(BlueprintReadWrite, Category = "Unit", meta=(AllowPrivateAccess = "true"))
-		int32 UnitValue;
+	UPROPERTY(BlueprintReadOnly, Category = "Unit", meta=(AllowPrivateAccess = "true"))
+		float UnitValue;
 
-	UPROPERTY(BlueprintReadWrite, Category = "Unit", meta = (AllowPrivateAccess = "true"))
-		int32 StaticExtraPoints;
+	UPROPERTY(BlueprintReadOnly, Category = "Unit", meta = (AllowPrivateAccess = "true"))
+		float StaticExtraPoints;
 
 		void RecalcUnitValue();
 
@@ -61,9 +69,20 @@
 	UFUNCTION(BlueprintCallable)
 		void AddAntal(EProfilePrio Prio, int32 NewAntal);
 
+	UFUNCTION(BlueprintCallable)
+		void AddStaticExtraValue(float AddValue);
+
+	UFUNCTION(BlueprintCallable)
+		void ChangeProfileCost(EProfilePrio Prio, float ExtraValue);
+
+	UFUNCTION(BlueprintCallable)
+		void RemoveProfile(EProfilePrio Prio);
+
+	UFUNCTION(BlueprintCallable)
+		TMap<EProfilePrio, FManProfile> LoadProfiles(const FMountUpgrade MountUpgrade, class UDataTable* ProfilData, EProfilePrio Parent);
+
 private:
 
-	UPROPERTY(BlueprintReadWrite, Category = "Identify", meta = (AllowPrivateAccess = "true"))
 		FGuid ID;
 	
 };
Index: Source/FantasyBattle/Public/Mode/GS_FantasyBattle_Play.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Source/FantasyBattle/Public/Mode/GS_FantasyBattle_Play.h b/Source/FantasyBattle/Public/Mode/GS_FantasyBattle_Play.h
new file mode 100644
--- /dev/null	(date 1642107272000)
+++ b/Source/FantasyBattle/Public/Mode/GS_FantasyBattle_Play.h	(date 1642107272000)
@@ -0,0 +1,17 @@
+// Fill out your copyright notice in the Description page of Project Settings.
+
+#pragma once
+
+#include "CoreMinimal.h"
+#include "GameFramework/GameStateBase.h"
+#include "GS_FantasyBattle_Play.generated.h"
+
+/**
+ * 
+ */
+UCLASS()
+class FANTASYBATTLE_API AGS_FantasyBattle_Play : public AGameStateBase
+{
+	GENERATED_BODY()
+	
+};
Index: Source/FantasyBattle/Public/Mode/GM_FantasyBattle_Play.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Source/FantasyBattle/Public/Mode/GM_FantasyBattle_Play.h b/Source/FantasyBattle/Public/Mode/GM_FantasyBattle_Play.h
new file mode 100644
--- /dev/null	(date 1642109794000)
+++ b/Source/FantasyBattle/Public/Mode/GM_FantasyBattle_Play.h	(date 1642109794000)
@@ -0,0 +1,25 @@
+// Fill out your copyright notice in the Description page of Project Settings.
+
+#pragma once
+
+#include "CoreMinimal.h"
+#include "GameFramework/GameModeBase.h"
+#include "GM_FantasyBattle_Play.generated.h"
+
+
+class APlayerController;
+/**
+ * 
+ */
+UCLASS()
+class FANTASYBATTLE_API AGM_FantasyBattle_Play : public AGameModeBase
+{
+	GENERATED_BODY()
+
+public:
+
+	/*AGM_FantasyBattle_Play();
+
+	virtual void PostLogin(APlayerController* NewPlayer) override;
+	*/
+};
Index: Source/FantasyBattle/Public/Mode/GameSession_FantasyBattle.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Source/FantasyBattle/Public/Mode/GameSession_FantasyBattle.h b/Source/FantasyBattle/Public/Mode/GameSession_FantasyBattle.h
new file mode 100644
--- /dev/null	(date 1642373450000)
+++ b/Source/FantasyBattle/Public/Mode/GameSession_FantasyBattle.h	(date 1642373450000)
@@ -0,0 +1,17 @@
+// Fill out your copyright notice in the Description page of Project Settings.
+
+#pragma once
+
+#include "CoreMinimal.h"
+#include "GameFramework/GameSession.h"
+#include "GameSession_FantasyBattle.generated.h"
+
+/**
+ * 
+ */
+UCLASS()
+class FANTASYBATTLE_API AGameSession_FantasyBattle : public AGameSession
+{
+	GENERATED_BODY()
+	
+};
Index: Source/FantasyBattle/Public/Mode/PC_FantasyBattle_PreGame.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Source/FantasyBattle/Public/Mode/PC_FantasyBattle_PreGame.h b/Source/FantasyBattle/Public/Mode/PC_FantasyBattle_PreGame.h
new file mode 100644
--- /dev/null	(date 1643456473544)
+++ b/Source/FantasyBattle/Public/Mode/PC_FantasyBattle_PreGame.h	(date 1643456473544)
@@ -0,0 +1,56 @@
+// Fill out your copyright notice in the Description page of Project Settings.
+
+#pragma once
+
+#include "CoreMinimal.h"
+#include "GameFramework/PlayerController.h"
+#include "Interfaces/LobbyInterface.h"
+#include "UI/Lobbby/UI_LobbyMenu.h"
+#include "PC_FantasyBattle_PreGame.generated.h"
+
+struct FArmyStatM;
+/**
+ * 
+ */
+UCLASS()
+class FANTASYBATTLE_API APC_FantasyBattle_PreGame : public APlayerController, public ILobbyInterface
+{
+	GENERATED_BODY()
+
+public:
+	
+	UFUNCTION(Client, Reliable)
+	void C_InitPC();
+
+	virtual void BeginPlay() override;
+
+	UFUNCTION(Client, Reliable)
+	void NewPlayerJoined(const FUniqueNetIdRepl& PlayerID);
+
+	UFUNCTION(Client, Reliable)
+	void C_GameStarting();
+
+	virtual void SetIsReady(bool newValue) override;
+	virtual void SetArmy(int32 ArrayIndex) override;
+	
+	void UpdateCountDownTimer(int32 TimeLeft);
+
+private:
+
+	UPROPERTY()
+	UUI_LobbyMenu* LobbyMenuPtr;
+
+	ILobbyInterface* LobbyInterface;
+	
+	FTimerHandle WaitingForPlayerStateTimer;
+	FTimerHandle LookingForPlayerTimer;
+	TArray<FUniqueNetIdRepl> UnfoundPlayers;
+
+	bool bInitializedLobbyGameInfo;
+
+	void WaitingForPS();
+	void LookingForPlayer();
+
+	TArray<FArmyStat> AvailableArmies;
+	FArmyStat SelectedArmy;
+};
Index: Source/FantasyBattle/Public/UI/Lobbby/UI_LobbyMenu.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Source/FantasyBattle/Public/UI/Lobbby/UI_LobbyMenu.h b/Source/FantasyBattle/Public/UI/Lobbby/UI_LobbyMenu.h
new file mode 100644
--- /dev/null	(date 1643469239516)
+++ b/Source/FantasyBattle/Public/UI/Lobbby/UI_LobbyMenu.h	(date 1643469239516)
@@ -0,0 +1,82 @@
+// Fill out your copyright notice in the Description page of Project Settings.
+
+#pragma once
+
+#include "CoreMinimal.h"
+#include "Blueprint/UserWidget.h"
+//#include "Components/BackgroundBlur.h"
+#include "Interfaces/LobbyInterface.h"
+#include "UI_LobbyMenu.generated.h"
+
+class UTextBlock;
+class UButton;
+class UComboBoxString;
+class UBackgroundBlur;
+
+/**
+ * 
+ */
+UCLASS()
+class FANTASYBATTLE_API UUI_LobbyMenu : public UUserWidget
+{
+	GENERATED_BODY()
+
+public:
+		
+	virtual bool Initialize() override;
+	
+	void SetupMenu(int32 OwnerID, FString PlayerName);
+
+	void SetupArmyInfo(int32 MaxSize, TArray<FArmyStat> Armies);
+
+	UFUNCTION(BlueprintImplementableEvent)
+	void CreatePlayerWidget(const FString& PlayerName, const int32 PlayerID);
+
+	void SetLobbyInterface(ILobbyInterface* Interface);
+
+	void UpdateCountDownTimer(int32 TimeLeft);
+
+protected:
+
+	UPROPERTY(BlueprintReadOnly)
+	int32 ParentID;
+
+	UFUNCTION(BlueprintImplementableEvent)
+	void UpdateReadyState(bool newValue, int32 PlayerID);
+
+	UPROPERTY(BlueprintReadOnly)
+	int32 MaxArmySize;
+	
+	UPROPERTY(VisibleAnywhere, BlueprintReadOnly, meta = (BindWidget), Category="Component")
+	UButton* Ready_Btn;
+	
+	UPROPERTY(VisibleAnywhere, BlueprintReadOnly, meta = (BindWidget), Category="Component")
+	UComboBoxString* Armies_Combo;
+	
+	UPROPERTY(VisibleAnywhere, BlueprintReadOnly, meta = (BindWidget), Category="Component")
+	UTextBlock* ArmySize_Text;
+	
+	UPROPERTY(VisibleAnywhere, BlueprintReadOnly, meta = (BindWidget), Category="Component")
+	UTextBlock* ReadyBtn_Text;
+	
+	UPROPERTY(VisibleAnywhere, BlueprintReadOnly, meta = (BindWidget), Category="Component")
+	UBackgroundBlur* BG_Blur;
+	
+	UPROPERTY(VisibleAnywhere, BlueprintReadOnly, meta = (BindWidget), Category="Component")
+	UTextBlock* CountDown_Text;
+private:
+	ILobbyInterface* LobbyInterface;
+
+	UPROPERTY(VisibleAnywhere)
+	bool bIsReady;
+	
+	void UpdateReadyBtnText();
+	
+	UFUNCTION()
+	void ReadyClick();
+	
+	UFUNCTION()
+	void ArmySelectionChanged(FString SelectedItem, ESelectInfo::Type SelectionType);
+	
+	
+};
Index: Source/FantasyBattle/Public/EnumLibrary.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// Fill out your copyright notice in the Description page of Project Settings.\r\n\r\n#pragma once\r\n\r\n#include \"CoreMinimal.h\"\r\n#include \"Kismet/BlueprintFunctionLibrary.h\"\r\n#include \"EnumLibrary.generated.h\"\r\n\r\ntemplate<typename TEnum>\r\nstatic FORCEINLINE FString GetEnumValueToString(const FString& Name, TEnum Value)\r\n{\r\n\tconst UEnum* enumPtr = FindObject<UEnum>(ANY_PACKAGE, *Name, true);\r\n\tif (!enumPtr)\r\n\t{\r\n\t\treturn FString(\"Invalid\");\r\n\t}\r\n\treturn enumPtr->GetDisplayNameTextByValue((int64)Value).ToString();//GetNameByValue((int64)Value).ToString();\r\n}\r\n\r\ntemplate<typename T>\r\nstatic FORCEINLINE TArray<T> EnumGetList(const FString& enumName)\r\n{\r\n\tTArray<T> lResult;\r\n\tUEnum* pEnum = FindObject<UEnum>(ANY_PACKAGE, *enumName, true);\r\n\tint max = pEnum->ContainsExistingMax() ? pEnum->GetMaxEnumValue() - 1 : pEnum->GetMaxEnumValue();\r\n\tfor (int i = 0; i <= max; ++i)\r\n\t{\r\n\t\tif (pEnum->IsValidEnumValue(i))\r\n\t\t\tlResult.Add(static_cast<T>(i));\r\n\t}\r\n\treturn lResult;\r\n}\r\n\r\n\r\nUENUM(BlueprintType)\r\nenum class EArmies : uint8\r\n{\r\n\tE_Lizardmen UMETA(DisplayName = \"Lizarmen\"),\r\n\tE_Bretonnia UMETA(DisplayName = \"Bretonnia\"),\r\n\tE_OrcGoblin UMETA(DisplayName = \"Orcs and Goblins\")\r\n};\r\n\r\nUENUM(BlueprintType)\r\nenum class EUnitRarity : uint8\r\n{\r\n\tE_Lord UMETA(DisplayName = \"Lord\"),\r\n\tE_Hero UMETA(DisplayName = \"Hero\"),\r\n\tE_Core UMETA(DisplayName = \"Core\"),\r\n\tE_Special UMETA(DisplayName = \"Special\"),\r\n\tE_Rare UMETA(DisplayName = \"Rare\")\r\n};\r\n\r\nUENUM(BlueprintType)\r\nenum class ETroopType : uint8\r\n{\r\n\tE_Infantry UMETA(DisplayName = \"Infantry\"),\r\n\tE_Monstinf UMETA(DisplayName = \"Monstrous Infantry\"),\r\n\tE_Cavalry UMETA(DisplayName = \"Cavalry\"),\r\n\tE_Monstcavalry UMETA(DisplayName = \"Monstrous Cavalry\"),\r\n\tE_Swarm UMETA(DisplayName = \"Swarm\"),\r\n\tE_Warbeast UMETA(DisplayName = \"War Beast\"),\r\n\tE_Monstbeast UMETA(DisplayName = \"Monstrous Beast\"),\r\n\tE_Monster UMETA(DisplayName = \"Monster\"),\r\n\tE_Chariot UMETA(DisplayName = \"Chariot\"),\r\n\tE_Warmachine UMETA(DisplayName = \"War Machine\")\r\n};\r\n\r\nUENUM(BlueprintType)\r\nenum class EWeapons : uint8\r\n{\r\n\tE_None UMETA(DisplayName = \"None\"),\r\n\tE_Handweapon UMETA(DisplayName = \"Hand Weapon\"),\r\n\tE_Bow UMETA(DisplayName = \"Bow\"),\r\n\tE_Blowpipe UMETA(DisplayName = \"Blowpipe\"),\r\n\tE_Crossbow UMETA(DisplayName = \"Cross Bow\"),\r\n\tE_Flail UMETA(DisplayName = \"Flail\"),\r\n\tE_Giantblowpipes UMETA(DisplayName = \"Giant Blowpipes\"),\r\n\tE_Giantbow UMETA(DisplayName = \"Giant Bow\"),\r\n\tE_Greatweapon UMETA(DisplayName = \"Great Weapon\"),\r\n\tE_Halberd UMETA(DisplayName = \"Halberd\"),\r\n\tE_Handgun UMETA(DisplayName = \"Handgun\"),\r\n\tE_Lustrianjavelin UMETA(DisplayName = \"Lustrian Javelin\"),\r\n\tE_Javelin UMETA(DisplayName = \"Javelin\"),\r\n\tE_Lance UMETA(DisplayName = \"Lance\"),\r\n\tE_Longbow UMETA(DisplayName = \"Longbow\"),\r\n\tE_Morningstar UMETA(DisplayName = \"Morning Star\"),\r\n\tE_Pistol UMETA(DisplayName = \"Pistol\"),\r\n\tE_Bracepistol_melee UMETA(DisplayName = \"Brace of Pistols (Melee)\"),\r\n\tE_Bracepistol_ranged UMETA(DisplayName = \"Brace of Pistols (Ranged)\"),\r\n\tE_Shortbow UMETA(DisplayName = \"Short Bow\"),\r\n\tE_Sling UMETA(DisplayName = \"Sling\"),\r\n\tE_Spear_foot UMETA(DisplayName = \"Spear (Foot)\"),\r\n\tE_Spear_mount UMETA(DisplayName = \"Spear (Mount)\"),\r\n\tE_Throwingweapon UMETA(DisplayName = \"Throwing Weapons\"),\r\n\tE_Throwingaxes UMETA(DisplayName = \"Throwing Axes\"),\r\n\tE_Additionalhandweapon UMETA(DisplayName = \"Additional Hand Weapon\"),\r\n\tE_Arkofsotek UMETA(DisplayName = \"Ark of Sotek\"),\r\n\tE_Fireleechbolas UMETA(DisplayName = \"Fireleech Bolas\"),\r\n\tE_Solarengine UMETA(DisplayName = \"Solar Engine\"),\r\n\tE_Engineofthegods UMETA(DisplayName = \"Engine of the Gods\"),\r\n};\r\n\r\nUENUM(BlueprintType)\r\nenum class EArmor : uint8\r\n{\r\n\tE_None UMETA(DisplayName = \"None\"),\r\n\tE_Lightarmor UMETA(DisplayName = \"Light Armor\"),\r\n\tE_Heavyarmor UMETA(DisplayName = \"Heavy Armor\"),\r\n\tE_Shield UMETA(DisplayName = \"Shield\")\r\n};\r\n\r\nUENUM(BlueprintType)\r\nenum class EMagicLores : uint8\r\n{\r\n\tE_LoreFire UMETA(DisplayName = \"The Lore of Fire\"),\r\n\tE_LoreBeasts UMETA(DisplayName = \"The Lore of Beats\"),\r\n\tE_LoreMetal UMETA(DisplayName = \"The Lore of Metal\"),\r\n\tE_LoreLight UMETA(DisplayName = \"The Lore of Light\"),\r\n\tE_LoreLife UMETA(DisplayName = \"The Lore of Life\"),\r\n\tE_LoreHeavens UMETA(DisplayName = \"The Lore of Heavens\"),\r\n\tE_LoreShadow UMETA(DisplayName = \"The Lore of  Shadow\"),\r\n\tE_LoreDeath UMETA(DisplayName = \"The Lore of Death\"),\r\n\tE_LoreHighMagic UMETA(DisplayName = \"The Lore of High Magic\"),\r\n\tE_SpellsBigWaaagh UMETA(DisplayName = \"Spells of Da Big Waaagh!\"),\r\n\tE_SpellsLittleWaaagh UMETA(DisplayName = \"Spells of Da Little Waaagh!\")\r\n};\r\n\r\nUENUM(BlueprintType)\r\nenum class EDiceRequirement : uint8\r\n{\r\n\tE_None UMETA(DisplayName = \"None\"),\r\n\tE_1p UMETA(DisplayName = \"1+\"),\r\n\tE_2p UMETA(DisplayName = \"2+\"),\r\n\tE_3p UMETA(DisplayName = \"3+\"),\r\n\tE_4p UMETA(DisplayName = \"4+\"),\r\n\tE_5p UMETA(DisplayName = \"5+\"),\r\n\tE_6p UMETA(DisplayName = \"6+\"),\r\n\tE_7p UMETA(DisplayName = \"7+\")\r\n};\r\n\r\nUENUM(BlueprintType)\r\nenum class EDiceNumber : uint8\r\n{\r\n\tE_None UMETA(DisplayName = \"None\"),\r\n\tE_D3 UMETA(DisplayName = \"D3\"),\r\n\tE_D6 UMETA(DisplayName = \"D6\"),\r\n\tE_2D6 UMETA(DisplayName = \"2D6\"),\r\n\tE_3D6 UMETA(DisplayName = \"3D6\")\r\n};\r\n\r\nUENUM(BlueprintType)\r\nenum class EProfilePrio : uint8\r\n{\r\n\tE_Unit UMETA(DisplayName = \"Unit\"),\r\n\tE_Main UMETA(DisplayName = \"Main\"),\r\n\tE_Secondary UMETA(DisplayName = \"Secondary\"),\r\n\tE_Mount UMETA(DisplayName = \"Mount\"),\r\n\tE_Sub UMETA(DisplayName = \"Sub\"),\r\n\tE_SubMount UMETA(DisplayName = \"SubMount\")\r\n};\r\n/**\r\n * \r\n */\r\nUCLASS()\r\nclass FANTASYBATTLE_API UEnumLibrary : public UBlueprintFunctionLibrary\r\n{\r\n\tGENERATED_BODY()\r\n\t\r\n};\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Source/FantasyBattle/Public/EnumLibrary.h b/Source/FantasyBattle/Public/EnumLibrary.h
--- a/Source/FantasyBattle/Public/EnumLibrary.h	(revision 9b08c3c30042b95af90916955e891c673f23b32c)
+++ b/Source/FantasyBattle/Public/EnumLibrary.h	(date 1641633312000)
@@ -50,6 +50,16 @@
 	E_Rare UMETA(DisplayName = "Rare")
 };
 
+UENUM(BlueprintType)
+enum class EUpgradeTypes : uint8
+{
+	E_Command UMETA(DisplayName = "CommandGroup Upgrade"),
+	E_Equipment UMETA(DisplayName = "Equipment Upgrade"),
+	E_Rule UMETA(DisplayName = "Specialrule Upgrade"),
+	E_SubUnit UMETA(DisplayName = "Sub Unit Upgrade"),
+	E_Mount UMETA(DisplayName = "Mount Upgrade")
+}; 
+
 UENUM(BlueprintType)
 enum class ETroopType : uint8
 {
Index: Source/FantasyBattle/Public/UI/PreGame/UI_GS_PreGame.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Source/FantasyBattle/Public/UI/PreGame/UI_GS_PreGame.h b/Source/FantasyBattle/Public/UI/PreGame/UI_GS_PreGame.h
new file mode 100644
--- /dev/null	(date 1642713076000)
+++ b/Source/FantasyBattle/Public/UI/PreGame/UI_GS_PreGame.h	(date 1642713076000)
@@ -0,0 +1,18 @@
+// Fill out your copyright notice in the Description page of Project Settings.
+
+#pragma once
+
+#include "CoreMinimal.h"
+#include "Blueprint/UserWidget.h"
+#include "UI_GS_PreGame.generated.h"
+
+/**
+ * 
+ */
+UCLASS()
+class FANTASYBATTLE_API UUI_GS_PreGame : public UUserWidget
+{
+	GENERATED_BODY()
+
+
+};
Index: Source/FantasyBattle/Public/StructLibrary.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// Fill out your copyright notice in the Description page of Project Settings.\r\n\r\n#pragma once\r\n\r\n#include \"CoreMinimal.h\"\r\n#include \"Engine/DataTable.h\"\r\n#include \"SpecialRules/Public/SpecialRulesLibrary.h\"\r\n#include \"EnumLibrary.h\"\r\n#include \"StructLibrary.generated.h\"\r\n\r\n\r\nUSTRUCT(BlueprintType)\r\nstruct FUnitConstruction\r\n{\r\n\tGENERATED_USTRUCT_BODY()\r\n\r\n\tUPROPERTY(EditDefaultsOnly, BlueprintReadWrite)\r\n\t\tint32 MinAntal;\r\n\r\n\tUPROPERTY(EditDefaultsOnly, BlueprintReadWrite)\r\n\t\tint32 MaxAntal;\r\n\r\n\tUPROPERTY(EditDefaultsOnly, BlueprintReadWrite)\r\n\t\tint32 Points;\r\n\r\n\tUPROPERTY(EditDefaultsOnly, BlueprintReadWrite)\r\n\t\tfloat SecondaryRatio;\r\n\r\n\tUPROPERTY(EditDefaultsOnly, BlueprintReadWrite)\r\n\t\tint32 SecondaryPoints;\r\n\r\n\tUPROPERTY(EditDefaultsOnly, BlueprintReadWrite)\r\n\t\tint32 SubProfileCount;\r\n};\r\n\r\nUSTRUCT(BlueprintType)\r\nstruct FUnitCommandUpgrade\r\n{\r\n\tGENERATED_USTRUCT_BODY()\r\n\r\n\t\tUPROPERTY(EditDefaultsOnly, BlueprintReadWrite)\r\n\t\tint32 UpgradeCost;\r\n\r\n\tUPROPERTY(EditDefaultsOnly, BlueprintReadWrite)\r\n\t\tbool bChampion;\r\n\r\n\tUPROPERTY(EditDefaultsOnly, BlueprintReadWrite)\r\n\t\tbool bStandardbearer;\r\n\r\n\tUPROPERTY(EditDefaultsOnly, BlueprintReadWrite)\r\n\t\tbool bMusician;\r\n\r\n\tUPROPERTY(EditDefaultsOnly, BlueprintReadWrite)\r\n\t\tFText ChampionName;\r\n\r\n\t//If it got several profile boosts they are seperated by ;\r\n\tUPROPERTY(EditDefaultsOnly, BlueprintReadWrite)\r\n\t\tFText ChampionBonusStat;\r\n\r\n\tUPROPERTY(EditDefaultsOnly, BlueprintReadWrite)\r\n\t\tint32 ChampionMagicItemLimit;\r\n\r\n\tUPROPERTY(EditDefaultsOnly, BlueprintReadWrite)\r\n\t\tint32 StandardMagicItemLimit;\r\n};\r\n\r\nUSTRUCT(BlueprintType)\r\nstruct FManstat\r\n{\r\n\tGENERATED_USTRUCT_BODY()\r\n\r\npublic:\r\n\r\n\tUPROPERTY(EditDefaultsOnly, BlueprintReadWrite)\r\n\t\tint32 Movement;\r\n\r\n\tUPROPERTY(EditDefaultsOnly, BlueprintReadWrite)\r\n\t\tint32 Weaponskill;\r\n\r\n\tUPROPERTY(EditDefaultsOnly, BlueprintReadWrite)\r\n\t\tint32 Ballisticskill;\r\n\r\n\tUPROPERTY(EditDefaultsOnly, BlueprintReadWrite)\r\n\t\tint32 Strength;\r\n\r\n\tUPROPERTY(EditDefaultsOnly, BlueprintReadWrite)\r\n\t\tint32 Toughness;\r\n\r\n\tUPROPERTY(EditDefaultsOnly, BlueprintReadWrite)\r\n\t\tint32 Wound;\r\n\r\n\tUPROPERTY(EditDefaultsOnly, BlueprintReadWrite)\r\n\t\tint32 Initiativ;\r\n\r\n\tUPROPERTY(EditDefaultsOnly, BlueprintReadWrite)\r\n\t\tint32 Attack;\r\n\r\n\tUPROPERTY(EditDefaultsOnly, BlueprintReadWrite)\r\n\t\tint32 Leadership;\r\n};\r\n\r\nUSTRUCT(BlueprintType)\r\nstruct FSpecialRule\r\n{\r\n\tGENERATED_USTRUCT_BODY()\r\n\r\n\tUPROPERTY(EditDefaultsOnly, BlueprintReadOnly)\r\n\t\tESpecialRule Rule;\r\n\r\n\tUPROPERTY(EditDefaultsOnly, BlueprintReadOnly)\r\n\t\tEDiceRequirement BonusStat;\r\n\r\n\tUPROPERTY(EditDefaultsOnly, BlueprintReadOnly)\r\n\t\tEDiceNumber DiceStat;\r\n\r\n\tUPROPERTY(EditDefaultsOnly, BlueprintReadOnly)\r\n\t\tint32 IntStat;\r\n\r\n};\r\n\r\nUSTRUCT(BlueprintType)\r\nstruct FBaseUpgrade\r\n{\r\n\tGENERATED_USTRUCT_BODY()\r\n\r\n\tUPROPERTY(EditDefaultsOnly, BlueprintReadOnly)\r\n\t\tint32 UpgradeCost;\r\n\r\n\tUPROPERTY(EditDefaultsOnly, BlueprintReadOnly)\r\n\t\tFText UpgradeText;\r\n\r\n};\r\n\r\nUSTRUCT(BlueprintType)\r\nstruct FEquipmentUpgrade : public FBaseUpgrade\r\n{\r\n\tGENERATED_USTRUCT_BODY()\r\n\r\n\tUPROPERTY(EditDefaultsOnly, BlueprintReadOnly)\r\n\t\tTArray<EWeapons> AddWeapon;\r\n\r\n\tUPROPERTY(EditDefaultsOnly, BlueprintReadOnly)\r\n\t\tTArray<EWeapons> RemoveWeapon;\r\n\r\n\tUPROPERTY(EditDefaultsOnly, BlueprintReadOnly)\r\n\t\tTArray<EArmor> AddArmor;\r\n\r\n\tUPROPERTY(EditDefaultsOnly, BlueprintReadOnly)\r\n\t\tTArray<EArmor> RemoveArmor;\r\n\r\n\tUPROPERTY(EditDefaultsOnly, BlueprintReadOnly)\r\n\t\tint32 UpgradeGroup;\r\n};\r\n\r\nUSTRUCT(BlueprintType)\r\nstruct FSpecialRuleUpgrade : public FBaseUpgrade\r\n{\r\n\tGENERATED_USTRUCT_BODY()\r\n\r\n\tUPROPERTY(EditDefaultsOnly, BlueprintReadOnly)\r\n\t\tTArray<ESpecialRule> AddSpecialRule;\r\n\r\n\tUPROPERTY(EditDefaultsOnly, BlueprintReadOnly)\r\n\t\tTArray<ESpecialRule> RemoveSpecialRule;\r\n};\r\n\r\nUSTRUCT(BlueprintType)\r\nstruct FMountUpgrade : public FBaseUpgrade\r\n{\r\n\tGENERATED_USTRUCT_BODY()\r\n\r\n\tUPROPERTY(EditDefaultsOnly, BlueprintReadOnly)\r\n\t\tFName MountName;\r\n};\r\n\r\nUSTRUCT(BlueprintType)\r\nstruct FSubProfileUpgrade : public FBaseUpgrade\r\n{\r\n\tGENERATED_USTRUCT_BODY()\r\n\r\n\t//Added to the SubProfileCount\r\n\tUPROPERTY(EditDefaultsOnly, BlueprintReadOnly)\r\n\t\tint32 Antal;\r\n\r\n\tUPROPERTY(EditDefaultsOnly, BlueprintReadOnly)\r\n\t\tTArray<EWeapons> AddWeapon;\r\n\r\n\tUPROPERTY(EditDefaultsOnly, BlueprintReadOnly)\r\n\t\tTArray<EWeapons> RemoveWeapon;\r\n};\r\n\r\nUSTRUCT(BlueprintType)\r\nstruct FUnitStat : public FTableRowBase\r\n{\r\n\tGENERATED_USTRUCT_BODY()\r\n\r\npublic:\r\n\r\n\tUPROPERTY(EditDefaultsOnly, BlueprintReadOnly)\r\n\t\tFText UnitNavn;\r\n\r\n\tUPROPERTY(EditDefaultsOnly, BlueprintReadOnly)\r\n\t\tFText UnitPointText;\r\n\r\n\tUPROPERTY(EditAnywhere, BlueprintReadOnly)\r\n\t\tFText UnitAntalText;\r\n\r\n\tUPROPERTY(EditDefaultsOnly, BlueprintReadOnly)\r\n\t\tUTexture2D* UnitImage;\r\n\r\n\tUPROPERTY(EditDefaultsOnly, BlueprintReadOnly)\r\n\t\tFUnitConstruction ConstructionsValues;\r\n\r\n\tUPROPERTY(EditDefaultsOnly, BlueprintReadOnly)\r\n\t\tEUnitRarity Rarity;\r\n\r\n\tUPROPERTY(EditDefaultsOnly, BlueprintReadOnly)\r\n\t\tETroopType TroopType;\r\n\r\n\tUPROPERTY(EditDefaultsOnly, BlueprintReadOnly)\r\n\t\tEArmies ArmyGroup;\r\n\r\n\tUPROPERTY(EditDefaultsOnly, BlueprintReadOnly)\r\n\t\tFName MainProfileName;\r\n\r\n\tUPROPERTY(EditDefaultsOnly, BlueprintReadOnly)\r\n\t\tFName SecondaryProfileName;\r\n\r\n\tUPROPERTY(EditDefaultsOnly, BlueprintReadOnly)\r\n\t\tFName MountProfileName;\r\n\r\n\tUPROPERTY(EditDefaultsOnly, BlueprintReadOnly)\r\n\t\tFName SubProfileName;\r\n\r\n\tUPROPERTY(EditDefaultsOnly, BlueprintReadOnly)\r\n\t\tFName SubMountProfileName;\r\n\r\n\tUPROPERTY(EditDefaultsOnly, BlueprintReadOnly)\r\n\t\tFUnitCommandUpgrade CommandUpgrades;\r\n\r\n\tUPROPERTY(EditDefaultsOnly, BlueprintReadOnly)\r\n\t\tTArray<FSubProfileUpgrade> SubProfileUpgrades;\r\n\r\n\tFUnitStat()\r\n\t{\r\n\t\tUnitImage = nullptr;\r\n\t}\r\n\r\n\tFUnitStat(FUnitStat* NewProfile)\r\n\t{\r\n\t\tUnitNavn = NewProfile->UnitNavn;\r\n\t\tUnitPointText = NewProfile->UnitPointText;\r\n\t\tUnitAntalText = NewProfile->UnitAntalText;\r\n\t\tUnitImage = NewProfile->UnitImage;\r\n\t\tConstructionsValues = NewProfile->ConstructionsValues;\r\n\t\tRarity = NewProfile->Rarity;\r\n\t\tTroopType = NewProfile->TroopType;\r\n\t\tArmyGroup = NewProfile->ArmyGroup;\r\n\t\tMainProfileName = NewProfile->MainProfileName;\r\n\t\tSecondaryProfileName = NewProfile->SecondaryProfileName;\r\n\t\tSubProfileName = NewProfile->SubProfileName;\r\n\t\tMountProfileName = NewProfile->MountProfileName;\r\n\t\tCommandUpgrades = NewProfile->CommandUpgrades;\r\n\t\tSubProfileUpgrades = NewProfile->SubProfileUpgrades;\r\n\t}\r\n};\r\n\r\nUSTRUCT(BlueprintType)\r\nstruct FManProfile : public FTableRowBase\r\n{\r\n\tGENERATED_USTRUCT_BODY()\r\n\r\n\tUPROPERTY(EditDefaultsOnly, BlueprintReadOnly)\r\n\t\tFText ProfileName;\r\n\r\n\tUPROPERTY(EditAnywhere, BlueprintReadOnly)\r\n\t\tint32 Antal;\r\n\r\n\tUPROPERTY(EditDefaultsOnly, BlueprintReadOnly)\r\n\t\tFManstat ProfileStats;\r\n\r\n\tUPROPERTY(EditAnywhere, BlueprintReadOnly)\r\n\t\tint32 WizardLvl;\r\n\r\n\tUPROPERTY(EditDefaultsOnly, BlueprintReadOnly)\r\n\t\tTArray<EMagicLores> WizardLores;\r\n\r\n\tUPROPERTY(EditAnywhere, BlueprintReadOnly)\r\n\t\tTArray<EWeapons> Weapons;\r\n\r\n\tUPROPERTY(EditAnywhere, BlueprintReadOnly)\r\n\t\tTArray<EArmor> Armor;\r\n\r\n\tUPROPERTY(EditAnywhere, BlueprintReadOnly)\r\n\t\tESpecialRule SpecialRules;\r\n\r\n\tUPROPERTY(EditDefaultsOnly, BlueprintReadOnly)\r\n\t\tFVector BaseSize;\r\n\r\n\tUPROPERTY(EditDefaultsOnly, BlueprintReadOnly)\r\n\t\tTArray<FSpecialRuleUpgrade> SpecialRuleUpgrade;\r\n\r\n\tUPROPERTY(EditDefaultsOnly, BlueprintReadOnly)\r\n\t\tTArray<FEquipmentUpgrade> EquipmentUpgrade;\r\n\r\n\tUPROPERTY(EditAnywhere, BlueprintReadOnly)\r\n\t\tEProfilePrio Prio;\r\n\r\n\tUPROPERTY(EditAnywhere, BlueprintReadOnly)\r\n\t\tEProfilePrio ParentPrio;\r\n\r\n\tFManProfile()\r\n\t{\r\n\t}\r\n\r\n\tFManProfile(FManProfile* NewProfile)\r\n\t{\r\n\t\tProfileName = NewProfile->ProfileName;\r\n\t\tAntal = NewProfile->Antal;\r\n\t\tProfileStats = NewProfile->ProfileStats;\r\n\t\tWizardLvl = NewProfile->WizardLvl;\r\n\t\tWizardLores = NewProfile->WizardLores;\r\n\t\tWeapons = NewProfile->Weapons;\r\n\t\tArmor = NewProfile->Armor;\r\n\t\tSpecialRules = NewProfile->SpecialRules;\r\n\t\tBaseSize = NewProfile->BaseSize;\r\n\t\tSpecialRuleUpgrade = NewProfile->SpecialRuleUpgrade;\r\n\t\tEquipmentUpgrade = NewProfile->EquipmentUpgrade;\r\n\t\tPrio = NewProfile->Prio;\r\n\t\tParentPrio = NewProfile->ParentPrio;\r\n\t}\r\n};\r\n\r\nUSTRUCT(BlueprintType)\r\nstruct FMountProfile : public FTableRowBase\r\n{\r\n\tGENERATED_USTRUCT_BODY()\r\n\r\n\tUPROPERTY(EditDefaultsOnly, BlueprintReadOnly)\r\n\t\tFText ProfileName;\r\n\r\n\tUPROPERTY(EditDefaultsOnly, BlueprintReadOnly)\r\n\t\tFManstat ProfileStats;\r\n\r\n\tUPROPERTY(EditAnywhere, BlueprintReadOnly)\r\n\t\tTArray<ESpecialRule> SpecialRules;\r\n\r\n\tUPROPERTY(EditDefaultsOnly, BlueprintReadOnly)\r\n\t\tFName SubProfile;\r\n\r\n\tUPROPERTY(EditDefaultsOnly, BlueprintReadOnly)\r\n\t\tFName SubMountProfile;\r\n\r\n\tUPROPERTY(EditDefaultsOnly, BlueprintReadOnly)\r\n\t\tint32 SubCount;\r\n\r\n\tUPROPERTY(EditDefaultsOnly, BlueprintReadOnly)\r\n\t\tint32 SubMountCount;\r\n\r\n\tUPROPERTY(EditDefaultsOnly, BlueprintReadOnly)\r\n\t\tFVector BaseSize;\r\n\r\n\tUPROPERTY(EditDefaultsOnly, BlueprintReadOnly)\r\n\t\tTArray<FSpecialRuleUpgrade> SpecialRuleUpgrade;\r\n\r\n};\r\n/**\r\n * \r\n */\r\nUCLASS()\r\nclass FANTASYBATTLE_API UStructLibrary : public UObject\r\n{\r\n\tGENERATED_BODY()\r\n\r\npublic:\r\n\r\n};\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Source/FantasyBattle/Public/StructLibrary.h b/Source/FantasyBattle/Public/StructLibrary.h
--- a/Source/FantasyBattle/Public/StructLibrary.h	(revision 9b08c3c30042b95af90916955e891c673f23b32c)
+++ b/Source/FantasyBattle/Public/StructLibrary.h	(date 1643222170514)
@@ -26,11 +26,17 @@
 	UPROPERTY(EditDefaultsOnly, BlueprintReadWrite)
 		float SecondaryRatio;
 
+	UPROPERTY(EditDefaultsOnly, BlueprintReadWrite)
+		int32 MinSecondaryAntal;
+
 	UPROPERTY(EditDefaultsOnly, BlueprintReadWrite)
 		int32 SecondaryPoints;
 
 	UPROPERTY(EditDefaultsOnly, BlueprintReadWrite)
 		int32 SubProfileCount;
+
+	UPROPERTY(EditDefaultsOnly, BlueprintReadWrite)
+		int32 SubMountProfileCount;
 };
 
 USTRUCT(BlueprintType)
@@ -38,7 +44,7 @@
 {
 	GENERATED_USTRUCT_BODY()
 
-		UPROPERTY(EditDefaultsOnly, BlueprintReadWrite)
+	UPROPERTY(EditDefaultsOnly, BlueprintReadWrite)
 		int32 UpgradeCost;
 
 	UPROPERTY(EditDefaultsOnly, BlueprintReadWrite)
@@ -124,7 +130,7 @@
 	GENERATED_USTRUCT_BODY()
 
 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
-		int32 UpgradeCost;
+		float UpgradeCost;
 
 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
 		FText UpgradeText;
@@ -149,7 +155,7 @@
 		TArray<EArmor> RemoveArmor;
 
 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
-		int32 UpgradeGroup;
+		TArray<int32> UpgradeGroup;
 };
 
 USTRUCT(BlueprintType)
@@ -171,6 +177,27 @@
 
 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
 		FName MountName;
+
+	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
+		int32 UpgradeGroup;
+
+	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
+		FName SubUnitName;
+
+	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
+		int32 SubUnitCount;
+
+	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
+		FName SubMountName;
+
+	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
+		int32 SubMountCount;
+
+	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
+		bool MustIncludeSubUpgrade;
+
+	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
+		bool CantIncludeSubUpgrade;
 };
 
 USTRUCT(BlueprintType)
@@ -259,6 +286,7 @@
 		MainProfileName = NewProfile->MainProfileName;
 		SecondaryProfileName = NewProfile->SecondaryProfileName;
 		SubProfileName = NewProfile->SubProfileName;
+		SubMountProfileName = NewProfile->SubMountProfileName;
 		MountProfileName = NewProfile->MountProfileName;
 		CommandUpgrades = NewProfile->CommandUpgrades;
 		SubProfileUpgrades = NewProfile->SubProfileUpgrades;
@@ -273,12 +301,15 @@
 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
 		FText ProfileName;
 
-	UPROPERTY(EditAnywhere, BlueprintReadOnly)
+	UPROPERTY(EditAnywhere, BlueprintReadWrite)
 		int32 Antal;
 
 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
 		FManstat ProfileStats;
 
+	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
+		ETroopType TroopType;
+
 	UPROPERTY(EditAnywhere, BlueprintReadOnly)
 		int32 WizardLvl;
 
@@ -303,6 +334,12 @@
 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
 		TArray<FEquipmentUpgrade> EquipmentUpgrade;
 
+	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
+		TArray<FMountUpgrade> MountUpgrade;
+
+	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
+		TArray<FSubProfileUpgrade> SubProfileUpgrades;
+
 	UPROPERTY(EditAnywhere, BlueprintReadOnly)
 		EProfilePrio Prio;
 
@@ -318,6 +355,7 @@
 		ProfileName = NewProfile->ProfileName;
 		Antal = NewProfile->Antal;
 		ProfileStats = NewProfile->ProfileStats;
+		TroopType = NewProfile->TroopType;
 		WizardLvl = NewProfile->WizardLvl;
 		WizardLores = NewProfile->WizardLores;
 		Weapons = NewProfile->Weapons;
@@ -326,15 +364,19 @@
 		BaseSize = NewProfile->BaseSize;
 		SpecialRuleUpgrade = NewProfile->SpecialRuleUpgrade;
 		EquipmentUpgrade = NewProfile->EquipmentUpgrade;
+		MountUpgrade = NewProfile->MountUpgrade;
+		SubProfileUpgrades = NewProfile->SubProfileUpgrades;
 		Prio = NewProfile->Prio;
 		ParentPrio = NewProfile->ParentPrio;
 	}
+
+	bool operator==(const FManProfile& B) const;
 };
 
 USTRUCT(BlueprintType)
 struct FMountProfile : public FTableRowBase
 {
-	GENERATED_USTRUCT_BODY()
+	GENERATED_BODY()
 
 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
 		FText ProfileName;
@@ -342,6 +384,9 @@
 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
 		FManstat ProfileStats;
 
+	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
+		ETroopType TroopType;
+
 	UPROPERTY(EditAnywhere, BlueprintReadOnly)
 		TArray<ESpecialRule> SpecialRules;
 
@@ -363,7 +408,103 @@
 	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
 		TArray<FSpecialRuleUpgrade> SpecialRuleUpgrade;
 
+	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
+		TArray<FSubProfileUpgrade> SubProfileUpgrades;
+
+	FMountProfile()
+	{
+	}
+
+	FMountProfile(FMountProfile* NewProfile)
+	{
+		ProfileName = NewProfile->ProfileName;
+		ProfileStats = NewProfile->ProfileStats;
+		TroopType = NewProfile->TroopType;
+		SpecialRules = NewProfile->SpecialRules;
+		SubProfile = NewProfile->SubProfile;
+		SubMountProfile = NewProfile->SubMountProfile;
+		SubCount = NewProfile->SubCount;
+		SubMountCount = NewProfile->SubMountCount;
+		BaseSize = NewProfile->BaseSize;
+		SpecialRuleUpgrade = NewProfile->SpecialRuleUpgrade;
+		SubProfileUpgrades = NewProfile->SubProfileUpgrades;
+
+	}
+
+	bool Equals(const FMountProfile& other) const;
+	bool operator==(const FMountProfile& other) const;
+};
+
+FORCEINLINE bool FMountProfile::Equals(const FMountProfile& other) const
+{
+	return ProfileName.ToString() == other.ProfileName.ToString();
+}
+
+FORCEINLINE bool FMountProfile::operator==(const FMountProfile& other) const
+{
+	return ProfileName.ToString() == other.ProfileName.ToString();
+}
+
+USTRUCT(BlueprintType)
+struct FSaveGameUnitProfile : public FTableRowBase
+{
+	GENERATED_BODY()
+
+public:
+
+	UPROPERTY(EditAnywhere, BlueprintReadWrite)
+		FUnitStat UnitBase;
+
+	UPROPERTY(EditAnywhere, BlueprintReadWrite)
+		TArray<FText> IncludedUpgrades;
+
+	UPROPERTY(EditAnywhere, BlueprintReadWrite)
+		TArray<FManProfile> Profiler;
+
+	FSaveGameUnitProfile()
+	{
+
+	}
+
+	FSaveGameUnitProfile(FUnitStat Base, TArray<FText> Upgrades, TArray<FManProfile> InProfiles)
+	{
+		UnitBase = Base;
+		IncludedUpgrades = Upgrades;
+		Profiler = InProfiles;
+	}
+
 };
+
+USTRUCT(BlueprintType)
+struct FArmyStat : public FTableRowBase
+{
+	GENERATED_BODY()
+
+public:
+
+	UPROPERTY(EditAnywhere, BlueprintReadWrite)
+		FString ArmyName;
+
+	UPROPERTY(EditAnywhere, BlueprintReadWrite)
+		float ArmyValue;
+
+	UPROPERTY(EditAnywhere, BlueprintReadWrite)
+		int32 ArmyTotalMax;
+
+	UPROPERTY(EditAnywhere, BlueprintReadWrite)
+		EArmies ArmyType;
+
+	UPROPERTY(EditAnywhere, BlueprintReadWrite)
+		TArray<FSaveGameUnitProfile> Units;
+
+	FArmyStat()
+	{
+		ArmyValue = 0.f;
+		ArmyTotalMax = 2000;
+		ArmyType = EArmies::E_Lizardmen;
+	}
+};
+
 /**
  * 
  */
@@ -374,4 +515,10 @@
 
 public:
 
+	UFUNCTION(BlueprintPure, meta = (DisplayName = "Profile == Profile", CompactNodeTitle = "==", ScriptMethod = "EqualsManProfile", ScriptOperator = "==", Keywords = "== Equals"), Category = "Math|ManProfile")
+		static bool Equals_Profile(const FManProfile& A, const FManProfile& B);
+
+	UFUNCTION(BlueprintPure, meta = (DisplayName = "Army == Army", CompactNodeTitle = "==", ScriptMethod = "EqualsArmy", ScriptOperator = "==", Keywords = "== Equals"), Category = "Math|Army")
+		static bool Equals_Army(const FArmyStat& A, const FArmyStat& B);
+
 };
Index: Source/FantasyBattle/Public/UI/PreGame/UI_MainMenu.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Source/FantasyBattle/Public/UI/PreGame/UI_MainMenu.h b/Source/FantasyBattle/Public/UI/PreGame/UI_MainMenu.h
new file mode 100644
--- /dev/null	(date 1643137216773)
+++ b/Source/FantasyBattle/Public/UI/PreGame/UI_MainMenu.h	(date 1643137216773)
@@ -0,0 +1,23 @@
+// Fill out your copyright notice in the Description page of Project Settings.
+
+#pragma once
+
+#include "CoreMinimal.h"
+#include "FantasyBattle_GI.h"
+#include "Blueprint/UserWidget.h"
+#include "UI_MainMenu.generated.h"
+
+/**
+ * 
+ */
+UCLASS()
+class FANTASYBATTLE_API UUI_MainMenu : public UUserWidget
+{
+	GENERATED_BODY()
+
+public:
+
+	UFUNCTION(BlueprintImplementableEvent)
+	void FoundSessions(const TArray<FFoundSessionResult>& Sessions);
+	
+};
Index: Config/DefaultEngine.ini
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>\r\n\r\n[/Script/EngineSettings.GameMapsSettings]\r\nEditorStartupMap=/Game/Blank.Blank\r\nGameDefaultMap=/Game/Blank.Blank\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Config/DefaultEngine.ini b/Config/DefaultEngine.ini
--- a/Config/DefaultEngine.ini	(revision 9b08c3c30042b95af90916955e891c673f23b32c)
+++ b/Config/DefaultEngine.ini	(date 1642886897293)
@@ -1,6 +1,55 @@
 
 
 [/Script/EngineSettings.GameMapsSettings]
-EditorStartupMap=/Game/Blank.Blank
-GameDefaultMap=/Game/Blank.Blank
+EditorStartupMap=/Game/Maps/Lobby.Lobby
+GameDefaultMap=/Game/Maps/Lobby.Lobby
+GameInstanceClass=/Game/Mode/GI_FantasyBattle_BP.GI_FantasyBattle_BP_C
+ServerDefaultMap=/Game/Maps/Lobby.Lobby
+GlobalDefaultGameMode=/Game/Mode/GM_PreGame_BP.GM_PreGame_BP_C
+GlobalDefaultServerGameMode=/Game/Mode/GM_FantasyBattle_PreGame.GM_FantasyBattle_PreGame_C
+
+[/Script/OnlineSubsystemEOS.EOSSettings]
+CacheDir=CacheDir
+DefaultArtifactName=EOSArtifact
+TickBudgetInMilliseconds=0
+bEnableOverlay=True
+bEnableSocialOverlay=True
+bShouldEnforceBeingLaunchedByEGS=False
+TitleStorageReadChunkLength=0
++Artifacts=(ArtifactName="EOSArtifact",ClientId="xyza7891ZU3H6mZ6EnLi2aK16bWukyf3",ClientSecret="qx6HjgWh6dAJH83/c9Ts9VGDrgVXL+OcHstdsG7CRjM",ProductId="8799a108a1684f7f813c498c4f099fdc",SandboxId="f798a563ba2546aea0e06f76104c0de0",DeploymentId="f480da2acefc43eeb9cdf1a30e98b82b",EncryptionKey="1111111111111111111111111111111111111111111111111111111111111111")
+bUseEAS=True
+bUseEOSConnect=True
+bMirrorStatsToEOS=False
+bMirrorAchievementsToEOS=False
+bUseEOSSessions=True
+bMirrorPresenceToEAS=True
+
+[OnlineSubsystemEOS]
+bEnabled=true
+;[OnlineSubsystemEOSPlus]
+;bEnabled=true
+;[OnlineSubsystemSteam]
+;bEnabled=true
+;SteamDevAppId=480
+;bInitServerOnClient=true
+
+[OnlineSubsystem]
+DefaultPlatformService=EOS
+PresenceAdvertises=Session
+;NativePlatformService=EOS
+;NativePlatformService=Steam
+
+[/Script/Engine.GameEngine]
++NetDriverDefinitions=(DefName="GameNetDriver",DriverClassName="OnlineSubsystemEOS.NetDriverEOS",DriverClassNameFallback="OnlineSubsystemUtils.IpNetDriver")
+;+NetDriverDefinitions=(DefName="GameNetDriver",DriverClassName="OnlineSubsystemSteam.SteamNetDriver",DriverClassNameFallback="OnlineSubsystemUtils.IpNetDriver")
+
+[/Script/OnlineSubsystemEOS.NetDriverEOS]
+bIsUsingP2PSockets=true
+
+[/Script/OnlineSubsystemUtils.OnlineEngineInterfaceImpl]
++CompatibleUniqueNetIdTypes=EOS
+;+CompatibleUniqueNetIdTypes=EOSPlus
+
+;[/Script/OnlineSubsystemSteam.SteamNetDriver]
+;etConnectionClassName="OnlineSubsystemSteam.SteamNetConnection"
 
Index: Source/FantasyBattle/Public/Mode/PS_PreGame.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Source/FantasyBattle/Public/Mode/PS_PreGame.h b/Source/FantasyBattle/Public/Mode/PS_PreGame.h
new file mode 100644
--- /dev/null	(date 1642712264000)
+++ b/Source/FantasyBattle/Public/Mode/PS_PreGame.h	(date 1642712264000)
@@ -0,0 +1,40 @@
+// Fill out your copyright notice in the Description page of Project Settings.
+
+#pragma once
+
+#include "CoreMinimal.h"
+#include "StructLibrary.h"
+#include "GameFramework/PlayerState.h"
+#include "PS_PreGame.generated.h"
+
+/**
+ * 
+ */
+UCLASS()
+class FANTASYBATTLE_API APS_PreGame : public APlayerState
+{
+	GENERATED_BODY()
+
+public:
+	UFUNCTION()
+	void SetIsReady(bool NewValue);
+
+	UFUNCTION(BlueprintPure)
+	FORCEINLINE bool GetIsReady() const {return bIsReady;}
+
+	UFUNCTION()
+	void SetArmy(FArmyStat NewArmy);
+
+	UFUNCTION(BlueprintPure)
+	FORCEINLINE FArmyStat GetArmy() {return SelectedArmy;}
+	
+private:
+	
+	UPROPERTY(Replicated)
+	bool bIsReady;
+
+	UPROPERTY(Replicated)
+	FArmyStat SelectedArmy;
+
+	virtual void GetLifetimeReplicatedProps(TArray< FLifetimeProperty > & OutLifetimeProps) const override;
+};
Index: Source/FantasyBattle/Private/UI_CreationMainMenu.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// Fill out your copyright notice in the Description page of Project Settings.\r\n\r\n\r\n#include \"UI_CreationMainMenu.h\"\r\n#include \"Enumlibrary.h\"\r\n#include \"Components/ScrollBox.h\"\r\n#include \"Engine/DataTable.h\"\r\n#include \"UI_ArmyUnit.h\"\r\n\r\nbool UUI_CreationMainMenu::Initialize()\r\n{\r\n\tbool result = Super::Initialize();\r\n\tif (!result)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tFString ContextString;\r\n\r\n\tif (UnitStatTable && BuildUnitClass)\r\n\t{\r\n\t\tTArray<FName> UnitNames = UnitStatTable->GetRowNames();\r\n\t\tfor (FName Unit : UnitNames)\r\n\t\t{\r\n\t\t\tFUnitStat TempUnit = UnitStatTable->FindRow<FUnitStat>(Unit, ContextString);\r\n\r\n\t\t\tUUserWidget* tempunit = CreateWidget<UUserWidget>(this, BuildUnitClass);\r\n\t\t\t//tempunit->Setup(TempUnit, GetRarityColor(TempUnit.Rarity));\r\n\t\t\t//tempunit->OnClicked.AddDynamic(this, &UUI_CreateMenu::OnBuildUnitButtonClick);\r\n\t\t\tBuildUnitPanel_Scroll->AddChild(tempunit);\r\n\t\t\tOnCreationUnitCreated(tempunit, TempUnit, GetRarityColor(TempUnit.Rarity));\r\n\t\t}\r\n\t}\r\n\treturn false;\r\n}\r\n\r\nvoid UUI_CreationMainMenu::CreateArmyUnit(const FUnitStat UnitStats)\r\n{\r\n\tif (!ensure(ManStatTable)) return;\r\n\r\n\tUUI_ArmyUnit* tempunit = CreateWidget<UUI_ArmyUnit>(this, ArmyUnitClass);\r\n\tif (tempunit == nullptr) return;\r\n\r\n\ttempunit->UnitProfil = UnitStats;\r\n\r\n\tFManProfile MainProfile = ManStatTable->FindRow<FManProfile>(UnitStats.MainProfileName, FString(\"\"));\r\n\tMainProfile.Prio = EProfilePrio::E_Main;\r\n\tMainProfile.ParentPrio = EProfilePrio::E_Unit;\r\n\tMainProfile.Antal = UnitStats.ConstructionsValues.MinAntal;\r\n\ttempunit->AddProfile(EProfilePrio::E_Main, MainProfile);\r\n\r\n\tif (!UnitStats.SecondaryProfileName.IsNone())\r\n\t{\r\n\t\tFManProfile secondaryprofile = ManStatTable->FindRow<FManProfile>(UnitStats.SecondaryProfileName, FString(\"\"));\r\n\t\tif (!secondaryprofile.ProfileName.IsEmpty())\r\n\t\t{\r\n\t\t\tsecondaryprofile.Prio = EProfilePrio::E_Secondary;\r\n\t\t\tsecondaryprofile.ParentPrio = EProfilePrio::E_Unit;\r\n\t\t\ttempunit->AddProfile(EProfilePrio::E_Secondary, secondaryprofile);\r\n\t\t}\r\n\t}\r\n\tif (!UnitStats.MountProfileName.IsNone())\r\n\t{\r\n\t\tFManProfile MountProfile = ManStatTable->FindRow<FManProfile>(UnitStats.MountProfileName, FString(\"\"));\r\n\t\tif (!MountProfile.ProfileName.IsEmpty())\r\n\t\t{\r\n\t\t\tMountProfile.Prio = EProfilePrio::E_Mount;\r\n\t\t\tMountProfile.ParentPrio = EProfilePrio::E_Main;\r\n\t\t\ttempunit->AddProfile(EProfilePrio::E_Mount, MountProfile);\r\n\t\t}\r\n\t}\r\n\tif (!UnitStats.SubProfileName.IsNone())\r\n\t{\r\n\t\tFManProfile SubProfile = ManStatTable->FindRow<FManProfile>(UnitStats.SubProfileName, FString(\"\"));\r\n\t\tif (!SubProfile.ProfileName.IsEmpty())\r\n\t\t{\r\n\t\t\tSubProfile.Prio = EProfilePrio::E_Sub;\r\n\t\t\tSubProfile.ParentPrio = EProfilePrio::E_Main;\r\n\t\t\tSubProfile.Antal = UnitStats.ConstructionsValues.SubProfileCount;\r\n\t\t\ttempunit->AddProfile(EProfilePrio::E_Sub, SubProfile);\r\n\t\t}\r\n\t}\r\n\tArmyIncluded_Scroll->AddChild(tempunit);\r\n\ttempunit->ProfilesLoaded();\r\n\tOnArmyUnitCreated(tempunit);\r\n}\r\n\r\nFLinearColor UUI_CreationMainMenu::GetRarityColor(const EUnitRarity UnitRarity)\r\n{\r\n\tswitch (UnitRarity)\r\n\t{\r\n\tcase EUnitRarity::E_Lord:\r\n\t\treturn RarityColor.LordColor;\r\n\tcase EUnitRarity::E_Hero:\r\n\t\treturn RarityColor.HeroColor;\r\n\tcase EUnitRarity::E_Core:\r\n\t\treturn RarityColor.CoreColor;\r\n\tcase EUnitRarity::E_Special:\r\n\t\treturn RarityColor.SpecialColor;\r\n\tcase EUnitRarity::E_Rare:\r\n\t\treturn RarityColor.RareColor;\r\n\tdefault:\r\n\t\treturn FLinearColor::White;\r\n\t\tbreak;\r\n\t}\r\n}\r\n\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Source/FantasyBattle/Private/UI_CreationMainMenu.cpp b/Source/FantasyBattle/Private/UI_CreationMainMenu.cpp
--- a/Source/FantasyBattle/Private/UI_CreationMainMenu.cpp	(revision 9b08c3c30042b95af90916955e891c673f23b32c)
+++ b/Source/FantasyBattle/Private/UI_CreationMainMenu.cpp	(date 1641633312000)
@@ -40,6 +40,7 @@
 	UUI_ArmyUnit* tempunit = CreateWidget<UUI_ArmyUnit>(this, ArmyUnitClass);
 	if (tempunit == nullptr) return;
 
+	OnArmyUnitCreated(tempunit);
 	tempunit->UnitProfil = UnitStats;
 
 	FManProfile MainProfile = ManStatTable->FindRow<FManProfile>(UnitStats.MainProfileName, FString(""));
@@ -60,7 +61,7 @@
 	}
 	if (!UnitStats.MountProfileName.IsNone())
 	{
-		FManProfile MountProfile = ManStatTable->FindRow<FManProfile>(UnitStats.MountProfileName, FString(""));
+		FManProfile MountProfile = MountStatTable->FindRow<FManProfile>(UnitStats.MountProfileName, FString(""));
 		if (!MountProfile.ProfileName.IsEmpty())
 		{
 			MountProfile.Prio = EProfilePrio::E_Mount;
@@ -80,8 +81,31 @@
 		}
 	}
 	ArmyIncluded_Scroll->AddChild(tempunit);
+
 	tempunit->ProfilesLoaded();
-	OnArmyUnitCreated(tempunit);
+
+}
+
+void UUI_CreationMainMenu::LoadArmy(const FArmyStat Army)
+{
+	if (!ensure(ManStatTable)) return;
+
+	for (FSaveGameUnitProfile unit : Army.Units)
+	{
+		UUI_ArmyUnit* tempunit = CreateWidget<UUI_ArmyUnit>(this, ArmyUnitClass);
+		if (tempunit == nullptr) return;
+
+		OnArmyUnitCreated(tempunit);
+		tempunit->UnitProfil = unit.UnitBase;
+
+		for (FManProfile Profile : unit.Profiler)
+		{
+			tempunit->AddProfile(Profile.Prio, Profile);
+		}
+		ArmyIncluded_Scroll->AddChild(tempunit);
+
+		tempunit->ProfilesLoadedFromSave(unit.IncludedUpgrades);
+	}
 }
 
 FLinearColor UUI_CreationMainMenu::GetRarityColor(const EUnitRarity UnitRarity)
Index: Source/SpecialRules/Public/SpecialRulesLibrary.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// Fill out your copyright notice in the Description page of Project Settings.\r\n\r\n#pragma once\r\n\r\n#include \"CoreMinimal.h\"\r\n#include \"Kismet/BlueprintFunctionLibrary.h\"\r\n#include \"SpecialRulesLibrary.generated.h\"\r\n\r\nUENUM(BlueprintType)\r\nenum class ESpecialRule : uint8\r\n{\r\n\tE_None UMETA(DisplayName = \"None\"),\r\n\tE_Sharpenedhorns UMETA(DisplayName = \"Sharpened Horns\"),\r\n\tE_Unstoppablestampede UMETA(DisplayName = \"Unstoppable Stampede\"),\r\n\tE_Alwaysstrikefirst UMETA(DisplayName = \"Always Strike First\"),\r\n\tE_Alwaysstrikelast UMETA(DisplayName = \"Always Strike Last\"),\r\n\tE_Armorpiercing UMETA(DisplayName = \"Armor Piercing\"),\r\n\tE_Breathweapons UMETA(DisplayName = \"Breath Weapons\"),\r\n\tE_Devastatingcharge UMETA(DisplayName = \"Devastating Charge\"),\r\n\tE_Ethereal UMETA(DisplayName = \"Ethereal\"),\r\n\tE_Extraattck UMETA(DisplayName = \"Extra Attack\"),\r\n\tE_Fastcavalry UMETA(DisplayName = \"Fast Cavalry\"),\r\n\tE_Fear UMETA(DisplayName = \"Fear\"),\r\n\tE_Fightinextraranks UMETA(DisplayName = \"Fight in Extra Ranks\"),\r\n\tE_Flamingattacks UMETA(DisplayName = \"Flaming Attacks\"),\r\n\tE_Flammable UMETA(DisplayName = \"Flammable\"),\r\n\tE_Frenzy UMETA(DisplayName = \"Frenzy\"),\r\n\tE_Fly UMETA(DisplayName = \"Fly\"),\r\n\tE_Hatred UMETA(DisplayName = \"Hatred\"),\r\n\tE_Hover UMETA(DisplayName = \"Hover\"),\r\n\tE_Immunepsychology UMETA(DisplayName = \"Immune to Psychology\"),\r\n\tE_Ignorecover UMETA(DisplayName = \"Ignore Cover\"),\r\n\tE_Impacthits UMETA(DisplayName = \"Impact Hits\"),\r\n\tE_Killingblow UMETA(DisplayName = \"Killing Blow\"),\r\n\tE_Heroickillingblow UMETA(DisplayName = \"Heroic Killing Blow\"),\r\n\tE_Largetarget UMETA(DisplayName = \"Large Target\"),\r\n\tE_Loremaster UMETA(DisplayName = \"Loremaster\"),\r\n\tE_Magicresistance UMETA(DisplayName = \"Magic Resistance\"),\r\n\tE_Monsterandhandlers UMETA(DisplayName = \"Monster and Handlers\"),\r\n\tE_Moveorfire UMETA(DisplayName = \"Move or Fire\"),\r\n\tE_Multipleshots UMETA(DisplayName = \"Multiple Shots\"),\r\n\tE_MultipleWounds UMETA(DisplayName = \"Multiple Wounds\"),\r\n\tE_Poisonedattacks UMETA(DisplayName = \"Poisoned Attacks\"),\r\n\tE_Quicktofire UMETA(DisplayName = \"Quick to Fire\"),\r\n\tE_Randomattacks UMETA(DisplayName = \"Random Attacks\"),\r\n\tE_Randommovement UMETA(DisplayName = \"Random Movement\"),\r\n\tE_Regeneration UMETA(DisplayName = \"Regeneration\"),\r\n\tE_Requirestwohands UMETA(DisplayName = \"Requires two Hands\"),\r\n\tE_Scalyskin UMETA(DisplayName = \"Scaly Skin\"),\r\n\tE_Seacreature UMETA(DisplayName = \"Sea Creature\"),\r\n\tE_Slowtofire UMETA(DisplayName = \"Slow to Fire\"),\r\n\tE_Sniper UMETA(DisplayName = \"Sniper\"),\r\n\tE_Stomp UMETA(DisplayName = \"Stomp\"),\r\n\tE_Strider UMETA(DisplayName = \"Strider\"),\r\n\tE_Stubborn UMETA(DisplayName = \"Stubborn\"),\r\n\tE_Stupidity UMETA(DisplayName = \"Stupidity\"),\r\n\tE_Swiftstride UMETA(DisplayName = \"Swiftstride\"),\r\n\tE_Skirmishers UMETA(DisplayName = \"Skirmishers\"),\r\n\tE_Terror UMETA(DisplayName = \"Terror\"),\r\n\tE_Unbreakable UMETA(DisplayName = \"Unbreakable\"),\r\n\tE_Unstable UMETA(DisplayName = \"Unstable\"),\r\n\tE_Volleyfire UMETA(DisplayName = \"Volley Fire\"),\r\n\tE_Ambushers UMETA(DisplayName = \"Ambushers\"),\r\n\tE_Scouts UMETA(DisplayName = \"Scouts\"),\r\n\tE_Vanguard UMETA(DisplayName = \"Vanguard\"),\r\n\tE_Coldblooded UMETA(DisplayName = \"Cold-Blooded\"),\r\n\tE_Predatoryfighter UMETA(DisplayName = \"Predatory Fighter\"),\r\n\tE_Aquatic UMETA(DisplayName = \"Aquatic\"),\r\n\tE_Spawnkin UMETA(DisplayName = \"Spawn-kin\"),\r\n\tE_Guardians UMETA(DisplayName = \"Guardians\"),\r\n\tE_Sacredduty UMETA(DisplayName = \"Sacred Duty\"),\r\n\tE_Theyareeverywhere UMETA(DisplayName = \"They're Everywhere!\"),\r\n\tE_Chameleon UMETA(DisplayName = \"Chameleon\"),\r\n\tE_Thickskinned UMETA(DisplayName = \"Thick-skinned\")\r\n\r\n};\r\n/**\r\n * \r\n */\r\nUCLASS()\r\nclass SPECIALRULES_API USpecialRulesLibrary : public UBlueprintFunctionLibrary\r\n{\r\n\tGENERATED_BODY()\r\n\t\r\n};\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Source/SpecialRules/Public/SpecialRulesLibrary.h b/Source/SpecialRules/Public/SpecialRulesLibrary.h
--- a/Source/SpecialRules/Public/SpecialRulesLibrary.h	(revision 9b08c3c30042b95af90916955e891c673f23b32c)
+++ b/Source/SpecialRules/Public/SpecialRulesLibrary.h	(date 1641633312000)
@@ -71,8 +71,9 @@
 	E_Sacredduty UMETA(DisplayName = "Sacred Duty"),
 	E_Theyareeverywhere UMETA(DisplayName = "They're Everywhere!"),
 	E_Chameleon UMETA(DisplayName = "Chameleon"),
-	E_Thickskinned UMETA(DisplayName = "Thick-skinned")
-
+	E_Thickskinned UMETA(DisplayName = "Thick-skinned"),
+	E_Loopingstride UMETA(DisplayName = "Looping Stride"),
+	E_Bloodroar UMETA(DisplayName = "Bloodroar")
 };
 /**
  * 
Index: Source/FantasyBattle/Private/FantasyBattle_GI.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Source/FantasyBattle/Private/FantasyBattle_GI.cpp b/Source/FantasyBattle/Private/FantasyBattle_GI.cpp
new file mode 100644
--- /dev/null	(date 1643307004910)
+++ b/Source/FantasyBattle/Private/FantasyBattle_GI.cpp	(date 1643307004910)
@@ -0,0 +1,515 @@
+// Fill out your copyright notice in the Description page of Project Settings.
+
+#include "FantasyBattle_GI.h"
+//#include "..\Public\FantasyBattle_GI.h"
+//#include "Interfaces/OnlineSessionInterface.h"
+#include "ArmySaveGame.h"
+#include "Interfaces/OnlineIdentityInterface.h"
+#include "Interfaces/OnlineFriendsInterface.h"
+#include "Interfaces/OnlineExternalUIInterface.h"
+#include "OnlineSubsystem.h"
+#include "Blueprint/UserWidget.h"
+#include "Blueprint/WidgetLayoutLibrary.h"
+#include "GameFramework/PlayerState.h"
+#include "Kismet/GameplayStatics.h"
+#include "Mode/GM_PreGame.h"
+#include "UI/Lobbby/UI_LobbyMenu.h"
+#include "UI/PreGame/UI_MainMenu.h"
+
+
+const FName MySessionName = FName("Test Session");
+
+UFantasyBattle_GI::UFantasyBattle_GI()
+{
+	bIsLoggedIn = false;
+	bInSession = false;
+}
+
+void UFantasyBattle_GI::Init()
+{
+	Super::Init();
+
+	OnlineSubsystem = IOnlineSubsystem::Get();
+
+	IOnlineSessionPtr SessionPtr = OnlineSubsystem->GetSessionInterface();
+	SessionPtr->OnSessionUserInviteAcceptedDelegates.AddUObject(this, &UFantasyBattle_GI::OnInvitationAccepted);
+
+	InitSaveGameList();
+	//Login();
+	
+}
+
+UUI_LobbyMenu* UFantasyBattle_GI::ShowLobbyMenu()
+{
+	UWidgetLayoutLibrary::RemoveAllWidgets(this);
+	if (LobbyMenu)
+	{
+		LobbyMenu->AddToViewport();
+		return  LobbyMenu;
+	}
+	else
+	{
+		if (!ensureAlways(LobbyMenuClass)) return nullptr;
+		LobbyMenu = CreateWidget<UUI_LobbyMenu>(this, LobbyMenuClass);
+		if (LobbyMenu)
+		{
+			//MainMenu->SetMenuInterface(this);
+			LobbyMenu->AddToViewport();
+			return  LobbyMenu;
+		}
+	
+	}
+	return nullptr;
+}
+
+void UFantasyBattle_GI::ShowMainMenu()
+{
+	if (MainMenu)
+	{
+		UE_LOG(LogTemp, Warning, TEXT("Main Menu added to Viewport"));
+		MainMenu->AddToViewport();
+	}
+	else
+	{
+		if (!ensureAlways(MainMenuClass)) return;
+		MainMenu = CreateWidget<UUI_MainMenu>(this, MainMenuClass);
+		if (MainMenu)
+		{
+			UE_LOG(LogTemp, Warning, TEXT("Main Menu added to Viewport"));
+			MainMenu->AddToViewport();
+		}
+		
+	}
+}
+
+void UFantasyBattle_GI::ShowCreateMenu()
+{
+	UWidgetLayoutLibrary::RemoveAllWidgets(this);
+	if (CreateMenu)
+	{
+		UE_LOG(LogTemp, Warning, TEXT("Create Menu added to Viewport"));
+		CreateMenu->AddToViewport();
+	}
+	else
+	{
+		if (!ensureAlways(CreateArmyMenuClass)) return;
+		CreateMenu = CreateWidget<UUserWidget>(this, CreateArmyMenuClass);
+		if (CreateMenu)
+		{
+			UE_LOG(LogTemp, Warning, TEXT("Create Menu added to Viewport"));
+			CreateMenu->AddToViewport();
+		}
+		
+	}
+}
+
+FString UFantasyBattle_GI::FindUserInfo(const FUniqueNetIdRef PlayerID)
+{
+	IOnlineIdentityPtr IdentityPtr = OnlineSubsystem->GetIdentityInterface();
+	FString UserName = IdentityPtr->GetPlayerNickname(PlayerID.Get());
+	return UserName;
+}
+
+void UFantasyBattle_GI::Login(FString UserName)
+{
+	if(OnlineSubsystem)
+	{
+		if(IOnlineIdentityPtr Identity = OnlineSubsystem->GetIdentityInterface())
+		{
+			FOnlineAccountCredentials Credentials;
+			Credentials.Id = FString("127.0.0.1:6300");
+			Credentials.Token = UserName;
+			Credentials.Type = FString("developer");
+			
+			Identity->OnLoginCompleteDelegates->AddUObject(this, &UFantasyBattle_GI::OnLoginComplete);
+			Identity->Login(0, Credentials);
+		}
+	}
+}
+
+void UFantasyBattle_GI::OnLoginComplete(int32 LocalUserNum, bool bWasSuccessful, const FUniqueNetId& UserId, const FString& Error)
+{
+	UE_LOG(LogTemp, Warning, TEXT("LoggedIn: %d"), bWasSuccessful);
+	bIsLoggedIn = bWasSuccessful;
+	
+	if (OnlineSubsystem)
+	{
+		if(IOnlineIdentityPtr Identity = OnlineSubsystem->GetIdentityInterface())
+		{			
+			Identity->ClearOnLoginCompleteDelegates(0, this);
+			TSharedPtr<FUserOnlineAccount> User = Identity->GetUserAccount(UserId);
+			UE_LOG(LogTemp, Warning, TEXT("Did we get the right UserName: %s"), *User->GetDisplayName());
+			APlayerController* PC = GetFirstLocalPlayerController();
+			PC->PlayerState->SetPlayerName(User->GetDisplayName());
+		}
+
+	}
+}
+
+void UFantasyBattle_GI::CreateSession()
+{
+	if (bIsLoggedIn)
+	{
+		if (OnlineSubsystem)
+		{
+			if (IOnlineSessionPtr SessionPtr = OnlineSubsystem->GetSessionInterface())
+			{
+				FOnlineSessionSettings SessionSettings;
+				SessionSettings.bIsDedicated = false;
+				SessionSettings.bShouldAdvertise = true;
+				SessionSettings.bIsLANMatch = false;
+				SessionSettings.NumPublicConnections = 3;
+				SessionSettings.bAllowJoinInProgress = true;
+				SessionSettings.bAllowJoinViaPresence = true;
+				SessionSettings.bUsesPresence = true;
+				SessionSettings.bUseLobbiesIfAvailable = false;
+				SessionSettings.Set(FName("ServerName"), FString("FantasyBattleLobby"), EOnlineDataAdvertisementType::ViaOnlineService);
+				//SessionSettings.Set(SEARCH_PRESENCE, true, EOnlineDataAdvertisementType::ViaOnlineService);
+				
+				SessionPtr->OnCreateSessionCompleteDelegates.AddUObject(this, &UFantasyBattle_GI::OnCreateSessionComplete);
+				SessionPtr->CreateSession(0, MySessionName, SessionSettings);
+			}
+
+		}
+	}
+	else
+	{
+		UE_LOG(LogTemp, Warning, TEXT("CANNOT CREATE SESSION, NOT LOGGED IN"));
+	}
+}
+
+void UFantasyBattle_GI::CreateSession_Server()
+{
+	UE_LOG(LogTemp, Warning, TEXT("Creating Session Server called"));
+	if (OnlineSubsystem)
+	{
+		UE_LOG(LogTemp, Warning, TEXT("Creating Session Server Subsystem is valid"));
+		if (IOnlineSessionPtr SessionPtr = OnlineSubsystem->GetSessionInterface())
+		{
+			UE_LOG(LogTemp, Warning, TEXT("Creating Session Server Found Session interface"));
+			FOnlineSessionSettings SessionSettings;
+			SessionSettings.bIsDedicated = true;
+			SessionSettings.bShouldAdvertise = true;
+			SessionSettings.bIsLANMatch = false;
+			SessionSettings.NumPublicConnections = 3;
+			SessionSettings.bAllowJoinInProgress = true;
+			SessionSettings.bAllowJoinViaPresence = true;
+			SessionSettings.bUsesPresence = false;
+			SessionSettings.bUseLobbiesIfAvailable = false;
+			SessionSettings.Set(FName("ServerName"), FString("FantasyBattleLobby"), EOnlineDataAdvertisementType::ViaOnlineService);
+			//SessionSettings.Set(SEARCH_PRESENCE, true, EOnlineDataAdvertisementType::ViaOnlineService);
+				
+			SessionPtr->OnCreateSessionCompleteDelegates.AddUObject(this, &UFantasyBattle_GI::OnCreateSessionComplete);
+			SessionPtr->CreateSession(0, MySessionName, SessionSettings);
+			UE_LOG(LogTemp, Warning, TEXT("Creating Session Running waiting for callback"));
+		}
+
+	}
+}
+
+void UFantasyBattle_GI::OnCreateSessionComplete(FName SessionName, bool bWasSuccessful)
+{
+	UE_LOG(LogTemp, Warning, TEXT("Session Created: %d"), bWasSuccessful);
+
+	if (OnlineSubsystem)
+	{
+		if (IOnlineSessionPtr SessionPtr = OnlineSubsystem->GetSessionInterface())
+		{
+			SessionPtr->ClearOnCreateSessionCompleteDelegates(this);
+			bInSession = true;
+			AGM_PreGame* GM = Cast<AGM_PreGame>(GetWorld()->GetAuthGameMode());
+			GM->SessionCreated(SessionName, bWasSuccessful);
+			//OnSessionCreated.(SessionName, bWasSuccessful);
+			//GetWorld()->ServerTravel("/Game/Maps/Lobby?listen");
+			if (EnableListenServer(true))
+				UE_LOG(LogTemp, Warning, TEXT("Enabled Listen Server"));
+		}
+
+	}
+}
+
+void UFantasyBattle_GI::FindSessions()
+{
+	if (bIsLoggedIn)
+	{
+		if (OnlineSubsystem)
+		{
+			if (IOnlineSessionPtr SessionPtr = OnlineSubsystem->GetSessionInterface())
+			{
+				TSharedRef<FOnlineSessionSearch> const Search = MakeShared<FOnlineSessionSearch>();
+				// Remove the default search parameters that FOnlineSessionSearch sets up.
+				Search->QuerySettings.SearchParams.Empty();
+
+				Search->bIsLanQuery = false;
+				Search->MaxSearchResults = 200;	
+				// Add your search settings here. You must specify at least one filter, or EOS will not run the search.
+				Search->QuerySettings.Set(FName("ServerName"), FString("FantasyBattleLobby"), EOnlineComparisonOp::Equals);
+				//Search->QuerySettings.Set(SEARCH_PRESENCE, true, EOnlineComparisonOp::Equals);
+				FindSessionsDelegateHandle = SessionPtr->AddOnFindSessionsCompleteDelegate_Handle(FOnFindSessionsComplete::FDelegate::CreateUObject(this, &UFantasyBattle_GI::HandleFindSessionsComplete, Search));
+				
+				if (!SessionPtr->FindSessions(0, Search))
+				{
+					UE_LOG(LogTemp, Warning, TEXT("Search didn't Start"));
+				}
+			}
+		}
+	}
+}
+
+void UFantasyBattle_GI::FindFriendsSessions(const FUniqueNetId& UserID)
+{
+	if (bIsLoggedIn)
+	{
+		if (OnlineSubsystem)
+		{
+			if (IOnlineSessionPtr SessionPtr = OnlineSubsystem->GetSessionInterface())
+			{
+				TSharedRef<FOnlineSessionSearch> Search = MakeShared<FOnlineSessionSearch>();
+				// Remove the default search parameters that FOnlineSessionSearch sets up.
+				Search->QuerySettings.SearchParams.Empty();
+
+				Search->bIsLanQuery = false;
+				Search->MaxSearchResults = 200;
+				// Add your search settings here. You must specify at least one filter, or EOS will not run the search.
+				Search->QuerySettings.Set(FName("ServerName"), FString("FantasyBattleLobby"), EOnlineComparisonOp::Equals);
+				//Search->QuerySettings.Set(SEARCH_PRESENCE, true, EOnlineComparisonOp::Equals);
+				FindSessionsDelegateHandle = SessionPtr->AddOnFindSessionsCompleteDelegate_Handle(FOnFindSessionsComplete::FDelegate::CreateUObject(this, &UFantasyBattle_GI::HandleFindSessionsComplete, Search));
+
+				if (!SessionPtr->FindFriendSession(UserID, FriendsIDs))
+				{
+					UE_LOG(LogTemp, Warning, TEXT("Search didn't Start"));
+				}
+			}
+		}
+	}
+}
+
+void UFantasyBattle_GI::HandleFindSessionsComplete(bool bWasSuccessful, TSharedRef<FOnlineSessionSearch> Search)
+{
+	IOnlineSessionPtr SessionPtr = OnlineSubsystem->GetSessionInterface();
+	FString temp;
+	Search->QuerySettings.Get("ServerName", temp);
+	UE_LOG(LogTemp, Warning, TEXT("Keyword %s"), *temp);
+	if (bWasSuccessful)
+	{
+		UE_LOG(LogTemp, Warning, TEXT("We found %d sessions"), Search->SearchResults.Num());
+		for (auto RawResult : Search->SearchResults)
+		{
+			//UE_LOG(LogTemp, Warning, TEXT("Session owner id: %s. and Name: %s"), *RawResult.Session.OwningUserId->ToString(), *RawResult.Session.OwningUserName);
+			if (RawResult.IsValid() || RawResult.IsSessionInfoValid())
+			{
+				UE_LOG(LogTemp, Warning, TEXT("Public: %d - Private: %d"), RawResult.Session.NumOpenPublicConnections, RawResult.Session.NumOpenPrivateConnections);
+				UE_LOG(LogTemp, Warning, TEXT("Session Search Result is validated"));
+				FString ConnectInfo;
+				if (SessionPtr->GetResolvedConnectString(RawResult, NAME_GamePort, ConnectInfo))
+				{
+					Sessions.Add(FFoundSessionResult(RawResult, ConnectInfo));
+					//OnSessionFound.Broadcast(Sessions[Sessions.Num() - 1]);
+					//JoinSelectedSession(Sessions[Sessions.Num() - 1]);
+					UE_LOG(LogTemp, Warning, TEXT("Server connection info: %s"), *ConnectInfo);
+					break;
+				}
+			}
+		}
+		if (MainMenu)
+		{
+			MainMenu->FoundSessions(Sessions);
+		}
+	}
+
+	SessionPtr->ClearOnFindSessionsCompleteDelegate_Handle(this->FindSessionsDelegateHandle);
+	FindSessionsDelegateHandle.Reset();
+}
+
+void UFantasyBattle_GI::JoinSelectedSession(FFoundSessionResult Session)
+{
+	IOnlineSessionPtr SessionPtr = OnlineSubsystem->GetSessionInterface();
+
+	JoinSessionDelegateHandle = SessionPtr->AddOnJoinSessionCompleteDelegate_Handle(FOnJoinSessionComplete::FDelegate::CreateUObject(
+			this,
+			&UFantasyBattle_GI::HandleJoinSessionComplete,
+			Session.ConnectInfo));
+	//MainMenu->RemoveFromViewport();
+	if (!SessionPtr->JoinSession(0, FName(MySessionName), Session.SessionData))
+	{
+		UE_LOG(LogTemp, Warning, TEXT("join didn't Start"));
+	}
+}
+
+void UFantasyBattle_GI::HandleJoinSessionComplete(FName SessionName, EOnJoinSessionCompleteResult::Type JoinResult, FString ConnectInfo)
+{
+	if (JoinResult == EOnJoinSessionCompleteResult::Success ||
+		JoinResult == EOnJoinSessionCompleteResult::AlreadyInSession)
+	{
+		UE_LOG(LogTemp, Warning, TEXT("Join Succeded we just gotta travel there"));
+		UE_LOG(LogTemp, Warning, TEXT("open %s"), *ConnectInfo);
+
+		//TravelToSession(ConnectInfo);
+		bInSession = true;
+		GetWorld()->GetFirstPlayerController()->ClientTravel(ConnectInfo, ETravelType::TRAVEL_Absolute);
+	}
+	else
+	{
+		UE_LOG(LogTemp, Warning, TEXT("Join Failed"));
+	}
+
+	IOnlineSessionPtr Session = OnlineSubsystem->GetSessionInterface();
+
+	Session->ClearOnJoinSessionCompleteDelegate_Handle(this->JoinSessionDelegateHandle);
+	JoinSessionDelegateHandle.Reset();
+}
+
+void UFantasyBattle_GI::DestroySession()
+{
+	if (bIsLoggedIn)
+	{
+		if (OnlineSubsystem)
+		{
+			if (IOnlineSessionPtr SessionPtr = OnlineSubsystem->GetSessionInterface())
+			{
+				SessionPtr->OnDestroySessionCompleteDelegates.AddUObject(this, &UFantasyBattle_GI::OnDestroySessionComplete);
+				SessionPtr->DestroySession(MySessionName);
+			}
+		}
+	}
+}
+
+void UFantasyBattle_GI::OnDestroySessionComplete(FName SessionName, bool bWasSuccessful)
+{
+	if (bIsLoggedIn)
+	{
+		if (OnlineSubsystem)
+		{
+			if (IOnlineSessionPtr SessionPtr = OnlineSubsystem->GetSessionInterface())
+			{
+				if (SessionPtr->OnDestroySessionCompleteDelegates.IsBound())
+					SessionPtr->ClearOnDestroySessionCompleteDelegates(this);
+			}
+		}
+	}
+}
+
+void UFantasyBattle_GI::GetAllFriends()
+{
+	if (bIsLoggedIn)
+	{
+		if (OnlineSubsystem)
+		{
+			IOnlineFriendsPtr FriendsPtr = OnlineSubsystem->GetFriendsInterface();
+
+			FriendsPtr->ReadFriendsList(0, FString(""), FOnReadFriendsListComplete::CreateUObject(this, &UFantasyBattle_GI::OnGetFriendsListComplete));
+		}
+	}
+}
+
+void UFantasyBattle_GI::ShowFriendsUI()
+{
+	if (bIsLoggedIn)
+	{
+		if (OnlineSubsystem)
+		{
+			IOnlineExternalUIPtr UIPtr = OnlineSubsystem->GetExternalUIInterface();
+			if (UIPtr)
+			{
+				UIPtr->ShowFriendsUI(0);
+				//UIPtr->ShowInviteUI(0, MySessionName);
+			}
+		}
+	}
+}
+
+void UFantasyBattle_GI::OnGetFriendsListComplete(int32 LocalUserNum, bool bWasSuccessful, const FString& ListName, const FString& ErrorStr)
+{
+	if (bWasSuccessful)
+	{
+		UE_LOG(LogTemp, Warning, TEXT("Read Friends List Succesful"));
+		if (OnlineSubsystem)
+		{
+			if(IOnlineFriendsPtr FriendsPtr = OnlineSubsystem->GetFriendsInterface())
+			{
+				TArray<TSharedRef<FOnlineFriend>> FriendsList;
+				if (FriendsPtr->GetFriendsList(0, ListName,FriendsList))
+				{
+					for (TSharedRef<FOnlineFriend> Friend : FriendsList)
+					{
+						FString FriendName = Friend.Get().GetDisplayName();
+						UE_LOG(LogTemp, Warning, TEXT("Friend: %s"), *FriendName);
+						FriendsIDs.Add(Friend->GetUserId());
+					}
+				}
+				else
+				{
+					UE_LOG(LogTemp, Warning, TEXT("Failed getting Friendslist"));
+				}
+			}
+		}
+	}
+	else
+	{
+		UE_LOG(LogTemp, Warning, TEXT("Read Friends List Failed: %s"), *ErrorStr);
+	}
+}
+
+void UFantasyBattle_GI::OnInvitationAccepted(const bool bWasSuccessful, const int32 ControllerId,
+	FUniqueNetIdPtr UserId, const FOnlineSessionSearchResult& InviteResult)
+{
+	UE_LOG(LogTemp, Warning, TEXT("Invitation Accepted"));
+	if (InviteResult.IsValid() || InviteResult.IsSessionInfoValid())
+	{
+		IOnlineSessionPtr SessionPtr = OnlineSubsystem->GetSessionInterface();
+		UE_LOG(LogTemp, Warning, TEXT("Session Search Result is validated"));
+		FString ConnectInfo;
+		if (SessionPtr->GetResolvedConnectString(InviteResult, NAME_GamePort, ConnectInfo))
+		{
+			Sessions.Add(FFoundSessionResult(InviteResult, ConnectInfo));
+			//OnSessionFound.Broadcast(Sessions[Sessions.Num() - 1]);
+			JoinSelectedSession(Sessions[Sessions.Num() - 1]);
+			UE_LOG(LogTemp, Warning, TEXT("Server connection info: %s"), *ConnectInfo);
+		}
+	}
+}
+
+void UFantasyBattle_GI::InitSaveGameList()
+{
+	if (UGameplayStatics::DoesSaveGameExist(SaveGameListString, 0))
+	{
+		SaveGame = Cast<UArmySaveGame>(UGameplayStatics::LoadGameFromSlot(SaveGameListString, 0));
+		UE_LOG(LogTemp, Warning, TEXT("Loading"));
+	}
+	else
+	{
+		SaveGame = Cast<UArmySaveGame>(UGameplayStatics::CreateSaveGameObject(UArmySaveGame::StaticClass()));
+		UE_LOG(LogTemp, Warning, TEXT("Creating SaveList"));
+	}
+}
+
+bool UFantasyBattle_GI::AddArmyToSave(FArmyStat Army)
+{
+	if (!SaveGame)
+	{
+		InitSaveGameList();
+	}
+	return SaveGame->AddArmyToList(Army);
+}
+
+bool UFantasyBattle_GI::OverwriteArmy(FArmyStat Army, int32 Index, FString ErrorStr)
+{
+	if (!SaveGame)
+	{
+		InitSaveGameList();
+	}
+	return SaveGame->ReplaceSavedArmy(Army, Index, ErrorStr);
+}
+
+TArray<FArmyStat> UFantasyBattle_GI::GetSaveGameList()
+{
+	if (SaveGame)
+	{
+		UE_LOG(LogTemp, Warning, TEXT("Allready Exist"));
+		return SaveGame->GetSavedArmies();
+	}
+	InitSaveGameList();
+	return SaveGame->GetSavedArmies();
+}
+
+
Index: Source/FantasyBattle/Public/Mode/GS_PreGame.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Source/FantasyBattle/Public/Mode/GS_PreGame.h b/Source/FantasyBattle/Public/Mode/GS_PreGame.h
new file mode 100644
--- /dev/null	(date 1643447793649)
+++ b/Source/FantasyBattle/Public/Mode/GS_PreGame.h	(date 1643447793649)
@@ -0,0 +1,56 @@
+// Fill out your copyright notice in the Description page of Project Settings.
+
+#pragma once
+
+#include "CoreMinimal.h"
+#include "GameFramework/GameStateBase.h"
+#include "GS_PreGame.generated.h"
+
+/**
+ * 
+ */
+UCLASS()
+class FANTASYBATTLE_API AGS_PreGame : public AGameStateBase
+{
+	GENERATED_BODY()
+	
+public:
+
+	void RunReadyCheck();
+	
+	UFUNCTION(BlueprintCallable, Server, Reliable, WithValidation)
+	void SetMaxArmySize(int32 NewMax);
+
+	UFUNCTION(BlueprintPure)
+	FORCEINLINE int32 GetMaxArmySize() {return MaxArmySize;}
+
+protected:
+
+	void GameStarting();
+	
+	UPROPERTY(EditDefaultsOnly, ReplicatedUsing=OnRep_TimeToGameStartChanged)
+	uint32 TimeToGameStart = 5;
+	
+	UPROPERTY(EditDefaultsOnly, ReplicatedUsing = OnRep_MaxArmySizeChanged)
+	int32 MaxArmySize = 1500;
+	
+private:
+
+	bool IsEveryoneReady();
+
+	UFUNCTION()
+	void CountDown();
+	
+	UFUNCTION()
+	void OnRep_TimeToGameStartChanged();
+	
+	UFUNCTION()
+	void OnRep_MaxArmySizeChanged();
+
+	FTimerHandle GameStartDelay;
+
+	UPROPERTY()
+	class AGameSession_FantasyBattle* CastedSession;
+
+	virtual void GetLifetimeReplicatedProps(TArray<FLifetimeProperty> &OutLifetimeProps) const override;
+};
Index: Source/FantasyBattle/Private/UI_ArmyUnit.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// Fill out your copyright notice in the Description page of Project Settings.\r\n\r\n\r\n#include \"UI_ArmyUnit.h\"\r\n\r\nbool UUI_ArmyUnit::Initialize()\r\n{\r\n\tbool result = Super::Initialize();\r\n\tif (!result)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\r\n\tID = FGuid::NewGuid();\r\n\r\n\treturn true;\r\n}\r\n\r\nvoid UUI_ArmyUnit::AddProfile_Implementation(const EProfilePrio Prio, const FManProfile Profil)\r\n{\r\n\tProfiler.Add(Prio, Profil);\r\n\tif (Prio == EProfilePrio::E_Main)\r\n\t\tRecalcUnitValue();\r\n}\r\n\r\nvoid UUI_ArmyUnit::RecalcUnitValue()\r\n{\r\n\tfloat tempValue = (Profiler[EProfilePrio::E_Main].Antal * UnitProfil.ConstructionsValues.Points) + StaticExtraPoints;\r\n\tif (Profiler.Contains(EProfilePrio::E_Secondary))\r\n\t{\r\n\t\ttempValue += Profiler[EProfilePrio::E_Secondary].Antal * UnitProfil.ConstructionsValues.SecondaryPoints;\r\n\t}\r\n\tif (tempValue != UnitValue)\r\n\t{\r\n\t\tint32 Diffrence = tempValue - UnitValue;\r\n\t\tUnitValue = tempValue;\r\n\t\tUnitValueChanged(Diffrence);\r\n\t}\r\n}\r\n\r\nvoid UUI_ArmyUnit::AddAntal(EProfilePrio Prio, int32 NewAntal)\r\n{\r\n\tif (Profiler[Prio].Antal == NewAntal) return;\r\n\r\n\tProfiler[Prio].Antal = NewAntal;\r\n\tRecalcUnitValue();\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Source/FantasyBattle/Private/UI_ArmyUnit.cpp b/Source/FantasyBattle/Private/UI_ArmyUnit.cpp
--- a/Source/FantasyBattle/Private/UI_ArmyUnit.cpp	(revision 9b08c3c30042b95af90916955e891c673f23b32c)
+++ b/Source/FantasyBattle/Private/UI_ArmyUnit.cpp	(date 1641633312000)
@@ -2,6 +2,7 @@
 
 
 #include "UI_ArmyUnit.h"
+#include "Engine/DataTable.h"
 
 bool UUI_ArmyUnit::Initialize()
 {
@@ -23,6 +24,7 @@
 		RecalcUnitValue();
 }
 
+
 void UUI_ArmyUnit::RecalcUnitValue()
 {
 	float tempValue = (Profiler[EProfilePrio::E_Main].Antal * UnitProfil.ConstructionsValues.Points) + StaticExtraPoints;
@@ -32,9 +34,9 @@
 	}
 	if (tempValue != UnitValue)
 	{
-		int32 Diffrence = tempValue - UnitValue;
+		float Diffrence = tempValue - UnitValue;
 		UnitValue = tempValue;
-		UnitValueChanged(Diffrence);
+		UnitValueChanged(Diffrence, UnitProfil.Rarity);
 	}
 }
 
@@ -43,5 +45,70 @@
 	if (Profiler[Prio].Antal == NewAntal) return;
 
 	Profiler[Prio].Antal = NewAntal;
+	UnitAntalChanged(NewAntal, Prio);
+	RecalcUnitValue();
+}
+
+void UUI_ArmyUnit::AddStaticExtraValue(float AddValue)
+{
+	StaticExtraPoints += AddValue;
+
 	RecalcUnitValue();
 }
+
+void UUI_ArmyUnit::ChangeProfileCost(EProfilePrio Prio, float ExtraValue)
+{
+	if (Prio == EProfilePrio::E_Main)
+	{
+		UnitProfil.ConstructionsValues.Points += ExtraValue;
+	}
+	else if (Prio == EProfilePrio::E_Secondary)
+	{
+		UnitProfil.ConstructionsValues.SecondaryPoints += ExtraValue;
+	}
+	RecalcUnitValue();
+}
+
+void UUI_ArmyUnit::RemoveProfile(EProfilePrio Prio)
+{
+	Profiler.Remove(Prio);
+}
+
+TMap<EProfilePrio, FManProfile> UUI_ArmyUnit::LoadProfiles(const FMountUpgrade MountUpgrade, UDataTable* ProfilData, EProfilePrio Parent)
+{
+	TMap<EProfilePrio, FManProfile> tempProfiler;
+
+	FManProfile MountProfile = ProfilData->FindRow<FManProfile>(MountUpgrade.MountName, FString(""));
+	if (!MountProfile.ProfileName.IsEmpty())
+	{
+		MountProfile.Prio = EProfilePrio::E_Mount;
+		MountProfile.ParentPrio = EProfilePrio::E_Main;
+		tempProfiler.Add(EProfilePrio::E_Mount, MountProfile);
+	}
+
+	if (!MountUpgrade.SubUnitName.IsNone())
+	{
+		FManProfile SubProfile = ProfilData->FindRow<FManProfile>(MountUpgrade.SubUnitName, FString(""));
+		if (!SubProfile.ProfileName.IsEmpty())
+		{
+			SubProfile.Prio = EProfilePrio::E_Sub;
+			SubProfile.ParentPrio = EProfilePrio::E_Mount;
+			SubProfile.Antal = MountUpgrade.SubUnitCount;
+			tempProfiler.Add(EProfilePrio::E_Sub, SubProfile);
+		}
+	}
+
+	if (!MountUpgrade.SubMountName.IsNone())
+	{
+		FManProfile SubMountProfile = ProfilData->FindRow<FManProfile>(MountUpgrade.SubMountName, FString(""));
+		if (!SubMountProfile.ProfileName.IsEmpty())
+		{
+			SubMountProfile.Prio = EProfilePrio::E_SubMount;
+			SubMountProfile.ParentPrio = EProfilePrio::E_Mount;
+			SubMountProfile.Antal = MountUpgrade.SubMountCount;
+			tempProfiler.Add(EProfilePrio::E_SubMount, SubMountProfile);
+		}
+	}
+
+	return tempProfiler;
+}
Index: Source/FantasyBattle.Target.cs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// Copyright Epic Games, Inc. All Rights Reserved.\r\n\r\nusing UnrealBuildTool;\r\nusing System.Collections.Generic;\r\n\r\npublic class FantasyBattleTarget : TargetRules\r\n{\r\n\tpublic FantasyBattleTarget( TargetInfo Target) : base(Target)\r\n\t{\r\n\t\tType = TargetType.Game;\r\n\t\tDefaultBuildSettings = BuildSettingsVersion.V2;\r\n\t\tExtraModuleNames.AddRange( new string[] { \"FantasyBattle\" } );\r\n\t}\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Source/FantasyBattle.Target.cs b/Source/FantasyBattle.Target.cs
--- a/Source/FantasyBattle.Target.cs	(revision 9b08c3c30042b95af90916955e891c673f23b32c)
+++ b/Source/FantasyBattle.Target.cs	(date 1641762734000)
@@ -10,5 +10,6 @@
 		Type = TargetType.Game;
 		DefaultBuildSettings = BuildSettingsVersion.V2;
 		ExtraModuleNames.AddRange( new string[] { "FantasyBattle" } );
+		ProjectDefinitions.Add("ONLINE_SUBSYSTEM_EOS_ENABLE_STEAM=1");
 	}
 }
Index: Source/FantasyBattle/Public/Mode/GM_PreGame.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Source/FantasyBattle/Public/Mode/GM_PreGame.h b/Source/FantasyBattle/Public/Mode/GM_PreGame.h
new file mode 100644
--- /dev/null	(date 1643450512591)
+++ b/Source/FantasyBattle/Public/Mode/GM_PreGame.h	(date 1643450512591)
@@ -0,0 +1,39 @@
+// Fill out your copyright notice in the Description page of Project Settings.
+
+#pragma once
+
+#include "CoreMinimal.h"
+#include "GameFramework/GameModeBase.h"
+#include "GM_PreGame.generated.h"
+
+/**
+ * 
+ */
+UCLASS()
+class FANTASYBATTLE_API AGM_PreGame : public AGameModeBase
+{
+	GENERATED_BODY()
+
+public:
+
+	AGM_PreGame();
+
+	virtual void InitGame(const FString& MapName, const FString& Options, FString& ErrorMessage) override;
+
+	virtual void PostLogin(APlayerController* NewPlayer) override;
+	
+	UFUNCTION()
+	void SessionCreated(FName SessionName, bool bWasSuccessful);
+
+	UFUNCTION()
+	void StartGame();
+private:
+
+
+	bool bAllExistingPlayersRegistered;
+	FName CurrentSessionName;
+
+	class IOnlineSubsystem* OnlineSubsystem;
+
+	TArray<class APC_FantasyBattle_PreGame*> Players;
+};
